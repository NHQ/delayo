;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
var inherits = require('inherits')
var emitter = require('events').EventEmitter
var fs = require('fs');
var appendCSS = require('../uxer/appendCSS');

var css = "html, body, div, p, pre, img, audio, video, h1, h2, h3, h4, form, fieldset, label, legend, span\n{\n-webkit-box-sizing: border-box;\nbox-sizing: border-box;\nmargin:0;\npadding:0;\n-webkit-margin-start: 2px;\n-webkit-margin-end: 2px;\n-webkit-padding-before: 0.35em;\n-webkit-padding-start: 0.75em;\n-webkit-padding-end: 0.75em;\n-webkit-padding-after: 0.625em;\nfont-family:monospace;\n}\n.sourceCapture{\n  width: 85%;\n  height: 85%;\n  border-width: 16px;\n}\n\n.sourceCapOpts{\n  float:left;\n  width: 33%;\n  height: 100%;\n  border-right:16px solid OrangeRed;\n  -webkit-box-sizing: border-box;\n\n}\n\n.sourceCapOptsLabel {\n  height: 25%;\n}\n\n.sourceCapMode{\n  float: right;\n  width:66%;\n  height:100%;\n  -webkit-box-sizing: border-box;\n  overflow:hidden\n}";
var png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQ0JGMDc5OTdCMDIxMUUyOUMwM0YzNzJBNzhGMTlFMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQ0JGMDc5QTdCMDIxMUUyOUMwM0YzNzJBNzhGMTlFMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBDQkYwNzk3N0IwMjExRTI5QzAzRjM3MkE3OEYxOUUxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBDQkYwNzk4N0IwMjExRTI5QzAzRjM3MkE3OEYxOUUxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+eatsnwAAAmRJREFUeNq8lk1IVFEUx58z5pQKOjpg4CIX6dA0CzFaiTmGEoWUGy2k2uQiN0K4kYgKP0AKJBJXQZsWo5K4kWbAwo/aJgNBEJnooigpP9ACEa3/jfNiGs5977w3Mx74MXA/3vvNvfede3LCZ1oMiwiCVhABIRAAe+AbeAemwShYNVxGjkbgOHgILqkxNs/YAU/BXfDdqYCHaeugf9cieLkKH+ikOWfTFbgHnoDDLlbzKIiBi24FboD7RnqRB6KgWjohl36PgWGLcZvgJVgBXlBFy+1jxuaDSXAS/JIK9IMjTL868QN0ILeZJVftV5l5FaAb9Em2QJ34ds3LL9O52Gb6v4JrFtvWRVtiK3BF8zWoVZkQbGMvHb7UUDmjSSIQYdq3aHkl8Rvc1vQ1SARCTLvKcD8dnP4EWGbaT0gESpn2JRef4CLTViIR2GfavS4EuDm7EgEuf4dcZFRuzifJxATTrg5mmQMB3fhZicArzQXzwEH6HdTkkZhEIEpXampcB7cEmVRdXqeZvrikTvBQcTGi6R8CY1SY/FdHgFowR6JcPHNyGQ3QgwLMmDbiA/gIDoEwKBdsjVhgjfL6lMUnGGRWwioeg/fgrbQeiNPNtmtkJoopo55yUhGpAvMc+JIhCb+dBHcLzoBKcAds2LxgnwoVtX03Nde2KVHjpCo2QxUpzaCeMl0RVTkqw72h7/xz0vg68AIUMs9aB41gwYmAm6gjsQKJhMfIfLwG5zXXuZ+2rCabAhKJf2ciWwJ2EiWmRDYFJBLPsy1gSlzQSIwfhICKeUbiEeg5KIFkiR9Ucf+96v8IMAAR3HjwBE//uQAAAABJRU5ErkJggg==";

var loadSrc = require('./loadSrc')

appendCSS(css, 'synthFM')
 
var app = new emitter();
//inherits(app, emitter);

app.master = window.master = new webkitAudioContext();
app.sources = []
app.synths = []
app.user = {}
app.micLine = null
app.loadSrc = loadSrc(app)

app.loadSrc(function(err, src){
    console.log(err, src)
})
 
app.on('error', function(err){
    console.log(err)
})

},{"../uxer/appendCSS":9,"./loadSrc":3,"events":30,"fs":31,"inherits":23}],2:[function(require,module,exports){
module.exports = function(css, id){
    var es = document.getElementById(id);

    if(es){
	return false
//	es.parentNode.insertBefore(makeStyle(css), es.nextSibling)
    }
    else{
	var styleSheet = makeStyle(css, id)
	document.head.insertBefore(styleSheet, document.head.childNodes[0]);
	return styleSheet
    }

}


function makeStyle(str, id){
    var style = document.createElement('style');
    style.id = id || '';
    style.textContent = str;
    return style
}

},{}],3:[function(require,module,exports){
var sourceSelect = require('./sourceCap');
var sourceEvents = require('./sourceEvent');
var overlay = require('./overlay');

module.exports = function(app){

	// this should initialize the source capture view
	// allowing user to select from source options
	// src is an object
	// when the src loads, or starts loading,
	// the cb will be called with (err, src)
	// and the src will appended to app.sources
	// and the previous view will be restored 

    var sourceSelectElement = sourceSelect(sourceEvents(app));
//    var overlay = overlay
//    var app = app

    return function(cb){
	
	var oley = overlay(sourceSelectElement)

	oley.emit('show');

	app.once('sourceCap', function(err, src){
	    oley.emit('remove');
	    if(src) app.sources.push(src)
	    if(err) app.emit('error', err)
	    app.removeAllListeners('cancel')
	    cb(err, src)
	})

	app.once('cancel', function(){
	    app.removeAllListeners('sourceCap')
	    oley.emit('remove');
	})
    }
}

},{"./overlay":4,"./sourceCap":5,"./sourceEvent":6}],4:[function(require,module,exports){
var ee = require('events').EventEmitter
var fs = require('fs')
var html = require('hyperscript')
var center = require('../uxer/center')
var css = ".overlay {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background-color: #1d1d1d;\n  z-index: 1111111111;\n  border: none;\n  padding: 0;\n  margin: 0;  \n}\n";
var appendCSS = require('./appendCSS')

appendCSS(css)

var overlay = html('div.overlay');

module.exports = function(el){

    var em = new ee();

    em.on('show', function(){

	document.body.appendChild(overlay)

	overlay.appendChild(el);

	center(el)
	
    })

    em.on('remove', function(){
	
	document.body.removeChild(overlay)

	overlay.removeChild(el)

    })

    return em

}

},{"../uxer/center":10,"./appendCSS":2,"events":30,"fs":31,"hyperscript":16}],5:[function(require,module,exports){
var fs = require('fs');
var css = ".uxer-flat-fieldset {\n        color:OrangeRed;\n\tborder-radius:5px;\n\tpadding:0;\n\tmargin:0;\n\twidth:100%;\n\theight:100%;\n\tborder: 1px solid OrangeRed;\n\tborder-radius: 9px;\n}\n\n.uxer-flatfield-legend {\n        font-weight: 900;\n\tpadding:0 10px;\n\tfont-size:16px;\n\tline-height:16px;\n\tfont-style: italic;\n\ttext-align:center;\n}\n\n.uxer-flatfield-label {\n\tdisplay:block;\n\tborder-bottom: 1px solid rgba(200, 66, 0, .2);\n}\n\n.uxer-flatfield-label:hover, p.uxer-flatfield-radio-name:hover {\n\tcursor:pointer;\n}\n\n.uxer-flatfield-input[type=checkbox], .uxer-flatfield-input[type=radio],.uxer-flatfield-input[type=file], .uxer-flatfield-input[type=button]   {\n\tdisplay:none;\n}\n\n.uxer-flatfield-input[type=text], .uxer-flatfield-input[type=number], .uxer-flatfield-input[type=url]{\n    width: 100%;\n    color: OrangeRed;\n    font-size:16px;\n    font-weight:500;\n    padding:3px 0;\n    text-decoration:uppercase;\n    line-height:22px;\n    font-style: italic;\n    margin: 5px 0;\n    border:1px solid rgba(210, 66, 0, 0.2);\n    text-indent: 3px;\n}\n\n.uxer-flatfield-input[type=text]:focus, .uxer-flatfield-input[type=number]:focus, .uxer-flatfield-input[type=url]:focus{\n   outline:1px solid rgba(210, 66, 0, 0.2)\n}\n\n::-webkit-input-placeholder{\n    color: OrangeRed;\n    opacity: .38;\n    font-weight:900;\n}\n\ninput:focus::-webkit-input-placeholder{\n    color: rgba(0,0,0,0);\n}\n\n.uxer-flat-button{\n  min-width:40%;\n  font-size: 16px;\n  color: inherit;\n  outline:none;\n  border: 1px solid OrangeRed;\n  background: inherit;\n\n  border-radius: 3px;\n}\n.uxer-flat-button:active{\n  background: OrangeRed;\n  color: #eee;\n}\n.uxer-flatfield-radio-value, .uxer-flatfield-file-value {\n\tfont-size:16px;\n\tfont-weight:900;\n\tline-height:22px;\n}\n\n.uxer-flatfield-input[type=radio]:checked  + .uxer-flatfield-radio, .uxer-flatfield-input[type=radio]:checked ~ label{\n\tbackground:LimeGreen;\n}\n\n.uxer-flatfield-radio {\n\twidth:16px;\n\theight:16px;\n\tbackground:inherit;\n\tfloat:left;\n\tborder-radius:50%;\n\tborder:2px solid OrangeRed;\n}\n\n\n\n\n";
var html = require('hyperscript');
var touchdown = require('touchdown');
var appendCSS = require('../uxer/appendCSS');
var hover = require('mouse-around')

module.exports = function(sourceEvents){

    var change = sourceEvents.change;
    var click = sourceEvents.click;
    
    appendCSS(css, 'uxer-flatfield')

    var _fieldset = html('fieldset.uxer-flat-fieldset.sourceCapture');
    var _legend =  html('legend.uxer-flatfield-legend', '+ ADD AUDIO SOURCE +')

    _fieldset.appendChild(_legend);

    var options = html('div.sourceCapOpts')
    _fieldset.appendChild(options);
  
    var mode = html('div.sourceCapMode')
    _fieldset.appendChild(mode);
 
    var samplesLabel = html('label.uxer-flatfield-label.sourceCapOptsLabel');
    var samples = html('button.uxer-flat-button', 
		       {textContent: 'LOAD SAMPLES',
			name: 'samplebank',
			ontouchdown: function(e){click.call(samples, e)}
		       });

    hover(_fieldset, function(evt, node, pos, start, stop){ })
    touchdown.start(samples);
    samplesLabel.appendChild(samples);
    options.appendChild(samplesLabel);


    var ytextLabel = html('div.uxer-flatfield-label.sourceCapOptsLabel');
    var ytext = html('input.uxer-flatfield-input', 
		     {value: 'http://www.youtube.com/watch?v=1OixqPThDNE', 
		      placeholder: 'PASTE YOUTUBE LINK',
		      type: 'url',
		      name: 'sourceURL'
		     });
    var ytextModeButton = html('button.uxer-flat-button',
			   {textContent: 'USE INTERNET AUDIO', 
			    ontouchdown: function(e){e.preventDefault();click.call(ytext, e)}
			    });

    var ytextModeInfo = html('p.infoHelp', 
      [ 'You can load audio from almost anywhere on the internet: youtube, vimeo, soundcloud, bandcamp, synth.fm, or a direct link to an audio or video file. Soon you\'ll be able to search those same sources for multiple results, and even capture live ogg/mp3 streams.' 
      , html('br')
      , html('br')
      , html('h3', 'Examples:')
      , html('ul', [
	  html('li', 'http://www.youtube.com/watch?v=1OixqPThDNE'),
	  html('li', 'http://synth.fm/UdP4RuL3z')
      ])
      , html('h3', 'Supported audio File Types:')
      , html('ul', ['mp3', 'wav', 'ogg', 'aac'].map(function(k){
	    return html('li', k)
	}))
      ]) 

    var fileModeInfo = html('p.infoHelp', [
	html('h3', 'Load one or more files from your computer'),
	html('h3', 'Supported File Types:'),
	html('ul', ['mp3', 'wav', 'ogg', 'aac'].map(function(k){
	    return html('li', k)
	}))
    ]) 

    var ytextMode = html('div#sourceURL');
    var fileMode = html('div#soureceFile');
    var micLineMode = html('div#sourceMicLine');
    var sampleMode = html('div#sourceSample');

    mode.appendChild(ytextMode);
    mode.appendChild(fileMode);
    mode.appendChild(micLineMode);
    mode.appendChild(sampleMode);

    fileMode.appendChild(fileModeInfo);

    ytextLabel.appendChild(ytext);
    ytextMode.appendChild(ytextLabel)
    ytextMode.appendChild(ytextModeInfo)

    var ytextOptionLabel = html('div.uxer-flatfield-label.sourceCapOptsLabel');
    var ytextOptionButton = html('button.uxer-flat-button',
			   {textContent: 'USE INTERNET AUDIO', 
			    ontouchdown: function(e){e.preventDefault();click.call(ytext, e)}
			    });

//    touchdown.start(ytextButton);
//    ytextLabel.appendChild(ytext);
    ytextOptionLabel.appendChild(ytextOptionButton);
    options.appendChild(ytextOptionLabel);

    var fileCapLabel = html('label.uxer-flatfield-label.sourceCapOptsLabel');
    var fileCap = html('input.uxer-flatfield-input', {type: 'file', name: 'file', onchange: change});
    var fileCapButton = html('button.uxer-flat-button',
			   {textContent: 'OPEN A LOCAL AUDIO FILE', 
			    name: 'file'
			    });


    touchdown.start(fileCapButton);
    fileCapLabel.appendChild(fileCap);
    fileCapLabel.appendChild(fileCapButton);
    options.appendChild(fileCapLabel);


    var miclineLabel = html('label.uxer-flatfield-label.sourceCapOptsLabel');
    var micline = html('button.uxer-flat-button', 
		       {textContent: 'CAPTURE MIC / LINE-IN',
			name: 'line', 
			ontouchdown: function(e){click.call(micline, e)}
		       });


    touchdown.start(micline);
    miclineLabel.appendChild(micline);
    options.appendChild(miclineLabel);

    var playbuttonLabel = html('label.uxer-flatfield-label');
    var playbutton = html('button.uxer-flat-button', 
		       {textContent: 'PLAY',
			name: 'play',
			ontouchdown: function(e){click.call(playbutton, e)}
		       });

 //   touchdown.start(playbutton);
 //   playbuttonLabel.appendChild(playbutton);
 //   _fieldset.appendChild(playbuttonLabel);
    
    document.body.appendChild(_fieldset)

    var fset = _fieldset;

    return _fieldset;

}

function makeStyle(str){
  var style = document.createElement('style');
  style.id = 'uxer-flatfield-style';
  style.textContent = str;
  return style
}

function preventDefault(e){e.preventDefault()};

},{"../uxer/appendCSS":9,"fs":31,"hyperscript":16,"mouse-around":24,"touchdown":26}],6:[function(require,module,exports){
var url = require('url');
var ssn = require('./synth-server-node');
var hyperquest = require('hyperquest');

module.exports = function(app){

    var context = app.master;

    return {change: change, click: click}

    function change(e){
	if(this.name == 'url') return
	if(this.name == 'file'){

	    if(this.files[0].size > 1920000){
		var audio = new Audio();
		audio.src = window.URL.createObjectURL(this.files[0]);
		audio.addEventListener('canplay', function(){
		    var source = context.createMediaElementSource(audio);
		    app.emit('sourceCap', null, source)
		}, true)
	    }
	    else{
		var reader = new FileReader();
		reader.onload = function(e){
		    var buffer = e.target.result;
		    var source = context.createBufferSource();
		    try{
			var buf = context.createBuffer(buffer, true);
			source.buffer = buf;
			app.emit('sourceCap', null, source)
		    } 
		    catch(e){
			var err = new Error('Error: Probably an unsupported file type.')
			app.emit('sourceCap', err, null)
			// and this is where you would decode it with Aurora ...
		    }
		};
		try{
		    reader.readAsArrayBuffer(this.files[0]);
		} 
		catch(e){
		    var err = new Error('Error: Probably an unsupported file type.')
		    app.emit('sourceCap', err, null)
		}
	    }
	}
    }

    function click(e){

	if(this.name == 'url'){
	    e.preventDefault();
	    var uri = this.value;
	    if(uri.length){
		var parsed = url.parse(uri, true);
		
		if(((parsed.slashes || parsed.protocol) && (parsed.hostname.match('youtube.com'))) || 
		   (parsed.pathname && parsed.pathname.match('youtube.com'))) {

		    if(Modernizr.touch){

			var source = ssn(master, uri, function(err, source){
			    app.emit('sourceCap', err, source)
			});

		    }

		    else{

			// this is not gonna happen...
			var id = parsed.hostname === 'youtu.be' 
			    ? parsed.pathname.slice(1) : parsed.query.v;

			hyperquest('http://localhost:11002/get_info?'+uri, function(err, res){
			    res.on('data', function(data){

				var URI = data;
				var video = document.createElement('video');
				video.src = URI;
				video.addEventListener('loadstart', function(){
				    var source = context.createMediaElementSource(video);
				    app.emit('sourceCap', null, source)
				});

			    })
			})

		    }
		}
		else console.log('nup');
	    }
	}
	if(this.name == 'file'){
	}
	if(this.name == 'line'){ // getUserMedia
	    navigator.webkitGetUserMedia({audio: true, video: false}, function(stream){
		var source = context.createMediaStreamSource(stream);
		app.emit('sourceCap', null, source);
	    })
	}
    }


    function makeStyle(str){
	var style = document.createElement('style');
	style.id = 'uxer-flatfield-style';
	style.textContent = str;
	return style
    }

    function preventDefault(e){e.preventDefault()};
}

},{"./synth-server-node":8,"hyperquest":13,"url":35}],7:[function(require,module,exports){
module.exports = floatConcat

function floatConcat(first, second)
{

    if(!first) return second;

    var firstLength = first.length;
    var result = new Float32Array(firstLength + second.length);

    result.set(first);
    result.set(second, firstLength);

    return result;
}

},{}],8:[function(require,module,exports){
(function(){webkitAudioContext.prototype.createScriptProcessor = webkitAudioContext.prototype.createJavaScriptNode
if(!window.URL) window.URL = {createObjectURL: window.webkitURL.createObjectURL}

var fs = require('fs');
var enslave = require('work-slave');
var buffers = require('buffers');

var floatConcat = require('./floatConcat.js');

var worker = "this.onmessage = function(evt){\n\n    var self = this;\n    var evt = evt;\n    var sampleRate = evt.data.sampleRate;\n    var resamplers = [];\n    var id = evt.data.id;\n    var chans = 1;\n\n    var player = AV.Asset.fromURL('http://10.0.0.3:11002/youtube?' + evt.data.uri);\n\n    player.on('format', function(d){\n\n\n\td.sourceLength = player.source.length;\n\tchans = d.channelsPerFrame;\n\n\tvar bufferSize = Math.ceil(4096 / (sampleRate / d.sampleRate));\n\n\tfor(var x = 0; x < chans; x++){\n\t    resamplers[x] = new Resampler(d.sampleRate, sampleRate, 1, bufferSize);\n\t}\n\t\n\tself.postMessage({type: 'meta', data: d});\n\n    });\n\n    player.on('meta', function(d){\n\tself.postMessage({id: id, type: 'meta', data: d})\n    });\n\n    player.on('progress', function(evt){\n\tself.postMessagae({id: id, type: 'progress', data: evt})\n    });\n\n    player.on('data', function(bufArray){\n        for(x in resamplers){\n\t    bufArray[x] = resamplers[x].resampler(bufArray[x])\n\t}\n\tself.postMessage({id: id, buffer: bufArray})\n    });\n\n    player.on('end', function(){\n\tself.postMessage({id: id, type: 'end'})\n    });\n\n    player.start();\n}\n\n";
var aurora = "/*\n * This resampler is from XAudioJS: https://github.com/grantgalitz/XAudioJS\n * Planned to be replaced with src.js, eventually: https://github.com/jussi-kalliokoski/src.js\n */\n\n//JavaScript Audio Resampler (c) 2011 - Grant Galitz\nfunction Resampler(fromSampleRate, toSampleRate, channels, outputBufferSize, noReturn) {\n\tthis.fromSampleRate = fromSampleRate;\n\tthis.toSampleRate = toSampleRate;\n\tthis.channels = channels | 0;\n\tthis.outputBufferSize = outputBufferSize;\n\tthis.noReturn = !!noReturn;\n\tthis.initialize();\n}\n\nResampler.prototype.initialize = function () {\n\t//Perform some checks:\n\tif (this.fromSampleRate > 0 && this.toSampleRate > 0 && this.channels > 0) {\n\t\tif (this.fromSampleRate == this.toSampleRate) {\n\t\t\t//Setup a resampler bypass:\n\t\t\tthis.resampler = this.bypassResampler;\t\t//Resampler just returns what was passed through.\n\t\t\tthis.ratioWeight = 1;\n\t\t}\n\t\telse {\n\t\t\tif (this.fromSampleRate < this.toSampleRate) {\n\t\t\t\t/*\n\t\t\t\t\tUse generic linear interpolation if upsampling,\n\t\t\t\t\tas linear interpolation produces a gradient that we want\n\t\t\t\t\tand works fine with two input sample points per output in this case.\n\t\t\t\t*/\n\t\t\t\tthis.compileLinearInterpolationFunction();\n\t\t\t\tthis.lastWeight = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t\tCustom resampler I wrote that doesn't skip samples\n\t\t\t\t\tlike standard linear interpolation in high downsampling.\n\t\t\t\t\tThis is more accurate than linear interpolation on downsampling.\n\t\t\t\t*/\n\t\t\t\tthis.compileMultiTapFunction();\n\t\t\t\tthis.tailExists = false;\n\t\t\t\tthis.lastWeight = 0;\n\t\t\t}\n\t\t\tthis.ratioWeight = this.fromSampleRate / this.toSampleRate;\n\t\t\tthis.initializeBuffers();\n\t\t}\n\t}\n\telse {\n\t\tthrow(new Error(\"Invalid settings specified for the resampler.\"));\n\t}\n};\n\nResampler.prototype.compileLinearInterpolationFunction = function () {\n\tvar toCompile = \"var bufferLength = buffer.length;\\\n\tvar outLength = this.outputBufferSize;\\\n\tif ((bufferLength % \" + this.channels + \") == 0) {\\\n\t\tif (bufferLength > 0) {\\\n\t\t\tvar ratioWeight = this.ratioWeight;\\\n\t\t\tvar weight = this.lastWeight;\\\n\t\t\tvar firstWeight = 0;\\\n\t\t\tvar secondWeight = 0;\\\n\t\t\tvar sourceOffset = 0;\\\n\t\t\tvar outputOffset = 0;\\\n\t\t\tvar outputBuffer = this.outputBuffer;\\\n\t\t\tfor (; weight < 1; weight += ratioWeight) {\\\n\t\t\t\tsecondWeight = weight % 1;\\\n\t\t\t\tfirstWeight = 1 - secondWeight;\";\n\tfor (var channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"outputBuffer[outputOffset++] = (this.lastOutput[\" + channel + \"] * firstWeight) + (buffer[\" + channel + \"] * secondWeight);\";\n\t}\n\ttoCompile += \"}\\\n\t\t\tweight -= 1;\\\n\t\t\tfor (bufferLength -= \" + this.channels + \", sourceOffset = Math.floor(weight) * \" + this.channels + \"; outputOffset < outLength && sourceOffset < bufferLength;) {\\\n\t\t\t\tsecondWeight = weight % 1;\\\n\t\t\t\tfirstWeight = 1 - secondWeight;\";\n\tfor (var channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"outputBuffer[outputOffset++] = (buffer[sourceOffset\" + ((channel > 0) ? (\" + \" + channel) : \"\") + \"] * firstWeight) + (buffer[sourceOffset + \" + (this.channels + channel) + \"] * secondWeight);\";\n\t}\n\ttoCompile += \"weight += ratioWeight;\\\n\t\t\t\tsourceOffset = Math.floor(weight) * \" + this.channels + \";\\\n\t\t\t}\";\n\tfor (var channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"this.lastOutput[\" + channel + \"] = buffer[sourceOffset++];\";\n\t}\n\ttoCompile += \"this.lastWeight = weight % 1;\\\n\t\t\treturn this.bufferSlice(outputOffset);\\\n\t\t}\\\n\t\telse {\\\n\t\t\treturn (this.noReturn) ? 0 : [];\\\n\t\t}\\\n\t}\\\n\telse {\\\n\t\tthrow(new Error(\\\"Buffer was of incorrect sample length.\\\"));\\\n\t}\";\n\tthis.resampler = Function(\"buffer\", toCompile);\n};\n\nResampler.prototype.compileMultiTapFunction = function () {\n\tvar toCompile = \"var bufferLength = buffer.length;\\\n\tvar outLength = this.outputBufferSize;\\\n\tif ((bufferLength % \" + this.channels + \") == 0) {\\\n\t\tif (bufferLength > 0) {\\\n\t\t\tvar ratioWeight = this.ratioWeight;\\\n\t\t\tvar weight = 0;\";\n\tfor (var channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"var output\" + channel + \" = 0;\"\n\t}\n\ttoCompile += \"var actualPosition = 0;\\\n\t\t\tvar amountToNext = 0;\\\n\t\t\tvar alreadyProcessedTail = !this.tailExists;\\\n\t\t\tthis.tailExists = false;\\\n\t\t\tvar outputBuffer = this.outputBuffer;\\\n\t\t\tvar outputOffset = 0;\\\n\t\t\tvar currentPosition = 0;\\\n\t\t\tdo {\\\n\t\t\t\tif (alreadyProcessedTail) {\\\n\t\t\t\t\tweight = ratioWeight;\";\n\tfor (channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"output\" + channel + \" = 0;\"\n\t}\n\ttoCompile += \"}\\\n\t\t\t\telse {\\\n\t\t\t\t\tweight = this.lastWeight;\";\n\tfor (channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"output\" + channel + \" = this.lastOutput[\" + channel + \"];\"\n\t}\n\ttoCompile += \"alreadyProcessedTail = true;\\\n\t\t\t\t}\\\n\t\t\t\twhile (weight > 0 && actualPosition < bufferLength) {\\\n\t\t\t\t\tamountToNext = 1 + actualPosition - currentPosition;\\\n\t\t\t\t\tif (weight >= amountToNext) {\";\n\tfor (channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"output\" + channel + \" += buffer[actualPosition++] * amountToNext;\"\n\t}\n\ttoCompile += \"currentPosition = actualPosition;\\\n\t\t\t\t\t\tweight -= amountToNext;\\\n\t\t\t\t\t}\\\n\t\t\t\t\telse {\";\n\tfor (channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"output\" + channel + \" += buffer[actualPosition\" + ((channel > 0) ? (\" + \" + channel) : \"\") + \"] * weight;\"\n\t}\n\ttoCompile += \"currentPosition += weight;\\\n\t\t\t\t\t\tweight = 0;\\\n\t\t\t\t\t\tbreak;\\\n\t\t\t\t\t}\\\n\t\t\t\t}\\\n\t\t\t\tif (weight == 0) {\";\n\tfor (channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"outputBuffer[outputOffset++] = output\" + channel + \" / ratioWeight;\"\n\t}\n\ttoCompile += \"}\\\n\t\t\t\telse {\\\n\t\t\t\t\tthis.lastWeight = weight;\";\n\tfor (channel = 0; channel < this.channels; ++channel) {\n\t\ttoCompile += \"this.lastOutput[\" + channel + \"] = output\" + channel + \";\"\n\t}\n\ttoCompile += \"this.tailExists = true;\\\n\t\t\t\t\tbreak;\\\n\t\t\t\t}\\\n\t\t\t} while (actualPosition < bufferLength && outputOffset < outLength);\\\n\t\t\treturn this.bufferSlice(outputOffset);\\\n\t\t}\\\n\t\telse {\\\n\t\t\treturn (this.noReturn) ? 0 : [];\\\n\t\t}\\\n\t}\\\n\telse {\\\n\t\tthrow(new Error(\\\"Buffer was of incorrect sample length.\\\"));\\\n\t}\";\n\tthis.resampler = Function(\"buffer\", toCompile);\n};\n\nResampler.prototype.bypassResampler = function (buffer) {\n\tif (this.noReturn) {\n\t\t//Set the buffer passed as our own, as we don't need to resample it:\n\t\tthis.outputBuffer = buffer;\n\t\treturn buffer.length;\n\t}\n\telse {\n\t\t//Just return the buffer passsed:\n\t\treturn buffer;\n\t}\n};\n\nResampler.prototype.bufferSlice = function (sliceAmount) {\n\tif (this.noReturn) {\n\t\t//If we're going to access the properties directly from this object:\n\t\treturn sliceAmount;\n\t}\n\telse {\n\t\t//Typed array and normal array buffer section referencing:\n\t\ttry {\n\t\t\treturn this.outputBuffer.subarray(0, sliceAmount);\n\t\t}\n\t\tcatch (error) {\n\t\t\ttry {\n\t\t\t\t//Regular array pass:\n\t\t\t\tthis.outputBuffer.length = sliceAmount;\n\t\t\t\treturn this.outputBuffer;\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\t//Nightly Firefox 4 used to have the subarray function named as slice:\n\t\t\t\treturn this.outputBuffer.slice(0, sliceAmount);\n\t\t\t}\n\t\t}\n\t}\n};\n\nResampler.prototype.initializeBuffers = function () {\n\t//Initialize the internal buffer:\n\ttry {\n\t\tthis.outputBuffer = new Float32Array(this.outputBufferSize);\n\t\tthis.lastOutput = new Float32Array(this.channels);\n\t}\n\tcatch (error) {\n\t\tthis.outputBuffer = [];\n\t\tthis.lastOutput = [];\n\t}\n};\n\n(function() {\n  var global;\n\n  global = this;\n  var AV;\n\nAV = {};\n\nvar __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nAV.Base = (function() {\n  var fnTest;\n\n  function Base() {}\n\n  fnTest = /\\b_super\\b/;\n\n  Base.extend = function(prop) {\n    var Class, fn, key, keys, _ref, _ref1, _super;\n\n    Class = (function(_super) {\n      __extends(Class, _super);\n\n      function Class() {\n        _ref = Class.__super__.constructor.apply(this, arguments);\n        return _ref;\n      }\n\n      return Class;\n\n    })(this);\n    if (typeof prop === 'function') {\n      keys = Object.keys(Class.prototype);\n      prop.call(Class, Class);\n      prop = {};\n      _ref1 = Class.prototype;\n      for (key in _ref1) {\n        fn = _ref1[key];\n        if (__indexOf.call(keys, key) < 0) {\n          prop[key] = fn;\n        }\n      }\n    }\n    _super = Class.__super__;\n    for (key in prop) {\n      fn = prop[key];\n      if (typeof fn === 'function' && fnTest.test(fn)) {\n        (function(key, fn) {\n          return Class.prototype[key] = function() {\n            var ret, tmp;\n\n            tmp = this._super;\n            this._super = _super[key];\n            ret = fn.apply(this, arguments);\n            this._super = tmp;\n            return ret;\n          };\n        })(key, fn);\n      } else {\n        Class.prototype[key] = fn;\n      }\n    }\n    return Class;\n  };\n\n  return Base;\n\n})();\n//import \"core/base.coffee\";\n\nAV.Buffer = (function() {\n  var BlobBuilder, URL;\n\n  function Buffer(data) {\n    this.data = data;\n    this.length = this.data.length;\n    this.next = null;\n    this.prev = null;\n  }\n\n  Buffer.allocate = function(size) {\n    return new AV.Buffer(new Uint8Array(size));\n  };\n\n  Buffer.prototype.copy = function() {\n    return new AV.Buffer(new Uint8Array(this.data));\n  };\n\n  Buffer.prototype.slice = function(position, length) {\n    if (position === 0 && length >= this.length) {\n      return new AV.Buffer(this.data);\n    } else {\n      return new AV.Buffer(this.data.subarray(position, position + length));\n    }\n  };\n\n  BlobBuilder = global.BlobBuilder || global.MozBlobBuilder || global.WebKitBlobBuilder;\n\n  URL = global.URL || global.webkitURL || global.mozURL;\n\n  Buffer.makeBlob = function(data, type) {\n    var bb;\n\n    if (type == null) {\n      type = 'application/octet-stream';\n    }\n    try {\n      return new Blob([data], {\n        type: type\n      });\n    } catch (_error) {}\n    if (BlobBuilder != null) {\n      bb = new BlobBuilder;\n      bb.append(data);\n      return bb.getBlob(type);\n    }\n    return null;\n  };\n\n  Buffer.makeBlobURL = function(data, type) {\n    return URL != null ? URL.createObjectURL(this.makeBlob(data, type)) : void 0;\n  };\n\n  Buffer.revokeBlobURL = function(url) {\n    return URL != null ? URL.revokeObjectURL(url) : void 0;\n  };\n\n  Buffer.prototype.toBlob = function() {\n    return Buffer.makeBlob(this.data.buffer);\n  };\n\n  Buffer.prototype.toBlobURL = function() {\n    return Buffer.makeBlobURL(this.data.buffer);\n  };\n\n  return Buffer;\n\n})();\n//import \"core/buffer.coffee\";\n\nAV.BufferList = (function() {\n  function BufferList() {\n    this.first = null;\n    this.last = null;\n    this.availableBytes = 0;\n    this.availableBuffers = 0;\n  }\n\n  BufferList.prototype.copy = function() {\n    var result;\n\n    result = new AV.BufferList;\n    result.first = this.first;\n    result.last = this.last;\n    result.availableBytes = this.availableBytes;\n    result.availableBuffers = this.availableBuffers;\n    return result;\n  };\n\n  BufferList.prototype.append = function(buffer) {\n    var _ref, _ref1;\n\n    buffer.prev = this.last;\n    if ((_ref = this.last) != null) {\n      _ref.next = buffer;\n    }\n    this.last = buffer;\n    if ((_ref1 = this.first) == null) {\n      this.first = buffer;\n    }\n    this.availableBytes += buffer.length;\n    return this.availableBuffers++;\n  };\n\n  BufferList.prototype.advance = function() {\n    if (this.first) {\n      this.availableBytes -= this.first.length;\n      this.availableBuffers--;\n      return this.first = this.first.next;\n    }\n  };\n\n  BufferList.prototype.rewind = function() {\n    var _ref;\n\n    if (this.first && !this.first.prev) {\n      return;\n    }\n    this.first = ((_ref = this.first) != null ? _ref.prev : void 0) || this.last;\n    if (this.first) {\n      this.availableBytes += this.first.length;\n      return this.availableBuffers++;\n    }\n  };\n\n  return BufferList;\n\n})();\n//import \"core/bufferlist.coffee\";\n\nvar __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.Stream = (function() {\n  var buf, decodeString, float32, float64, float64Fallback, float80, int16, int32, int8, nativeEndian, uint16, uint32, uint8;\n\n  buf = new ArrayBuffer(16);\n\n  uint8 = new Uint8Array(buf);\n\n  int8 = new Int8Array(buf);\n\n  uint16 = new Uint16Array(buf);\n\n  int16 = new Int16Array(buf);\n\n  uint32 = new Uint32Array(buf);\n\n  int32 = new Int32Array(buf);\n\n  float32 = new Float32Array(buf);\n\n  if (typeof Float64Array !== \"undefined\" && Float64Array !== null) {\n    float64 = new Float64Array(buf);\n  }\n\n  nativeEndian = new Uint16Array(new Uint8Array([0x12, 0x34]).buffer)[0] === 0x3412;\n\n  AV.UnderflowError = (function(_super) {\n    __extends(UnderflowError, _super);\n\n    function UnderflowError() {\n      this.name = 'AV.UnderflowError';\n    }\n\n    return UnderflowError;\n\n  })(Error);\n\n  function Stream(list) {\n    this.list = list;\n    this.localOffset = 0;\n    this.offset = 0;\n  }\n\n  Stream.fromBuffer = function(buffer) {\n    var list;\n\n    list = new AV.BufferList;\n    list.append(buffer);\n    return new AV.Stream(list);\n  };\n\n  Stream.prototype.copy = function() {\n    var result;\n\n    result = new AV.Stream(this.list.copy());\n    result.localOffset = this.localOffset;\n    result.offset = this.offset;\n    return result;\n  };\n\n  Stream.prototype.available = function(bytes) {\n    return bytes <= this.list.availableBytes - this.localOffset;\n  };\n\n  Stream.prototype.remainingBytes = function() {\n    return this.list.availableBytes - this.localOffset;\n  };\n\n  Stream.prototype.advance = function(bytes) {\n    if (!this.available(bytes)) {\n      throw new AV.UnderflowError();\n    }\n    this.localOffset += bytes;\n    this.offset += bytes;\n    while (this.list.first && this.localOffset >= this.list.first.length) {\n      this.localOffset -= this.list.first.length;\n      this.list.advance();\n    }\n    return this;\n  };\n\n  Stream.prototype.rewind = function(bytes) {\n    if (bytes > this.offset) {\n      throw new AV.UnderflowError();\n    }\n    if (!this.list.first) {\n      this.list.rewind();\n      this.localOffset = this.list.first.length;\n    }\n    this.localOffset -= bytes;\n    this.offset -= bytes;\n    while (this.list.first.prev && this.localOffset < 0) {\n      this.list.rewind();\n      this.localOffset += this.list.first.length;\n    }\n    return this;\n  };\n\n  Stream.prototype.seek = function(position) {\n    if (position > this.offset) {\n      return this.advance(position - this.offset);\n    } else if (position < this.offset) {\n      return this.rewind(this.offset - position);\n    }\n  };\n\n  Stream.prototype.readUInt8 = function() {\n    var a;\n\n    if (!this.available(1)) {\n      throw new AV.UnderflowError();\n    }\n    a = this.list.first.data[this.localOffset];\n    this.localOffset += 1;\n    this.offset += 1;\n    if (this.localOffset === this.list.first.length) {\n      this.localOffset = 0;\n      this.list.advance();\n    }\n    return a;\n  };\n\n  Stream.prototype.peekUInt8 = function(offset) {\n    var buffer;\n\n    if (offset == null) {\n      offset = 0;\n    }\n    if (!this.available(offset + 1)) {\n      throw new AV.UnderflowError();\n    }\n    offset = this.localOffset + offset;\n    buffer = this.list.first;\n    while (buffer) {\n      if (buffer.length > offset) {\n        return buffer.data[offset];\n      }\n      offset -= buffer.length;\n      buffer = buffer.next;\n    }\n    return 0;\n  };\n\n  Stream.prototype.read = function(bytes, littleEndian) {\n    var i, _i, _j, _ref;\n\n    if (littleEndian == null) {\n      littleEndian = false;\n    }\n    if (littleEndian === nativeEndian) {\n      for (i = _i = 0; _i < bytes; i = _i += 1) {\n        uint8[i] = this.readUInt8();\n      }\n    } else {\n      for (i = _j = _ref = bytes - 1; _j >= 0; i = _j += -1) {\n        uint8[i] = this.readUInt8();\n      }\n    }\n  };\n\n  Stream.prototype.peek = function(bytes, offset, littleEndian) {\n    var i, _i, _j;\n\n    if (littleEndian == null) {\n      littleEndian = false;\n    }\n    if (littleEndian === nativeEndian) {\n      for (i = _i = 0; _i < bytes; i = _i += 1) {\n        uint8[i] = this.peekUInt8(offset + i);\n      }\n    } else {\n      for (i = _j = 0; _j < bytes; i = _j += 1) {\n        uint8[bytes - i - 1] = this.peekUInt8(offset + i);\n      }\n    }\n  };\n\n  Stream.prototype.readInt8 = function() {\n    this.read(1);\n    return int8[0];\n  };\n\n  Stream.prototype.peekInt8 = function(offset) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(1, offset);\n    return int8[0];\n  };\n\n  Stream.prototype.readUInt16 = function(littleEndian) {\n    this.read(2, littleEndian);\n    return uint16[0];\n  };\n\n  Stream.prototype.peekUInt16 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(2, offset, littleEndian);\n    return uint16[0];\n  };\n\n  Stream.prototype.readInt16 = function(littleEndian) {\n    this.read(2, littleEndian);\n    return int16[0];\n  };\n\n  Stream.prototype.peekInt16 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(2, offset, littleEndian);\n    return int16[0];\n  };\n\n  Stream.prototype.readUInt24 = function(littleEndian) {\n    if (littleEndian) {\n      return this.readUInt16(true) + (this.readUInt8() << 16);\n    } else {\n      return (this.readUInt16() << 8) + this.readUInt8();\n    }\n  };\n\n  Stream.prototype.peekUInt24 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    if (littleEndian) {\n      return this.peekUInt16(offset, true) + (this.peekUInt8(offset + 2) << 16);\n    } else {\n      return (this.peekUInt16(offset) << 8) + this.peekUInt8(offset + 2);\n    }\n  };\n\n  Stream.prototype.readInt24 = function(littleEndian) {\n    if (littleEndian) {\n      return this.readUInt16(true) + (this.readInt8() << 16);\n    } else {\n      return (this.readInt16() << 8) + this.readUInt8();\n    }\n  };\n\n  Stream.prototype.peekInt24 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    if (littleEndian) {\n      return this.peekUInt16(offset, true) + (this.peekInt8(offset + 2) << 16);\n    } else {\n      return (this.peekInt16(offset) << 8) + this.peekUInt8(offset + 2);\n    }\n  };\n\n  Stream.prototype.readUInt32 = function(littleEndian) {\n    this.read(4, littleEndian);\n    return uint32[0];\n  };\n\n  Stream.prototype.peekUInt32 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(4, offset, littleEndian);\n    return uint32[0];\n  };\n\n  Stream.prototype.readInt32 = function(littleEndian) {\n    this.read(4, littleEndian);\n    return int32[0];\n  };\n\n  Stream.prototype.peekInt32 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(4, offset, littleEndian);\n    return int32[0];\n  };\n\n  Stream.prototype.readFloat32 = function(littleEndian) {\n    this.read(4, littleEndian);\n    return float32[0];\n  };\n\n  Stream.prototype.peekFloat32 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(4, offset, littleEndian);\n    return float32[0];\n  };\n\n  Stream.prototype.readFloat64 = function(littleEndian) {\n    this.read(8, littleEndian);\n    if (float64) {\n      return float64[0];\n    } else {\n      return float64Fallback();\n    }\n  };\n\n  float64Fallback = function() {\n    var exp, frac, high, low, out, sign;\n\n    low = uint32[0], high = uint32[1];\n    if (!high || high === 0x80000000) {\n      return 0.0;\n    }\n    sign = 1 - (high >>> 31) * 2;\n    exp = (high >>> 20) & 0x7ff;\n    frac = high & 0xfffff;\n    if (exp === 0x7ff) {\n      if (frac) {\n        return NaN;\n      }\n      return sign * Infinity;\n    }\n    exp -= 1023;\n    out = (frac | 0x100000) * Math.pow(2, exp - 20);\n    out += low * Math.pow(2, exp - 52);\n    return sign * out;\n  };\n\n  Stream.prototype.peekFloat64 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(8, offset, littleEndian);\n    if (float64) {\n      return float64[0];\n    } else {\n      return float64Fallback();\n    }\n  };\n\n  Stream.prototype.readFloat80 = function(littleEndian) {\n    this.read(10, littleEndian);\n    return float80();\n  };\n\n  float80 = function() {\n    var a0, a1, exp, high, low, out, sign;\n\n    high = uint32[0], low = uint32[1];\n    a0 = uint8[9];\n    a1 = uint8[8];\n    sign = 1 - (a0 >>> 7) * 2;\n    exp = ((a0 & 0x7F) << 8) | a1;\n    if (exp === 0 && low === 0 && high === 0) {\n      return 0;\n    }\n    if (exp === 0x7fff) {\n      if (low === 0 && high === 0) {\n        return sign * Infinity;\n      }\n      return NaN;\n    }\n    exp -= 16383;\n    out = low * Math.pow(2, exp - 31);\n    out += high * Math.pow(2, exp - 63);\n    return sign * out;\n  };\n\n  Stream.prototype.peekFloat80 = function(offset, littleEndian) {\n    if (offset == null) {\n      offset = 0;\n    }\n    this.peek(10, offset, littleEndian);\n    return float80();\n  };\n\n  Stream.prototype.readBuffer = function(length) {\n    var i, result, to, _i;\n\n    result = AV.Buffer.allocate(length);\n    to = result.data;\n    for (i = _i = 0; _i < length; i = _i += 1) {\n      to[i] = this.readUInt8();\n    }\n    return result;\n  };\n\n  Stream.prototype.peekBuffer = function(offset, length) {\n    var i, result, to, _i;\n\n    if (offset == null) {\n      offset = 0;\n    }\n    result = AV.Buffer.allocate(length);\n    to = result.data;\n    for (i = _i = 0; _i < length; i = _i += 1) {\n      to[i] = this.peekUInt8(offset + i);\n    }\n    return result;\n  };\n\n  Stream.prototype.readSingleBuffer = function(length) {\n    var result;\n\n    result = this.list.first.slice(this.localOffset, length);\n    this.advance(result.length);\n    return result;\n  };\n\n  Stream.prototype.peekSingleBuffer = function(offset, length) {\n    var result;\n\n    result = this.list.first.slice(this.localOffset + offset, length);\n    return result;\n  };\n\n  Stream.prototype.readString = function(length, encoding) {\n    if (encoding == null) {\n      encoding = 'ascii';\n    }\n    return decodeString.call(this, 0, length, encoding, true);\n  };\n\n  Stream.prototype.peekString = function(offset, length, encoding) {\n    if (offset == null) {\n      offset = 0;\n    }\n    if (encoding == null) {\n      encoding = 'ascii';\n    }\n    return decodeString.call(this, offset, length, encoding, false);\n  };\n\n  decodeString = function(offset, length, encoding, advance) {\n    var b1, b2, b3, b4, bom, c, end, littleEndian, nullEnd, pt, result, w1, w2;\n\n    encoding = encoding.toLowerCase();\n    nullEnd = length === null ? 0 : -1;\n    if (length == null) {\n      length = Infinity;\n    }\n    end = offset + length;\n    result = '';\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n        while (offset < end && (c = this.peekUInt8(offset++)) !== nullEnd) {\n          result += String.fromCharCode(c);\n        }\n        break;\n      case 'utf8':\n      case 'utf-8':\n        while (offset < end && (b1 = this.peekUInt8(offset++)) !== nullEnd) {\n          if ((b1 & 0x80) === 0) {\n            result += String.fromCharCode(b1);\n          } else if ((b1 & 0xe0) === 0xc0) {\n            b2 = this.peekUInt8(offset++) & 0x3f;\n            result += String.fromCharCode(((b1 & 0x1f) << 6) | b2);\n          } else if ((b1 & 0xf0) === 0xe0) {\n            b2 = this.peekUInt8(offset++) & 0x3f;\n            b3 = this.peekUInt8(offset++) & 0x3f;\n            result += String.fromCharCode(((b1 & 0x0f) << 12) | (b2 << 6) | b3);\n          } else if ((b1 & 0xf8) === 0xf0) {\n            b2 = this.peekUInt8(offset++) & 0x3f;\n            b3 = this.peekUInt8(offset++) & 0x3f;\n            b4 = this.peekUInt8(offset++) & 0x3f;\n            pt = (((b1 & 0x0f) << 18) | (b2 << 12) | (b3 << 6) | b4) - 0x10000;\n            result += String.fromCharCode(0xd800 + (pt >> 10), 0xdc00 + (pt & 0x3ff));\n          }\n        }\n        break;\n      case 'utf16-be':\n      case 'utf16be':\n      case 'utf16le':\n      case 'utf16-le':\n      case 'utf16bom':\n      case 'utf16-bom':\n        switch (encoding) {\n          case 'utf16be':\n          case 'utf16-be':\n            littleEndian = false;\n            break;\n          case 'utf16le':\n          case 'utf16-le':\n            littleEndian = true;\n            break;\n          case 'utf16bom':\n          case 'utf16-bom':\n            if (length < 2 || (bom = this.peekUInt16(offset)) === nullEnd) {\n              if (advance) {\n                this.advance(offset += 2);\n              }\n              return result;\n            }\n            littleEndian = bom === 0xfffe;\n            offset += 2;\n        }\n        while (offset < end && (w1 = this.peekUInt16(offset, littleEndian)) !== nullEnd) {\n          offset += 2;\n          if (w1 < 0xd800 || w1 > 0xdfff) {\n            result += String.fromCharCode(w1);\n          } else {\n            if (w1 > 0xdbff) {\n              throw new Error(\"Invalid utf16 sequence.\");\n            }\n            w2 = this.peekUInt16(offset, littleEndian);\n            if (w2 < 0xdc00 || w2 > 0xdfff) {\n              throw new Error(\"Invalid utf16 sequence.\");\n            }\n            result += String.fromCharCode(w1, w2);\n            offset += 2;\n          }\n        }\n        if (w1 === nullEnd) {\n          offset += 2;\n        }\n        break;\n      default:\n        throw new Error(\"Unknown encoding: \" + encoding);\n    }\n    if (advance) {\n      this.advance(offset);\n    }\n    return result;\n  };\n\n  return Stream;\n\n})();\n//import \"core/stream.coffee\";\n\nAV.Bitstream = (function() {\n  function Bitstream(stream) {\n    this.stream = stream;\n    this.bitPosition = 0;\n  }\n\n  Bitstream.prototype.copy = function() {\n    var result;\n\n    result = new AV.Bitstream(this.stream.copy());\n    result.bitPosition = this.bitPosition;\n    return result;\n  };\n\n  Bitstream.prototype.offset = function() {\n    return 8 * this.stream.offset + this.bitPosition;\n  };\n\n  Bitstream.prototype.available = function(bits) {\n    return this.stream.available((bits + 8 - this.bitPosition) / 8);\n  };\n\n  Bitstream.prototype.advance = function(bits) {\n    var pos;\n\n    pos = this.bitPosition + bits;\n    this.stream.advance(pos >> 3);\n    return this.bitPosition = pos & 7;\n  };\n\n  Bitstream.prototype.rewind = function(bits) {\n    var pos;\n\n    pos = this.bitPosition - bits;\n    this.stream.rewind(Math.abs(pos >> 3));\n    return this.bitPosition = pos & 7;\n  };\n\n  Bitstream.prototype.seek = function(offset) {\n    var curOffset;\n\n    curOffset = this.offset();\n    if (offset > curOffset) {\n      return this.advance(offset - curOffset);\n    } else if (offset < curOffset) {\n      return this.rewind(curOffset - offset);\n    }\n  };\n\n  Bitstream.prototype.align = function() {\n    if (this.bitPosition !== 0) {\n      this.bitPosition = 0;\n      return this.stream.advance(1);\n    }\n  };\n\n  Bitstream.prototype.read = function(bits, signed) {\n    var a, a0, a1, a2, a3, a4, mBits;\n\n    if (bits === 0) {\n      return 0;\n    }\n    mBits = bits + this.bitPosition;\n    if (mBits <= 8) {\n      a = ((this.stream.peekUInt8() << this.bitPosition) & 0xff) >>> (8 - bits);\n    } else if (mBits <= 16) {\n      a = ((this.stream.peekUInt16() << this.bitPosition) & 0xffff) >>> (16 - bits);\n    } else if (mBits <= 24) {\n      a = ((this.stream.peekUInt24() << this.bitPosition) & 0xffffff) >>> (24 - bits);\n    } else if (mBits <= 32) {\n      a = (this.stream.peekUInt32() << this.bitPosition) >>> (32 - bits);\n    } else if (mBits <= 40) {\n      a0 = this.stream.peekUInt8(0) * 0x0100000000;\n      a1 = this.stream.peekUInt8(1) << 24 >>> 0;\n      a2 = this.stream.peekUInt8(2) << 16;\n      a3 = this.stream.peekUInt8(3) << 8;\n      a4 = this.stream.peekUInt8(4);\n      a = a0 + a1 + a2 + a3 + a4;\n      a %= Math.pow(2, 40 - this.bitPosition);\n      a = Math.floor(a / Math.pow(2, 40 - this.bitPosition - bits));\n    } else {\n      throw new Error(\"Too many bits!\");\n    }\n    if (signed) {\n      if (mBits < 32) {\n        if (a >>> (bits - 1)) {\n          a = ((1 << bits >>> 0) - a) * -1;\n        }\n      } else {\n        if (a / Math.pow(2, bits - 1) | 0) {\n          a = (Math.pow(2, bits) - a) * -1;\n        }\n      }\n    }\n    this.advance(bits);\n    return a;\n  };\n\n  Bitstream.prototype.peek = function(bits, signed) {\n    var a, a0, a1, a2, a3, a4, mBits;\n\n    if (bits === 0) {\n      return 0;\n    }\n    mBits = bits + this.bitPosition;\n    if (mBits <= 8) {\n      a = ((this.stream.peekUInt8() << this.bitPosition) & 0xff) >>> (8 - bits);\n    } else if (mBits <= 16) {\n      a = ((this.stream.peekUInt16() << this.bitPosition) & 0xffff) >>> (16 - bits);\n    } else if (mBits <= 24) {\n      a = ((this.stream.peekUInt24() << this.bitPosition) & 0xffffff) >>> (24 - bits);\n    } else if (mBits <= 32) {\n      a = (this.stream.peekUInt32() << this.bitPosition) >>> (32 - bits);\n    } else if (mBits <= 40) {\n      a0 = this.stream.peekUInt8(0) * 0x0100000000;\n      a1 = this.stream.peekUInt8(1) << 24 >>> 0;\n      a2 = this.stream.peekUInt8(2) << 16;\n      a3 = this.stream.peekUInt8(3) << 8;\n      a4 = this.stream.peekUInt8(4);\n      a = a0 + a1 + a2 + a3 + a4;\n      a %= Math.pow(2, 40 - this.bitPosition);\n      a = Math.floor(a / Math.pow(2, 40 - this.bitPosition - bits));\n    } else {\n      throw new Error(\"Too many bits!\");\n    }\n    if (signed) {\n      if (mBits < 32) {\n        if (a >>> (bits - 1)) {\n          a = ((1 << bits >>> 0) - a) * -1;\n        }\n      } else {\n        if (a / Math.pow(2, bits - 1) | 0) {\n          a = (Math.pow(2, bits) - a) * -1;\n        }\n      }\n    }\n    return a;\n  };\n\n  Bitstream.prototype.readLSB = function(bits, signed) {\n    var a, mBits;\n\n    if (bits === 0) {\n      return 0;\n    }\n    if (bits > 40) {\n      throw new Error(\"Too many bits!\");\n    }\n    mBits = bits + this.bitPosition;\n    a = (this.stream.peekUInt8(0)) >>> this.bitPosition;\n    if (mBits > 8) {\n      a |= (this.stream.peekUInt8(1)) << (8 - this.bitPosition);\n    }\n    if (mBits > 16) {\n      a |= (this.stream.peekUInt8(2)) << (16 - this.bitPosition);\n    }\n    if (mBits > 24) {\n      a += (this.stream.peekUInt8(3)) << (24 - this.bitPosition) >>> 0;\n    }\n    if (mBits > 32) {\n      a += (this.stream.peekUInt8(4)) * Math.pow(2, 32 - this.bitPosition);\n    }\n    if (mBits >= 32) {\n      a %= Math.pow(2, bits);\n    } else {\n      a &= (1 << bits) - 1;\n    }\n    if (signed) {\n      if (mBits < 32) {\n        if (a >>> (bits - 1)) {\n          a = ((1 << bits >>> 0) - a) * -1;\n        }\n      } else {\n        if (a / Math.pow(2, bits - 1) | 0) {\n          a = (Math.pow(2, bits) - a) * -1;\n        }\n      }\n    }\n    this.advance(bits);\n    return a;\n  };\n\n  Bitstream.prototype.peekLSB = function(bits, signed) {\n    var a, mBits;\n\n    if (bits === 0) {\n      return 0;\n    }\n    if (bits > 40) {\n      throw new Error(\"Too many bits!\");\n    }\n    mBits = bits + this.bitPosition;\n    a = (this.stream.peekUInt8(0)) >>> this.bitPosition;\n    if (mBits > 8) {\n      a |= (this.stream.peekUInt8(1)) << (8 - this.bitPosition);\n    }\n    if (mBits > 16) {\n      a |= (this.stream.peekUInt8(2)) << (16 - this.bitPosition);\n    }\n    if (mBits > 24) {\n      a += (this.stream.peekUInt8(3)) << (24 - this.bitPosition) >>> 0;\n    }\n    if (mBits > 32) {\n      a += (this.stream.peekUInt8(4)) * Math.pow(2, 32 - this.bitPosition);\n    }\n    if (mBits >= 32) {\n      a %= Math.pow(2, bits);\n    } else {\n      a &= (1 << bits) - 1;\n    }\n    if (signed) {\n      if (mBits < 32) {\n        if (a >>> (bits - 1)) {\n          a = ((1 << bits >>> 0) - a) * -1;\n        }\n      } else {\n        if (a / Math.pow(2, bits - 1) | 0) {\n          a = (Math.pow(2, bits) - a) * -1;\n        }\n      }\n    }\n    return a;\n  };\n\n  return Bitstream;\n\n})();\n//import \"core/bitstream.coffee\";\n\nvar _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __slice = [].slice;\n\nAV.EventEmitter = (function(_super) {\n  __extends(EventEmitter, _super);\n\n  function EventEmitter() {\n    _ref = EventEmitter.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  EventEmitter.prototype.on = function(event, fn) {\n    var _base, _ref1, _ref2;\n\n    if ((_ref1 = this.events) == null) {\n      this.events = {};\n    }\n    if ((_ref2 = (_base = this.events)[event]) == null) {\n      _base[event] = [];\n    }\n    return this.events[event].push(fn);\n  };\n\n  EventEmitter.prototype.off = function(event, fn) {\n    var index, _ref1;\n\n    if (!((_ref1 = this.events) != null ? _ref1[event] : void 0)) {\n      return;\n    }\n    index = this.events[event].indexOf(fn);\n    if (~index) {\n      return this.events[event].splice(index, 1);\n    }\n  };\n\n  EventEmitter.prototype.once = function(event, fn) {\n    var cb;\n\n    return this.on(event, cb = function() {\n      this.off(event, cb);\n      return fn.apply(this, arguments);\n    });\n  };\n\n  EventEmitter.prototype.emit = function() {\n    var args, event, fn, _i, _len, _ref1, _ref2;\n\n    event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (!((_ref1 = this.events) != null ? _ref1[event] : void 0)) {\n      return;\n    }\n    _ref2 = this.events[event].slice();\n    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n      fn = _ref2[_i];\n      fn.apply(this, args);\n    }\n  };\n\n  return EventEmitter;\n\n})(AV.Base);\n//import \"core/events.coffee\";\n\nvar __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.Demuxer = (function(_super) {\n  var formats;\n\n  __extends(Demuxer, _super);\n\n  Demuxer.probe = function(buffer) {\n    return false;\n  };\n\n  function Demuxer(source, chunk) {\n    var list, received,\n      _this = this;\n\n    list = new AV.BufferList;\n    list.append(chunk);\n    this.stream = new AV.Stream(list);\n    received = false;\n    source.on('data', function(chunk) {\n      received = true;\n      list.append(chunk);\n      return _this.readChunk(chunk);\n    });\n    source.on('error', function(err) {\n      return _this.emit('error', err);\n    });\n    source.on('end', function() {\n      if (!received) {\n        _this.readChunk(chunk);\n      }\n      return _this.emit('end');\n    });\n    this.seekPoints = [];\n    this.init();\n  }\n\n  Demuxer.prototype.init = function() {};\n\n  Demuxer.prototype.readChunk = function(chunk) {};\n\n  Demuxer.prototype.addSeekPoint = function(offset, timestamp) {\n    var index;\n\n    index = this.searchTimestamp(timestamp);\n    return this.seekPoints.splice(index, 0, {\n      offset: offset,\n      timestamp: timestamp\n    });\n  };\n\n  Demuxer.prototype.searchTimestamp = function(timestamp, backward) {\n    var high, low, mid, time;\n\n    low = 0;\n    high = this.seekPoints.length;\n    if (high > 0 && this.seekPoints[high - 1].timestamp < timestamp) {\n      return high;\n    }\n    while (low < high) {\n      mid = (low + high) >> 1;\n      time = this.seekPoints[mid].timestamp;\n      if (time < timestamp) {\n        low = mid + 1;\n      } else if (time >= timestamp) {\n        high = mid;\n      }\n    }\n    if (high > this.seekPoints.length) {\n      high = this.seekPoints.length;\n    }\n    return high;\n  };\n\n  Demuxer.prototype.seek = function(timestamp) {\n    var index, seekPoint;\n\n    if (this.format && this.format.framesPerPacket > 0 && this.format.bytesPerPacket > 0) {\n      seekPoint = {\n        timestamp: timestamp,\n        offset: this.format.bytesPerPacket * timestamp / this.format.framesPerPacket\n      };\n      return seekPoint;\n    } else {\n      index = this.searchTimestamp(timestamp);\n      return this.seekPoints[index];\n    }\n  };\n\n  formats = [];\n\n  Demuxer.register = function(demuxer) {\n    return formats.push(demuxer);\n  };\n\n  Demuxer.find = function(buffer) {\n    var format, stream, _i, _len;\n\n    stream = AV.Stream.fromBuffer(buffer);\n    for (_i = 0, _len = formats.length; _i < _len; _i++) {\n      format = formats[_i];\n      if (format.probe(stream)) {\n        return format;\n      }\n    }\n    return null;\n  };\n\n  return Demuxer;\n\n})(AV.EventEmitter);\n//import \"demuxer.coffee\";\n\nvar __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.Decoder = (function(_super) {\n  var codecs;\n\n  __extends(Decoder, _super);\n\n  function Decoder(demuxer, format) {\n    var list,\n      _this = this;\n\n    this.demuxer = demuxer;\n    this.format = format;\n    list = new AV.BufferList;\n    this.stream = new AV.Stream(list);\n    this.bitstream = new AV.Bitstream(this.stream);\n    this.receivedFinalBuffer = false;\n    this.waiting = false;\n    this.demuxer.on('cookie', function(cookie) {\n      var error;\n\n      try {\n        return _this.setCookie(cookie);\n      } catch (_error) {\n        error = _error;\n        return _this.emit('error', error);\n      }\n    });\n    this.demuxer.on('data', function(chunk) {\n      list.append(chunk);\n      if (_this.waiting) {\n        return _this.decode();\n      }\n    });\n    this.demuxer.on('end', function() {\n      _this.receivedFinalBuffer = true;\n      if (_this.waiting) {\n        return _this.decode();\n      }\n    });\n    this.init();\n  }\n\n  Decoder.prototype.init = function() {};\n\n  Decoder.prototype.setCookie = function(cookie) {};\n\n  Decoder.prototype.readChunk = function() {};\n\n  Decoder.prototype.decode = function() {\n    var error, offset, packet;\n\n    this.waiting = false;\n    offset = this.bitstream.offset();\n    try {\n      packet = this.readChunk();\n    } catch (_error) {\n      error = _error;\n      if (!(error instanceof AV.UnderflowError)) {\n        this.emit('error', error);\n        return false;\n      }\n    }\n    if (packet) {\n      this.emit('data', packet);\n      return true;\n    } else if (!this.receivedFinalBuffer) {\n      this.bitstream.seek(offset);\n      this.waiting = true;\n    } else {\n      this.emit('end');\n    }\n    return false;\n  };\n\n  Decoder.prototype.seek = function(timestamp) {\n    var seekPoint;\n\n    seekPoint = this.demuxer.seek(timestamp);\n    this.stream.seek(seekPoint.offset);\n    return seekPoint.timestamp;\n  };\n\n  codecs = {};\n\n  Decoder.register = function(id, decoder) {\n    return codecs[id] = decoder;\n  };\n\n  Decoder.find = function(id) {\n    return codecs[id] || null;\n  };\n\n  return Decoder;\n\n})(AV.EventEmitter);\n//import \"decoder.coffee\";\n\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.Queue = (function(_super) {\n  __extends(Queue, _super);\n\n  function Queue(asset) {\n    var _this = this;\n\n    this.asset = asset;\n    this.write = __bind(this.write, this);\n    this.readyMark = 64;\n    this.finished = false;\n    this.buffering = true;\n    this.ended = false;\n    this.buffers = [];\n    this.asset.on('data', this.write);\n    this.asset.on('end', function() {\n      return _this.ended = true;\n    });\n    this.asset.decodePacket();\n  }\n\n  Queue.prototype.write = function(buffer) {\n    if (buffer) {\n      this.buffers.push(buffer);\n    }\n    if (this.buffering) {\n      if (this.buffers.length >= this.readyMark || this.ended) {\n        this.buffering = false;\n        return this.emit('ready');\n      } else {\n        return this.asset.decodePacket();\n      }\n    }\n  };\n\n  Queue.prototype.read = function() {\n    if (this.buffers.length === 0) {\n      return null;\n    }\n    this.asset.decodePacket();\n    return this.buffers.shift();\n  };\n\n  Queue.prototype.reset = function() {\n    this.buffers.length = 0;\n    this.buffering = true;\n    return this.asset.decodePacket();\n  };\n\n  return Queue;\n\n})(AV.EventEmitter);\n//import \"queue.coffee\";\n\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.AudioDevice = (function(_super) {\n  var devices;\n\n  __extends(AudioDevice, _super);\n\n  function AudioDevice(sampleRate, channels) {\n    this.sampleRate = sampleRate;\n    this.channels = channels;\n    this.updateTime = __bind(this.updateTime, this);\n    this.playing = false;\n    this.currentTime = 0;\n    this._lastTime = 0;\n  }\n\n  AudioDevice.prototype.start = function() {\n    var _ref,\n      _this = this;\n\n    if (this.playing) {\n      return;\n    }\n    this.playing = true;\n    if ((_ref = this.device) == null) {\n\n      this.device = this._device = AV.AudioDevice.create(this.sampleRate, this.channels);\n    }\n    this._lastTime = this.device.getDeviceTime();\n    this._timer = setInterval(this.updateTime, 200);\n    return this.device.on('refill', this.refill = function(buffer) {\n      return _this.emit('refill', buffer);\n    });\n  };\n\n  AudioDevice.prototype.stop = function() {\n    if (!this.playing) {\n      return;\n    }\n    this.playing = false;\n    this.device.off('refill', this.refill);\n    return clearInterval(this._timer);\n  };\n\n  AudioDevice.prototype.destroy = function() {\n    this.stop();\n    return this.device.destroy();\n  };\n\n  AudioDevice.prototype.seek = function(currentTime) {\n    this.currentTime = currentTime;\n    if (this.playing) {\n      this._lastTime = this.device.getDeviceTime();\n    }\n    return this.emit('timeUpdate', this.currentTime);\n  };\n\n  AudioDevice.prototype.updateTime = function() {\n    var time;\n\n    time = this.device.getDeviceTime();\n    this.currentTime += (time - this._lastTime) / this.device.sampleRate * 1000 | 0;\n    this._lastTime = time;\n    return this.emit('timeUpdate', this.currentTime);\n  };\n\n  devices = [];\n\n  AudioDevice.register = function(device) {\n    return devices.push(device);\n  };\n\n  AudioDevice.create = function(sampleRate, channels) {\n    var device, _i, _len;\n\n    for (_i = 0, _len = devices.length; _i < _len; _i++) {\n      device = devices[_i];\n      if (device.supported) {\n        return new device(sampleRate, channels);\n      }\n    }\n    return null;\n  };\n\n  return AudioDevice;\n\n})(AV.EventEmitter);\n//import \"device.coffee\";\n\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.Asset = (function(_super) {\n  __extends(Asset, _super);\n\n  function Asset(source) {\n    var _this = this;\n\n    this.source = source;\n    this._decode = __bind(this._decode, this);\n    this.findDecoder = __bind(this.findDecoder, this);\n    this.probe = __bind(this.probe, this);\n    this.buffered = 0;\n    this.duration = null;\n    this.format = null;\n    this.metadata = null;\n    this.active = false;\n    this.demuxer = null;\n    this.decoder = null;\n    this.source.once('data', this.probe);\n    this.source.on('error', function(err) {\n      _this.emit('error', err);\n      return _this.stop();\n    });\n    this.source.on('progress', function(buffered) {\n      _this.buffered = buffered;\n      return _this.emit('buffer', _this.buffered);\n    });\n  }\n\n  Asset.fromURL = function(url) {\n    var source;\n\n    source = new AV.HTTPSource(url);\n    return new AV.Asset(source);\n  };\n\n  Asset.fromFile = function(file) {\n    var source;\n\n    source = new AV.FileSource(file);\n    return new AV.Asset(source);\n  };\n\n  Asset.prototype.start = function(decode) {\n    var _ref;\n\n    if (this.active) {\n      return;\n    }\n    if (decode != null) {\n      this.shouldDecode = decode;\n    }\n    if ((_ref = this.shouldDecode) == null) {\n      this.shouldDecode = true;\n    }\n    this.active = true;\n    this.source.start();\n    if (this.decoder && this.shouldDecode) {\n      return this._decode();\n    }\n  };\n\n  Asset.prototype.stop = function() {\n    if (!this.active) {\n      return;\n    }\n    this.active = false;\n    return this.source.pause();\n  };\n\n  Asset.prototype.get = function(event, callback) {\n    var _this = this;\n\n    if (event !== 'format' && event !== 'duration' && event !== 'metadata') {\n      return;\n    }\n    if (this[event] != null) {\n      return callback(this[event]);\n    } else {\n      this.once(event, function(value) {\n        _this.stop();\n        return callback(value);\n      });\n      return this.start();\n    }\n  };\n\n  Asset.prototype.decodePacket = function() {\n    return this.decoder.decode();\n  };\n\n  Asset.prototype.probe = function(chunk) {\n    var demuxer,\n      _this = this;\n\n    if (!this.active) {\n      return;\n    }\n    demuxer = AV.Demuxer.find(chunk);\n    if (!demuxer) {\n      return this.emit('error', 'A demuxer for this container was not found.');\n    }\n    this.demuxer = new demuxer(this.source, chunk);\n    this.demuxer.on('format', this.findDecoder);\n    this.demuxer.on('duration', function(duration) {\n      _this.duration = duration;\n      return _this.emit('duration', _this.duration);\n    });\n    this.demuxer.on('metadata', function(metadata) {\n      _this.metadata = metadata;\n      return _this.emit('metadata', _this.metadata);\n    });\n    return this.demuxer.on('error', function(err) {\n      _this.emit('error', err);\n      return _this.stop();\n    });\n  };\n\n  Asset.prototype.findDecoder = function(format) {\n    var decoder,\n      _this = this;\n\n    this.format = format;\n    if (!this.active) {\n      return;\n    }\n    this.emit('format', this.format);\n    decoder = AV.Decoder.find(this.format.formatID);\n    if (!decoder) {\n      return this.emit('error', \"A decoder for \" + this.format.formatID + \" was not found.\");\n    }\n    this.decoder = new decoder(this.demuxer, this.format);\n    this.decoder.on('data', function(buffer) {\n      return _this.emit('data', buffer);\n    });\n    this.decoder.on('error', function(err) {\n      _this.emit('error', err);\n      return _this.stop();\n    });\n    this.decoder.on('end', function() {\n      return _this.emit('end');\n    });\n    this.emit('decodeStart');\n    if (this.shouldDecode) {\n      return this._decode();\n    }\n  };\n\n  Asset.prototype._decode = function() {\n    while (this.decoder.decode() && this.active) {\n      continue;\n    }\n    if (this.active) {\n      return this.decoder.once('data', this._decode);\n    }\n  };\n\n  return Asset;\n\n})(AV.EventEmitter);\n//import \"asset.coffee\";\n\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.Player = (function(_super) {\n  __extends(Player, _super);\n\n  function Player(asset) {\n    var _this = this;\n\n    this.asset = asset;\n    this.startPlaying = __bind(this.startPlaying, this);\n    this.playing = false;\n    this.buffered = 0;\n    this.currentTime = 0;\n    this.duration = 0;\n    this.volume = 100;\n    this.pan = 0;\n    this.metadata = {};\n    this.filters = [new AV.VolumeFilter(this, 'volume'), new AV.BalanceFilter(this, 'pan')];\n    this.asset.on('buffer', function(buffered) {\n      _this.buffered = buffered;\n      return _this.emit('buffer', _this.buffered);\n    });\n    this.asset.on('decodeStart', function() {\n      _this.queue = new AV.Queue(_this.asset);\n      return _this.queue.once('ready', _this.startPlaying);\n    });\n    this.asset.on('format', function(format) {\n      _this.format = format;\n      return _this.emit('format', _this.format);\n    });\n    this.asset.on('metadata', function(metadata) {\n      _this.metadata = metadata;\n      return _this.emit('metadata', _this.metadata);\n    });\n    this.asset.on('duration', function(duration) {\n      _this.duration = duration;\n      return _this.emit('duration', _this.duration);\n    });\n    this.asset.on('error', function(error) {\n      return _this.emit('error', error);\n    });\n  }\n\n  Player.fromURL = function(url) {\n    var asset;\n\n    asset = AV.Asset.fromURL(url);\n    return new AV.Player(asset);\n  };\n\n  Player.fromFile = function(file) {\n    var asset;\n\n    asset = AV.Asset.fromFile(file);\n    return new AV.Player(asset);\n  };\n\n  Player.prototype.preload = function() {\n    if (!this.asset) {\n      return;\n    }\n    this.startedPreloading = true;\n    return this.asset.start(false);\n  };\n\n  Player.prototype.play = function() {\n    var _ref;\n\n    if (this.playing) {\n      return;\n    }\n    if (!this.startedPreloading) {\n      this.preload();\n    }\n    this.playing = true;\n    return (_ref = this.device) != null ? _ref.start() : void 0;\n  };\n\n  Player.prototype.pause = function() {\n    var _ref;\n\n    if (!this.playing) {\n      return;\n    }\n    this.playing = false;\n    return (_ref = this.device) != null ? _ref.stop() : void 0;\n  };\n\n  Player.prototype.togglePlayback = function() {\n    if (this.playing) {\n      return this.pause();\n    } else {\n      return this.play();\n    }\n  };\n\n  Player.prototype.stop = function() {\n    var _ref;\n\n    this.pause();\n    this.asset.stop();\n    return (_ref = this.device) != null ? _ref.destroy() : void 0;\n  };\n\n  Player.prototype.seek = function(timestamp) {\n    var _ref,\n      _this = this;\n\n    if ((_ref = this.device) != null) {\n      _ref.stop();\n    }\n    this.queue.once('ready', function() {\n      var _ref1, _ref2;\n\n      if ((_ref1 = _this.device) != null) {\n        _ref1.seek(_this.currentTime);\n      }\n      if (_this.playing) {\n        return (_ref2 = _this.device) != null ? _ref2.start() : void 0;\n      }\n    });\n    timestamp = (timestamp / 1000) * this.format.sampleRate;\n    timestamp = this.asset.decoder.seek(timestamp);\n    this.currentTime = timestamp / this.format.sampleRate * 1000 | 0;\n    this.queue.reset();\n    return this.currentTime;\n  };\n\n  Player.prototype.startPlaying = function() {\n    var div, frame, frameOffset,\n      _this = this;\n\n    frame = this.queue.read();\n    frameOffset = 0;\n    div = this.format.floatingPoint ? 1 : Math.pow(2, this.format.bitsPerChannel - 1);\n    this.device = new AV.AudioDevice(this.format.sampleRate, this.format.channelsPerFrame);\n    this.device.on('timeUpdate', function(currentTime) {\n      _this.currentTime = currentTime;\n      return _this.emit('progress', _this.currentTime);\n    });\n    this.refill = function(buffer) {\n      var bufferOffset, filter, i, max, _i, _j, _len, _ref;\n\n      if (!_this.playing) {\n        return;\n      }\n      if (!frame) {\n        frame = _this.queue.read();\n        frameOffset = 0;\n      }\n      bufferOffset = 0;\n      while (frame && bufferOffset < buffer.length) {\n        max = Math.min(frame.length - frameOffset, buffer.length - bufferOffset);\n        for (i = _i = 0; _i < max; i = _i += 1) {\n          buffer[bufferOffset++] = frame[frameOffset++] / div;\n        }\n        if (frameOffset === frame.length) {\n          frame = _this.queue.read();\n          frameOffset = 0;\n        }\n      }\n      _ref = _this.filters;\n      for (_j = 0, _len = _ref.length; _j < _len; _j++) {\n        filter = _ref[_j];\n        filter.process(buffer);\n      }\n      if (!frame) {\n        if (_this.asset.ended) {\n          _this.currentTime = _this.duration;\n          _this.emit('progress', _this.currentTime);\n          _this.emit('end');\n          _this.stop();\n        } else {\n          _this.device.stop();\n        }\n      }\n    };\n    this.device.on('refill', this.refill);\n    if (this.playing) {\n      this.device.start();\n    }\n    return this.emit('ready');\n  };\n\n  return Player;\n\n})(AV.EventEmitter);\n//import \"player.coffee\";\n\n//import \"resampler.js\";\nvar WebKitAudioDevice,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nWebKitAudioDevice = (function(_super) {\n  var AudioContext, sharedContext;\n\n  __extends(WebKitAudioDevice, _super);\n\n  AV.AudioDevice.register(WebKitAudioDevice);\n\n  AudioContext = global.AudioContext || global.webkitAudioContext;\n\n  WebKitAudioDevice.supported = typeof (AudioContext != null ? AudioContext.prototype.createJavaScriptNode : void 0) === 'function';\n\n  sharedContext = null;\n\n  function WebKitAudioDevice(sampleRate, channels) {\n    this.sampleRate = sampleRate;\n    this.channels = channels;\n    this.refill = __bind(this.refill, this);\n    this.context = master != null ? master : sharedContext = new AudioContext;\n    this.deviceSampleRate = this.context.sampleRate;\n    this.bufferSize = Math.ceil(4096 / (this.deviceSampleRate / this.sampleRate) * this.channels);\n    this.bufferSize += this.bufferSize % this.channels;\n    if (this.deviceSampleRate !== this.sampleRate) {\n      this.resampler = new Resampler(this.sampleRate, this.deviceSampleRate, this.channels, 4096 * this.channels);\n    }\n    this.node = this.context.createJavaScriptNode(4096, this.channels, this.channels);\n    this.node.onaudioprocess = this.refill;\n//    this.node.connect(this.context.destination);\n  }\n\n  WebKitAudioDevice.prototype.refill = function(event) {\n    var channelCount, channels, data, i, n, outputBuffer, _i, _j, _k, _ref;\n\n    outputBuffer = event.outputBuffer;\n    channelCount = outputBuffer.numberOfChannels;\n    channels = new Array(channelCount);\n    for (i = _i = 0; _i < channelCount; i = _i += 1) {\n      channels[i] = outputBuffer.getChannelData(i);\n    }\n    data = new Float32Array(this.bufferSize);\n    this.emit('refill', data);\n    if (this.resampler) {\n      data = this.resampler.resampler(data);\n    }\n    for (i = _j = 0, _ref = outputBuffer.length; _j < _ref; i = _j += 1) {\n      for (n = _k = 0; _k < channelCount; n = _k += 1) {\n        channels[n][i] = data[i * channelCount + n];\n      }\n    }\n  };\n\n  WebKitAudioDevice.prototype.destroy = function() {\n    return this.node.disconnect(0);\n  };\n\n  WebKitAudioDevice.prototype.getDeviceTime = function() {\n    return this.context.currentTime * this.sampleRate;\n  };\n\n  return WebKitAudioDevice;\n\n})(AV.EventEmitter);\n//import \"devices/webkit.coffee\";\n\nvar MozillaAudioDevice,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nMozillaAudioDevice = (function(_super) {\n  var createTimer, destroyTimer;\n\n  __extends(MozillaAudioDevice, _super);\n\n  AV.AudioDevice.register(MozillaAudioDevice);\n\n  MozillaAudioDevice.supported = (typeof Audio !== \"undefined\" && Audio !== null) && 'mozWriteAudio' in new Audio;\n\n  function MozillaAudioDevice(sampleRate, channels) {\n    this.sampleRate = sampleRate;\n    this.channels = channels;\n    this.refill = __bind(this.refill, this);\n    this.audio = new Audio;\n    this.audio.mozSetup(this.channels, this.sampleRate);\n    this.writePosition = 0;\n    this.prebufferSize = this.sampleRate / 2;\n    this.tail = null;\n    this.timer = createTimer(this.refill, 100);\n  }\n\n  MozillaAudioDevice.prototype.refill = function() {\n    var available, buffer, currentPosition, written;\n\n    if (this.tail) {\n      written = this.audio.mozWriteAudio(this.tail);\n      this.writePosition += written;\n      if (this.writePosition < this.tail.length) {\n        this.tail = this.tail.subarray(written);\n      } else {\n        this.tail = null;\n      }\n    }\n    currentPosition = this.audio.mozCurrentSampleOffset();\n    available = currentPosition + this.prebufferSize - this.writePosition;\n    if (available > 0) {\n      buffer = new Float32Array(available);\n      this.emit('refill', buffer);\n      written = this.audio.mozWriteAudio(buffer);\n      if (written < buffer.length) {\n        this.tail = buffer.subarray(written);\n      }\n      this.writePosition += written;\n    }\n  };\n\n  MozillaAudioDevice.prototype.destroy = function() {\n    return destroyTimer(this.timer);\n  };\n\n  MozillaAudioDevice.prototype.getDeviceTime = function() {\n    return this.audio.mozCurrentSampleOffset() / this.channels;\n  };\n\n  createTimer = function(fn, interval) {\n    var url, worker;\n\n    url = AV.Buffer.makeBlobURL(\"setInterval(function() { postMessage('ping'); }, \" + interval + \");\");\n    if (url == null) {\n      return setInterval(fn, interval);\n    }\n    worker = new Worker(url);\n    worker.onmessage = fn;\n    worker.url = url;\n    return worker;\n  };\n\n  destroyTimer = function(timer) {\n    if (timer.terminate) {\n      timer.terminate();\n      return URL.revokeObjectURL(timer.url);\n    } else {\n      return clearInterval(timer);\n    }\n  };\n\n  return MozillaAudioDevice;\n\n})(AV.EventEmitter);\n//import \"devices/mozilla.coffee\";\n\nAV.Filter = (function() {\n  function Filter(context, key) {\n    if (context && key) {\n      Object.defineProperty(this, 'value', {\n        get: function() {\n          return context[key];\n        }\n      });\n    }\n  }\n\n  Filter.prototype.process = function(buffer) {};\n\n  return Filter;\n\n})();\n//import \"filter.coffee\";\n\nvar _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.VolumeFilter = (function(_super) {\n  __extends(VolumeFilter, _super);\n\n  function VolumeFilter() {\n    _ref = VolumeFilter.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  VolumeFilter.prototype.process = function(buffer) {\n    var i, vol, _i, _ref1;\n\n    if (this.value >= 100) {\n      return;\n    }\n    vol = Math.max(0, Math.min(100, this.value)) / 100;\n    for (i = _i = 0, _ref1 = buffer.length; _i < _ref1; i = _i += 1) {\n      buffer[i] *= vol;\n    }\n  };\n\n  return VolumeFilter;\n\n})(AV.Filter);\n//import \"filters/volume.coffee\";\n\nvar _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.BalanceFilter = (function(_super) {\n  __extends(BalanceFilter, _super);\n\n  function BalanceFilter() {\n    _ref = BalanceFilter.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  BalanceFilter.prototype.process = function(buffer) {\n    var i, pan, _i, _ref1;\n\n    if (this.value === 0) {\n      return;\n    }\n    pan = Math.max(-50, Math.min(50, this.value));\n    for (i = _i = 0, _ref1 = buffer.length; _i < _ref1; i = _i += 2) {\n      buffer[i] *= Math.min(1, (50 - pan) / 50);\n      buffer[i + 1] *= Math.min(1, (50 + pan) / 50);\n    }\n  };\n\n  return BalanceFilter;\n\n})(AV.Filter);\n//import \"filters/balance.coffee\";\n\nvar CAFDemuxer, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nCAFDemuxer = (function(_super) {\n  __extends(CAFDemuxer, _super);\n\n  function CAFDemuxer() {\n    _ref = CAFDemuxer.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  AV.Demuxer.register(CAFDemuxer);\n\n  CAFDemuxer.probe = function(buffer) {\n    return buffer.peekString(0, 4) === 'caff';\n  };\n\n  CAFDemuxer.prototype.readChunk = function() {\n    var buffer, byteOffset, cookie, entries, flags, i, key, metadata, offset, sampleOffset, value, _i, _j, _ref1;\n\n    if (!this.format && this.stream.available(64)) {\n      if (this.stream.readString(4) !== 'caff') {\n        return this.emit('error', \"Invalid CAF, does not begin with 'caff'\");\n      }\n      this.stream.advance(4);\n      if (this.stream.readString(4) !== 'desc') {\n        return this.emit('error', \"Invalid CAF, 'caff' is not followed by 'desc'\");\n      }\n      if (!(this.stream.readUInt32() === 0 && this.stream.readUInt32() === 32)) {\n        return this.emit('error', \"Invalid 'desc' size, should be 32\");\n      }\n      this.format = {};\n      this.format.sampleRate = this.stream.readFloat64();\n      this.format.formatID = this.stream.readString(4);\n      flags = this.stream.readUInt32();\n      if (this.format.formatID === 'lpcm') {\n        this.format.floatingPoint = Boolean(flags & 1);\n        this.format.littleEndian = Boolean(flags & 2);\n      }\n      this.format.bytesPerPacket = this.stream.readUInt32();\n      this.format.framesPerPacket = this.stream.readUInt32();\n      this.format.channelsPerFrame = this.stream.readUInt32();\n      this.format.bitsPerChannel = this.stream.readUInt32();\n      this.emit('format', this.format);\n    }\n    while (this.stream.available(1)) {\n      if (!this.headerCache) {\n        this.headerCache = {\n          type: this.stream.readString(4),\n          oversize: this.stream.readUInt32() !== 0,\n          size: this.stream.readUInt32()\n        };\n        if (this.headerCache.oversize) {\n          return this.emit('error', \"Holy Shit, an oversized file, not supported in JS\");\n        }\n      }\n      switch (this.headerCache.type) {\n        case 'kuki':\n          if (this.stream.available(this.headerCache.size)) {\n            if (this.format.formatID === 'aac ') {\n              offset = this.stream.offset + this.headerCache.size;\n              if (cookie = M4ADemuxer.readEsds(this.stream)) {\n                this.emit('cookie', cookie);\n              }\n              this.stream.seek(offset);\n            } else {\n              buffer = this.stream.readBuffer(this.headerCache.size);\n              this.emit('cookie', buffer);\n            }\n            this.headerCache = null;\n          }\n          break;\n        case 'pakt':\n          if (this.stream.available(this.headerCache.size)) {\n            if (this.stream.readUInt32() !== 0) {\n              return this.emit('error', 'Sizes greater than 32 bits are not supported.');\n            }\n            this.numPackets = this.stream.readUInt32();\n            if (this.stream.readUInt32() !== 0) {\n              return this.emit('error', 'Sizes greater than 32 bits are not supported.');\n            }\n            this.numFrames = this.stream.readUInt32();\n            this.primingFrames = this.stream.readUInt32();\n            this.remainderFrames = this.stream.readUInt32();\n            this.emit('duration', this.numFrames / this.format.sampleRate * 1000 | 0);\n            this.sentDuration = true;\n            byteOffset = 0;\n            sampleOffset = 0;\n            for (i = _i = 0, _ref1 = this.numPackets; _i < _ref1; i = _i += 1) {\n              this.addSeekPoint(byteOffset, sampleOffset);\n              byteOffset += this.format.bytesPerPacket || M4ADemuxer.readDescrLen(this.stream);\n              sampleOffset += this.format.framesPerPacket || M4ADemuxer.readDescrLen(this.stream);\n            }\n            this.headerCache = null;\n          }\n          break;\n        case 'info':\n          entries = this.stream.readUInt32();\n          metadata = {};\n          for (i = _j = 0; 0 <= entries ? _j < entries : _j > entries; i = 0 <= entries ? ++_j : --_j) {\n            key = this.stream.readString(null);\n            value = this.stream.readString(null);\n            metadata[key] = value;\n          }\n          this.emit('metadata', metadata);\n          this.headerCache = null;\n          break;\n        case 'data':\n          if (!this.sentFirstDataChunk) {\n            this.stream.advance(4);\n            this.headerCache.size -= 4;\n            if (this.format.bytesPerPacket !== 0 && !this.sentDuration) {\n              this.numFrames = this.headerCache.size / this.format.bytesPerPacket;\n              this.emit('duration', this.numFrames / this.format.sampleRate * 1000 | 0);\n            }\n            this.sentFirstDataChunk = true;\n          }\n          buffer = this.stream.readSingleBuffer(this.headerCache.size);\n          this.headerCache.size -= buffer.length;\n          this.emit('data', buffer);\n          if (this.headerCache.size <= 0) {\n            this.headerCache = null;\n          }\n          break;\n        default:\n          if (this.stream.available(this.headerCache.size)) {\n            this.stream.advance(this.headerCache.size);\n            this.headerCache = null;\n          }\n      }\n    }\n  };\n\n  return CAFDemuxer;\n\n})(AV.Demuxer);\n//import \"demuxers/caf.coffee\";\n\nvar M4ADemuxer, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nM4ADemuxer = (function(_super) {\n  var BITS_PER_CHANNEL, TYPES, after, atom, atoms, bool, containers, diskTrack, genres, meta, string;\n\n  __extends(M4ADemuxer, _super);\n\n  function M4ADemuxer() {\n    _ref = M4ADemuxer.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  AV.Demuxer.register(M4ADemuxer);\n\n  TYPES = ['M4A ', 'M4P ', 'M4B ', 'M4V ', 'isom', 'mp42', 'qt  '];\n\n  M4ADemuxer.probe = function(buffer) {\n    var _ref1;\n\n    return buffer.peekString(4, 4) === 'ftyp' && (_ref1 = buffer.peekString(8, 4), __indexOf.call(TYPES, _ref1) >= 0);\n  };\n\n  M4ADemuxer.prototype.init = function() {\n    this.atoms = [];\n    this.offsets = [];\n    this.track = null;\n    return this.tracks = [];\n  };\n\n  atoms = {};\n\n  containers = {};\n\n  atom = function(name, fn) {\n    var c, container, _i, _len, _ref1, _ref2;\n\n    c = [];\n    _ref1 = name.split('.').slice(0, -1);\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      container = _ref1[_i];\n      c.push(container);\n      containers[c.join('.')] = true;\n    }\n    if ((_ref2 = atoms[name]) == null) {\n      atoms[name] = {};\n    }\n    return atoms[name].fn = fn;\n  };\n\n  after = function(name, fn) {\n    var _ref1;\n\n    if ((_ref1 = atoms[name]) == null) {\n      atoms[name] = {};\n    }\n    return atoms[name].after = fn;\n  };\n\n  M4ADemuxer.prototype.readChunk = function() {\n    var handler, path, type;\n\n    this[\"break\"] = false;\n    while (this.stream.available(1) && !this[\"break\"]) {\n      if (!this.readHeaders) {\n        if (!this.stream.available(8)) {\n          return;\n        }\n        this.len = this.stream.readUInt32() - 8;\n        this.type = this.stream.readString(4);\n        if (this.len === 0) {\n          continue;\n        }\n        this.atoms.push(this.type);\n        this.offsets.push(this.stream.offset + this.len);\n        this.readHeaders = true;\n      }\n      path = this.atoms.join('.');\n      handler = atoms[path];\n      if (handler != null ? handler.fn : void 0) {\n        if (!(this.stream.available(this.len) || path === 'mdat')) {\n          return;\n        }\n        handler.fn.call(this);\n        if (path in containers) {\n          this.readHeaders = false;\n        }\n      } else if (path in containers) {\n        this.readHeaders = false;\n      } else {\n        if (!this.stream.available(this.len)) {\n          return;\n        }\n        this.stream.advance(this.len);\n      }\n      while (this.stream.offset >= this.offsets[this.offsets.length - 1]) {\n        handler = atoms[this.atoms.join('.')];\n        if (handler != null ? handler.after : void 0) {\n          handler.after.call(this);\n        }\n        type = this.atoms.pop();\n        this.offsets.pop();\n        this.readHeaders = false;\n      }\n    }\n  };\n\n  atom('ftyp', function() {\n    var _ref1;\n\n    if (_ref1 = this.stream.readString(4), __indexOf.call(TYPES, _ref1) < 0) {\n      return this.emit('error', 'Not a valid M4A file.');\n    }\n    return this.stream.advance(this.len - 4);\n  });\n\n  atom('moov.trak', function() {\n    this.track = {};\n    return this.tracks.push(this.track);\n  });\n\n  atom('moov.trak.tkhd', function() {\n    this.stream.advance(4);\n    this.stream.advance(8);\n    this.track.id = this.stream.readUInt32();\n    return this.stream.advance(this.len - 16);\n  });\n\n  atom('moov.trak.mdia.hdlr', function() {\n    this.stream.advance(4);\n    this.stream.advance(4);\n    this.track.type = this.stream.readString(4);\n    this.stream.advance(12);\n    return this.stream.advance(this.len - 24);\n  });\n\n  atom('moov.trak.mdia.mdhd', function() {\n    this.stream.advance(4);\n    this.stream.advance(8);\n    this.track.timeScale = this.stream.readUInt32();\n    this.track.duration = this.stream.readUInt32();\n    return this.stream.advance(4);\n  });\n\n  BITS_PER_CHANNEL = {\n    ulaw: 8,\n    alaw: 8,\n    in24: 24,\n    in32: 32,\n    fl32: 32,\n    fl64: 64\n  };\n\n  atom('moov.trak.mdia.minf.stbl.stsd', function() {\n    var format, numEntries, version, _ref1, _ref2;\n\n    this.stream.advance(4);\n    numEntries = this.stream.readUInt32();\n    if (this.track.type !== 'soun') {\n      return this.stream.advance(this.len - 8);\n    }\n    if (numEntries !== 1) {\n      return this.emit('error', \"Only expecting one entry in sample description atom!\");\n    }\n    this.stream.advance(4);\n    format = this.track.format = {};\n    format.formatID = this.stream.readString(4);\n    this.stream.advance(6);\n    this.stream.advance(2);\n    version = this.stream.readUInt16();\n    this.stream.advance(6);\n    format.channelsPerFrame = this.stream.readUInt16();\n    format.bitsPerChannel = this.stream.readUInt16();\n    this.stream.advance(4);\n    format.sampleRate = this.stream.readUInt16();\n    this.stream.advance(2);\n    if (version === 1) {\n      format.framesPerPacket = this.stream.readUInt32();\n      this.stream.advance(4);\n      format.bytesPerFrame = this.stream.readUInt32();\n      this.stream.advance(4);\n    } else if (version !== 0) {\n      this.emit('error', 'Unknown version in stsd atom');\n    }\n    if (BITS_PER_CHANNEL[format.formatID] != null) {\n      format.bitsPerChannel = BITS_PER_CHANNEL[format.formatID];\n    }\n    format.floatingPoint = (_ref1 = format.formatID) === 'fl32' || _ref1 === 'fl64';\n    format.littleEndian = format.formatID === 'sowt' && format.bitsPerChannel > 8;\n    if ((_ref2 = format.formatID) === 'twos' || _ref2 === 'sowt' || _ref2 === 'in24' || _ref2 === 'in32' || _ref2 === 'fl32' || _ref2 === 'fl64' || _ref2 === 'raw ' || _ref2 === 'NONE') {\n      return format.formatID = 'lpcm';\n    }\n  });\n\n  atom('moov.trak.mdia.minf.stbl.stsd.alac', function() {\n    this.stream.advance(4);\n    return this.track.cookie = this.stream.readBuffer(this.len - 4);\n  });\n\n  atom('moov.trak.mdia.minf.stbl.stsd.esds', function() {\n    var offset;\n\n    offset = this.stream.offset + this.len;\n    this.track.cookie = M4ADemuxer.readEsds(this.stream);\n    return this.stream.seek(offset);\n  });\n\n  atom('moov.trak.mdia.minf.stbl.stsd.wave.enda', function() {\n    return this.track.format.littleEndian = !!this.stream.readUInt16();\n  });\n\n  M4ADemuxer.readDescrLen = function(stream) {\n    var c, count, len;\n\n    len = 0;\n    count = 4;\n    while (count--) {\n      c = stream.readUInt8();\n      len = (len << 7) | (c & 0x7f);\n      if (!(c & 0x80)) {\n        break;\n      }\n    }\n    return len;\n  };\n\n  M4ADemuxer.readEsds = function(stream) {\n    var codec_id, flags, len, tag;\n\n    stream.advance(4);\n    tag = stream.readUInt8();\n    len = M4ADemuxer.readDescrLen(stream);\n    if (tag === 0x03) {\n      stream.advance(2);\n      flags = stream.readUInt8();\n      if (flags & 0x80) {\n        stream.advance(2);\n      }\n      if (flags & 0x40) {\n        stream.advance(stream.readUInt8());\n      }\n      if (flags & 0x20) {\n        stream.advance(2);\n      }\n    } else {\n      stream.advance(2);\n    }\n    tag = stream.readUInt8();\n    len = M4ADemuxer.readDescrLen(stream);\n    if (tag === 0x04) {\n      codec_id = stream.readUInt8();\n      stream.advance(1);\n      stream.advance(3);\n      stream.advance(4);\n      stream.advance(4);\n      tag = stream.readUInt8();\n      len = M4ADemuxer.readDescrLen(stream);\n      if (tag === 0x05) {\n        return stream.readBuffer(len);\n      }\n    }\n    return null;\n  };\n\n  atom('moov.trak.mdia.minf.stbl.stts', function() {\n    var entries, i, _i;\n\n    this.stream.advance(4);\n    entries = this.stream.readUInt32();\n    this.track.stts = [];\n    for (i = _i = 0; _i < entries; i = _i += 1) {\n      this.track.stts[i] = {\n        count: this.stream.readUInt32(),\n        duration: this.stream.readUInt32()\n      };\n    }\n    return this.setupSeekPoints();\n  });\n\n  atom('moov.trak.mdia.minf.stbl.stsc', function() {\n    var entries, i, _i;\n\n    this.stream.advance(4);\n    entries = this.stream.readUInt32();\n    this.track.stsc = [];\n    for (i = _i = 0; _i < entries; i = _i += 1) {\n      this.track.stsc[i] = {\n        first: this.stream.readUInt32(),\n        count: this.stream.readUInt32(),\n        id: this.stream.readUInt32()\n      };\n    }\n    return this.setupSeekPoints();\n  });\n\n  atom('moov.trak.mdia.minf.stbl.stsz', function() {\n    var entries, i, _i;\n\n    this.stream.advance(4);\n    this.track.sampleSize = this.stream.readUInt32();\n    entries = this.stream.readUInt32();\n    if (this.track.sampleSize === 0 && entries > 0) {\n      this.track.sampleSizes = [];\n      for (i = _i = 0; _i < entries; i = _i += 1) {\n        this.track.sampleSizes[i] = this.stream.readUInt32();\n      }\n    }\n    return this.setupSeekPoints();\n  });\n\n  atom('moov.trak.mdia.minf.stbl.stco', function() {\n    var entries, i, _i;\n\n    this.stream.advance(4);\n    entries = this.stream.readUInt32();\n    this.track.chunkOffsets = [];\n    for (i = _i = 0; _i < entries; i = _i += 1) {\n      this.track.chunkOffsets[i] = this.stream.readUInt32();\n    }\n    return this.setupSeekPoints();\n  });\n\n  atom('moov.trak.tref.chap', function() {\n    var entries, i, _i;\n\n    entries = this.len >> 2;\n    this.track.chapterTracks = [];\n    for (i = _i = 0; _i < entries; i = _i += 1) {\n      this.track.chapterTracks[i] = this.stream.readUInt32();\n    }\n  });\n\n  M4ADemuxer.prototype.setupSeekPoints = function() {\n    var i, j, offset, position, sampleIndex, size, stscIndex, sttsIndex, sttsSample, timestamp, _i, _j, _len, _ref1, _ref2, _results;\n\n    if (!((this.track.chunkOffsets != null) && (this.track.stsc != null) && (this.track.sampleSize != null) && (this.track.stts != null))) {\n      return;\n    }\n    stscIndex = 0;\n    sttsIndex = 0;\n    sttsIndex = 0;\n    sttsSample = 0;\n    sampleIndex = 0;\n    offset = 0;\n    timestamp = 0;\n    this.track.seekPoints = [];\n    _ref1 = this.track.chunkOffsets;\n    _results = [];\n    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n      position = _ref1[i];\n      for (j = _j = 0, _ref2 = this.track.stsc[stscIndex].count; _j < _ref2; j = _j += 1) {\n        this.track.seekPoints.push({\n          offset: offset,\n          position: position,\n          timestamp: timestamp\n        });\n        size = this.track.sampleSize || this.track.sampleSizes[sampleIndex++];\n        offset += size;\n        position += size;\n        timestamp += this.track.stts[sttsIndex].duration;\n        if (sttsIndex + 1 < this.track.stts.length && ++sttsSample === this.track.stts[sttsIndex].count) {\n          sttsSample = 0;\n          sttsIndex++;\n        }\n      }\n      if (stscIndex + 1 < this.track.stsc.length && i + 1 === this.track.stsc[stscIndex + 1].first) {\n        _results.push(stscIndex++);\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  after('moov', function() {\n    var track, _i, _len, _ref1;\n\n    if (this.mdatOffset != null) {\n      this.stream.seek(this.mdatOffset - 8);\n    }\n    _ref1 = this.tracks;\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      track = _ref1[_i];\n      if (!(track.type === 'soun')) {\n        continue;\n      }\n      this.track = track;\n      break;\n    }\n    if (this.track.type !== 'soun') {\n      this.track = null;\n      return this.emit('error', 'No audio tracks in m4a file.');\n    }\n    this.emit('format', this.track.format);\n    this.emit('duration', this.track.duration / this.track.timeScale * 1000 | 0);\n    if (this.track.cookie) {\n      this.emit('cookie', this.track.cookie);\n    }\n    return this.seekPoints = this.track.seekPoints;\n  });\n\n  atom('mdat', function() {\n    var bytes, chunkSize, length, numSamples, offset, sample, size, _i, _ref1;\n\n    if (!this.startedData) {\n      if ((_ref1 = this.mdatOffset) == null) {\n        this.mdatOffset = this.stream.offset;\n      }\n      if (this.tracks.length === 0) {\n        bytes = Math.min(this.stream.remainingBytes(), this.len);\n        this.stream.advance(bytes);\n        this.len -= bytes;\n        return;\n      }\n      this.chunkIndex = 0;\n      this.stscIndex = 0;\n      this.sampleIndex = 0;\n      this.tailOffset = 0;\n      this.tailSamples = 0;\n      this.startedData = true;\n    }\n    if (!this.readChapters) {\n      this.readChapters = this.parseChapters();\n      if (this[\"break\"] = !this.readChapters) {\n        return;\n      }\n      this.stream.seek(this.mdatOffset);\n    }\n    offset = this.track.chunkOffsets[this.chunkIndex] + this.tailOffset;\n    length = 0;\n    if (!this.stream.available(offset - this.stream.offset)) {\n      this[\"break\"] = true;\n      return;\n    }\n    this.stream.seek(offset);\n    while (this.chunkIndex < this.track.chunkOffsets.length) {\n      numSamples = this.track.stsc[this.stscIndex].count - this.tailSamples;\n      chunkSize = 0;\n      for (sample = _i = 0; _i < numSamples; sample = _i += 1) {\n        size = this.track.sampleSize || this.track.sampleSizes[this.sampleIndex];\n        if (!this.stream.available(length + size)) {\n          break;\n        }\n        length += size;\n        chunkSize += size;\n        this.sampleIndex++;\n      }\n      if (sample < numSamples) {\n        this.tailOffset += chunkSize;\n        this.tailSamples += sample;\n        break;\n      } else {\n        this.chunkIndex++;\n        this.tailOffset = 0;\n        this.tailSamples = 0;\n        if (this.stscIndex + 1 < this.track.stsc.length && this.chunkIndex + 1 === this.track.stsc[this.stscIndex + 1].first) {\n          this.stscIndex++;\n        }\n        if (offset + length !== this.track.chunkOffsets[this.chunkIndex]) {\n          break;\n        }\n      }\n    }\n    if (length > 0) {\n      this.emit('data', this.stream.readBuffer(length));\n      return this[\"break\"] = this.chunkIndex === this.track.chunkOffsets.length;\n    } else {\n      return this[\"break\"] = true;\n    }\n  });\n\n  M4ADemuxer.prototype.parseChapters = function() {\n    var bom, id, len, nextTimestamp, point, title, track, _i, _len, _ref1, _ref2, _ref3, _ref4, _ref5;\n\n    if (!(((_ref1 = this.track.chapterTracks) != null ? _ref1.length : void 0) > 0)) {\n      return true;\n    }\n    id = this.track.chapterTracks[0];\n    _ref2 = this.tracks;\n    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n      track = _ref2[_i];\n      if (track.id === id) {\n        break;\n      }\n    }\n    if (track.id !== id) {\n      this.emit('error', 'Chapter track does not exist.');\n    }\n    if ((_ref3 = this.chapters) == null) {\n      this.chapters = [];\n    }\n    while (this.chapters.length < track.seekPoints.length) {\n      point = track.seekPoints[this.chapters.length];\n      if (!this.stream.available(point.position - this.stream.offset + 32)) {\n        return false;\n      }\n      this.stream.seek(point.position);\n      len = this.stream.readUInt16();\n      title = null;\n      if (!this.stream.available(len)) {\n        return false;\n      }\n      if (len > 2) {\n        bom = this.stream.peekUInt16();\n        if (bom === 0xfeff || bom === 0xfffe) {\n          title = this.stream.readString(len, 'utf16-bom');\n        }\n      }\n      if (title == null) {\n        title = this.stream.readString(len, 'utf8');\n      }\n      nextTimestamp = (_ref4 = (_ref5 = track.seekPoints[this.chapters.length + 1]) != null ? _ref5.timestamp : void 0) != null ? _ref4 : track.duration;\n      this.chapters.push({\n        title: title,\n        timestamp: point.timestamp / track.timeScale * 1000 | 0,\n        duration: (nextTimestamp - point.timestamp) / track.timeScale * 1000 | 0\n      });\n    }\n    this.emit('chapters', this.chapters);\n    return true;\n  };\n\n  atom('moov.udta.meta', function() {\n    this.metadata = {};\n    return this.stream.advance(4);\n  });\n\n  after('moov.udta.meta', function() {\n    return this.emit('metadata', this.metadata);\n  });\n\n  meta = function(field, name, fn) {\n    return atom(\"moov.udta.meta.ilst.\" + field + \".data\", function() {\n      this.stream.advance(8);\n      this.len -= 8;\n      return fn.call(this, name);\n    });\n  };\n\n  string = function(field) {\n    return this.metadata[field] = this.stream.readString(this.len, 'utf8');\n  };\n\n  meta('alb', 'album', string);\n\n  meta('arg', 'arranger', string);\n\n  meta('art', 'artist', string);\n\n  meta('ART', 'artist', string);\n\n  meta('aART', 'albumArtist', string);\n\n  meta('catg', 'category', string);\n\n  meta('com', 'composer', string);\n\n  meta('cpy', 'copyright', string);\n\n  meta('cprt', 'copyright', string);\n\n  meta('cmt', 'comments', string);\n\n  meta('day', 'releaseDate', string);\n\n  meta('desc', 'description', string);\n\n  meta('gen', 'genre', string);\n\n  meta('grp', 'grouping', string);\n\n  meta('isr', 'ISRC', string);\n\n  meta('keyw', 'keywords', string);\n\n  meta('lab', 'recordLabel', string);\n\n  meta('ldes', 'longDescription', string);\n\n  meta('lyr', 'lyrics', string);\n\n  meta('nam', 'title', string);\n\n  meta('phg', 'recordingCopyright', string);\n\n  meta('prd', 'producer', string);\n\n  meta('prf', 'performers', string);\n\n  meta('purd', 'purchaseDate', string);\n\n  meta('purl', 'podcastURL', string);\n\n  meta('swf', 'songwriter', string);\n\n  meta('too', 'encoder', string);\n\n  meta('wrt', 'composer', string);\n\n  meta('covr', 'coverArt', function(field) {\n    return this.metadata[field] = this.stream.readBuffer(this.len);\n  });\n\n  genres = [\"Blues\", \"Classic Rock\", \"Country\", \"Dance\", \"Disco\", \"Funk\", \"Grunge\", \"Hip-Hop\", \"Jazz\", \"Metal\", \"New Age\", \"Oldies\", \"Other\", \"Pop\", \"R&B\", \"Rap\", \"Reggae\", \"Rock\", \"Techno\", \"Industrial\", \"Alternative\", \"Ska\", \"Death Metal\", \"Pranks\", \"Soundtrack\", \"Euro-Techno\", \"Ambient\", \"Trip-Hop\", \"Vocal\", \"Jazz+Funk\", \"Fusion\", \"Trance\", \"Classical\", \"Instrumental\", \"Acid\", \"House\", \"Game\", \"Sound Clip\", \"Gospel\", \"Noise\", \"AlternRock\", \"Bass\", \"Soul\", \"Punk\", \"Space\", \"Meditative\", \"Instrumental Pop\", \"Instrumental Rock\", \"Ethnic\", \"Gothic\", \"Darkwave\", \"Techno-Industrial\", \"Electronic\", \"Pop-Folk\", \"Eurodance\", \"Dream\", \"Southern Rock\", \"Comedy\", \"Cult\", \"Gangsta\", \"Top 40\", \"Christian Rap\", \"Pop/Funk\", \"Jungle\", \"Native American\", \"Cabaret\", \"New Wave\", \"Psychadelic\", \"Rave\", \"Showtunes\", \"Trailer\", \"Lo-Fi\", \"Tribal\", \"Acid Punk\", \"Acid Jazz\", \"Polka\", \"Retro\", \"Musical\", \"Rock & Roll\", \"Hard Rock\", \"Folk\", \"Folk/Rock\", \"National Folk\", \"Swing\", \"Fast Fusion\", \"Bebob\", \"Latin\", \"Revival\", \"Celtic\", \"Bluegrass\", \"Avantgarde\", \"Gothic Rock\", \"Progressive Rock\", \"Psychedelic Rock\", \"Symphonic Rock\", \"Slow Rock\", \"Big Band\", \"Chorus\", \"Easy Listening\", \"Acoustic\", \"Humour\", \"Speech\", \"Chanson\", \"Opera\", \"Chamber Music\", \"Sonata\", \"Symphony\", \"Booty Bass\", \"Primus\", \"Porn Groove\", \"Satire\", \"Slow Jam\", \"Club\", \"Tango\", \"Samba\", \"Folklore\", \"Ballad\", \"Power Ballad\", \"Rhythmic Soul\", \"Freestyle\", \"Duet\", \"Punk Rock\", \"Drum Solo\", \"A Capella\", \"Euro-House\", \"Dance Hall\"];\n\n  meta('gnre', 'genre', function(field) {\n    return this.metadata[field] = genres[this.stream.readUInt16() - 1];\n  });\n\n  meta('tmpo', 'tempo', function(field) {\n    return this.metadata[field] = this.stream.readUInt16();\n  });\n\n  meta('rtng', 'rating', function(field) {\n    var rating;\n\n    rating = this.stream.readUInt8();\n    return this.metadata[field] = rating === 2 ? 'Clean' : rating !== 0 ? 'Explicit' : 'None';\n  });\n\n  diskTrack = function(field) {\n    this.stream.advance(2);\n    this.metadata[field] = this.stream.readUInt16() + ' of ' + this.stream.readUInt16();\n    return this.stream.advance(this.len - 6);\n  };\n\n  meta('disk', 'diskNumber', diskTrack);\n\n  meta('trkn', 'trackNumber', diskTrack);\n\n  bool = function(field) {\n    return this.metadata[field] = this.stream.readUInt8() === 1;\n  };\n\n  meta('cpil', 'compilation', bool);\n\n  meta('pcst', 'podcast', bool);\n\n  meta('pgap', 'gapless', bool);\n\n  return M4ADemuxer;\n\n})(AV.Demuxer);\n//import \"demuxers/m4a.coffee\";\n\nvar AIFFDemuxer, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAIFFDemuxer = (function(_super) {\n  __extends(AIFFDemuxer, _super);\n\n  function AIFFDemuxer() {\n    _ref = AIFFDemuxer.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  AV.Demuxer.register(AIFFDemuxer);\n\n  AIFFDemuxer.probe = function(buffer) {\n    var _ref1;\n\n    return buffer.peekString(0, 4) === 'FORM' && ((_ref1 = buffer.peekString(8, 4)) === 'AIFF' || _ref1 === 'AIFC');\n  };\n\n  AIFFDemuxer.prototype.readChunk = function() {\n    var buffer, format, offset, _ref1;\n\n    if (!this.readStart && this.stream.available(12)) {\n      if (this.stream.readString(4) !== 'FORM') {\n        return this.emit('error', 'Invalid AIFF.');\n      }\n      this.fileSize = this.stream.readUInt32();\n      this.fileType = this.stream.readString(4);\n      this.readStart = true;\n      if ((_ref1 = this.fileType) !== 'AIFF' && _ref1 !== 'AIFC') {\n        return this.emit('error', 'Invalid AIFF.');\n      }\n    }\n    while (this.stream.available(1)) {\n      if (!this.readHeaders && this.stream.available(8)) {\n        this.type = this.stream.readString(4);\n        this.len = this.stream.readUInt32();\n      }\n      switch (this.type) {\n        case 'COMM':\n          if (!this.stream.available(this.len)) {\n            return;\n          }\n          this.format = {\n            formatID: 'lpcm',\n            channelsPerFrame: this.stream.readUInt16(),\n            sampleCount: this.stream.readUInt32(),\n            bitsPerChannel: this.stream.readUInt16(),\n            sampleRate: this.stream.readFloat80(),\n            framesPerPacket: 1,\n            littleEndian: false,\n            floatingPoint: false\n          };\n          this.format.bytesPerPacket = (this.format.bitsPerChannel / 8) * this.format.channelsPerFrame;\n          if (this.fileType === 'AIFC') {\n            format = this.stream.readString(4);\n            this.format.littleEndian = format === 'sowt' && this.format.bitsPerChannel > 8;\n            this.format.floatingPoint = format === 'fl32' || format === 'fl64';\n            if (format === 'twos' || format === 'sowt' || format === 'fl32' || format === 'fl64' || format === 'NONE') {\n              format = 'lpcm';\n            }\n            this.format.formatID = format;\n            this.len -= 4;\n          }\n          this.stream.advance(this.len - 18);\n          this.emit('format', this.format);\n          this.emit('duration', this.format.sampleCount / this.format.sampleRate * 1000 | 0);\n          break;\n        case 'SSND':\n          if (!(this.readSSNDHeader && this.stream.available(4))) {\n            offset = this.stream.readUInt32();\n            this.stream.advance(4);\n            this.stream.advance(offset);\n            this.readSSNDHeader = true;\n          }\n          buffer = this.stream.readSingleBuffer(this.len);\n          this.len -= buffer.length;\n          this.readHeaders = this.len > 0;\n          this.emit('data', buffer);\n          break;\n        default:\n          if (!this.stream.available(this.len)) {\n            return;\n          }\n          this.stream.advance(this.len);\n      }\n      if (this.type !== 'SSND') {\n        this.readHeaders = false;\n      }\n    }\n  };\n\n  return AIFFDemuxer;\n\n})(AV.Demuxer);\n//import \"demuxers/aiff.coffee\";\n\nvar WAVEDemuxer, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nWAVEDemuxer = (function(_super) {\n  var formats;\n\n  __extends(WAVEDemuxer, _super);\n\n  function WAVEDemuxer() {\n    _ref = WAVEDemuxer.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  AV.Demuxer.register(WAVEDemuxer);\n\n  WAVEDemuxer.probe = function(buffer) {\n    return buffer.peekString(0, 4) === 'RIFF' && buffer.peekString(8, 4) === 'WAVE';\n  };\n\n  formats = {\n    0x0001: 'lpcm',\n    0x0003: 'lpcm',\n    0x0006: 'alaw',\n    0x0007: 'ulaw'\n  };\n\n  WAVEDemuxer.prototype.readChunk = function() {\n    var buffer, bytes, encoding;\n\n    if (!this.readStart && this.stream.available(12)) {\n      if (this.stream.readString(4) !== 'RIFF') {\n        return this.emit('error', 'Invalid WAV file.');\n      }\n      this.fileSize = this.stream.readUInt32(true);\n      this.readStart = true;\n      if (this.stream.readString(4) !== 'WAVE') {\n        return this.emit('error', 'Invalid WAV file.');\n      }\n    }\n    while (this.stream.available(1)) {\n      if (!this.readHeaders && this.stream.available(8)) {\n        this.type = this.stream.readString(4);\n        this.len = this.stream.readUInt32(true);\n      }\n      switch (this.type) {\n        case 'fmt ':\n          encoding = this.stream.readUInt16(true);\n          if (!(encoding in formats)) {\n            return this.emit('error', 'Unsupported format in WAV file.');\n          }\n          this.format = {\n            formatID: formats[encoding],\n            floatingPoint: encoding === 0x0003,\n            littleEndian: formats[encoding] === 'lpcm',\n            channelsPerFrame: this.stream.readUInt16(true),\n            sampleRate: this.stream.readUInt32(true),\n            framesPerPacket: 1\n          };\n          this.stream.advance(4);\n          this.stream.advance(2);\n          this.format.bitsPerChannel = this.stream.readUInt16(true);\n          this.format.bytesPerPacket = (this.format.bitsPerChannel / 8) * this.format.channelsPerFrame;\n          this.emit('format', this.format);\n          break;\n        case 'data':\n          if (!this.sentDuration) {\n            bytes = this.format.bitsPerChannel / 8;\n            this.emit('duration', this.len / bytes / this.format.channelsPerFrame / this.format.sampleRate * 1000 | 0);\n            this.sentDuration = true;\n          }\n          buffer = this.stream.readSingleBuffer(this.len);\n          this.len -= buffer.length;\n          this.readHeaders = this.len > 0;\n          this.emit('data', buffer);\n          break;\n        default:\n          if (!this.stream.available(this.len)) {\n            return;\n          }\n          this.stream.advance(this.len);\n      }\n      if (this.type !== 'data') {\n        this.readHeaders = false;\n      }\n    }\n  };\n\n  return WAVEDemuxer;\n\n})(AV.Demuxer);\n//import \"demuxers/wave.coffee\";\n\nvar AUDemuxer, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAUDemuxer = (function(_super) {\n  var bps, formats;\n\n  __extends(AUDemuxer, _super);\n\n  function AUDemuxer() {\n    _ref = AUDemuxer.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  AV.Demuxer.register(AUDemuxer);\n\n  AUDemuxer.probe = function(buffer) {\n    return buffer.peekString(0, 4) === '.snd';\n  };\n\n  bps = [8, 8, 16, 24, 32, 32, 64];\n\n  bps[26] = 8;\n\n  formats = {\n    1: 'ulaw',\n    27: 'alaw'\n  };\n\n  AUDemuxer.prototype.readChunk = function() {\n    var bytes, dataSize, encoding, size;\n\n    if (!this.readHeader && this.stream.available(24)) {\n      if (this.stream.readString(4) !== '.snd') {\n        return this.emit('error', 'Invalid AU file.');\n      }\n      size = this.stream.readUInt32();\n      dataSize = this.stream.readUInt32();\n      encoding = this.stream.readUInt32();\n      this.format = {\n        formatID: formats[encoding] || 'lpcm',\n        littleEndian: false,\n        floatingPoint: encoding === 6 || encoding === 7,\n        bitsPerChannel: bps[encoding - 1],\n        sampleRate: this.stream.readUInt32(),\n        channelsPerFrame: this.stream.readUInt32(),\n        framesPerPacket: 1\n      };\n      if (this.format.bitsPerChannel == null) {\n        return this.emit('error', 'Unsupported encoding in AU file.');\n      }\n      this.format.bytesPerPacket = (this.format.bitsPerChannel / 8) * this.format.channelsPerFrame;\n      if (dataSize !== 0xffffffff) {\n        bytes = this.format.bitsPerChannel / 8;\n        this.emit('duration', dataSize / bytes / this.format.channelsPerFrame / this.format.sampleRate * 1000 | 0);\n      }\n      this.emit('format', this.format);\n      this.readHeader = true;\n    }\n    if (this.readHeader) {\n      while (this.stream.available(1)) {\n        this.emit('data', this.stream.readSingleBuffer(this.stream.remainingBytes()));\n      }\n    }\n  };\n\n  return AUDemuxer;\n\n})(AV.Demuxer);\n//import \"demuxers/au.coffee\";\n\nvar LPCMDecoder, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nLPCMDecoder = (function(_super) {\n  __extends(LPCMDecoder, _super);\n\n  function LPCMDecoder() {\n    this.readChunk = __bind(this.readChunk, this);    _ref = LPCMDecoder.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  AV.Decoder.register('lpcm', LPCMDecoder);\n\n  LPCMDecoder.prototype.readChunk = function() {\n    var chunkSize, i, littleEndian, output, samples, stream, _i, _j, _k, _l, _m, _n;\n\n    stream = this.stream;\n    littleEndian = this.format.littleEndian;\n    chunkSize = Math.min(4096, stream.remainingBytes());\n    samples = chunkSize / (this.format.bitsPerChannel / 8) | 0;\n    if (chunkSize < this.format.bitsPerChannel / 8) {\n      return null;\n    }\n    if (this.format.floatingPoint) {\n      switch (this.format.bitsPerChannel) {\n        case 32:\n          output = new Float32Array(samples);\n          for (i = _i = 0; _i < samples; i = _i += 1) {\n            output[i] = stream.readFloat32(littleEndian);\n          }\n          break;\n        case 64:\n          output = new Float64Array(samples);\n          for (i = _j = 0; _j < samples; i = _j += 1) {\n            output[i] = stream.readFloat64(littleEndian);\n          }\n          break;\n        default:\n          throw new Error('Unsupported bit depth.');\n      }\n    } else {\n      switch (this.format.bitsPerChannel) {\n        case 8:\n          output = new Int8Array(samples);\n          for (i = _k = 0; _k < samples; i = _k += 1) {\n            output[i] = stream.readInt8();\n          }\n          break;\n        case 16:\n          output = new Int16Array(samples);\n          for (i = _l = 0; _l < samples; i = _l += 1) {\n            output[i] = stream.readInt16(littleEndian);\n          }\n          break;\n        case 24:\n          output = new Int32Array(samples);\n          for (i = _m = 0; _m < samples; i = _m += 1) {\n            output[i] = stream.readInt24(littleEndian);\n          }\n          break;\n        case 32:\n          output = new Int32Array(samples);\n          for (i = _n = 0; _n < samples; i = _n += 1) {\n            output[i] = stream.readInt32(littleEndian);\n          }\n          break;\n        default:\n          throw new Error('Unsupported bit depth.');\n      }\n    }\n    return output;\n  };\n\n  return LPCMDecoder;\n\n})(AV.Decoder);\n//import \"decoders/lpcm.coffee\";\n\nvar XLAWDecoder, _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nXLAWDecoder = (function(_super) {\n  var BIAS, QUANT_MASK, SEG_MASK, SEG_SHIFT, SIGN_BIT;\n\n  __extends(XLAWDecoder, _super);\n\n  function XLAWDecoder() {\n    this.readChunk = __bind(this.readChunk, this);    _ref = XLAWDecoder.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  AV.Decoder.register('ulaw', XLAWDecoder);\n\n  AV.Decoder.register('alaw', XLAWDecoder);\n\n  SIGN_BIT = 0x80;\n\n  QUANT_MASK = 0xf;\n\n  SEG_SHIFT = 4;\n\n  SEG_MASK = 0x70;\n\n  BIAS = 0x84;\n\n  XLAWDecoder.prototype.init = function() {\n    var i, seg, t, table, val, _i, _j;\n\n    this.format.bitsPerChannel = 16;\n    this.table = table = new Int16Array(256);\n    if (this.format.formatID === 'ulaw') {\n      for (i = _i = 0; _i < 256; i = ++_i) {\n        val = ~i;\n        t = ((val & QUANT_MASK) << 3) + BIAS;\n        t <<= (val & SEG_MASK) >>> SEG_SHIFT;\n        table[i] = val & SIGN_BIT ? BIAS - t : t - BIAS;\n      }\n    } else {\n      for (i = _j = 0; _j < 256; i = ++_j) {\n        val = i ^ 0x55;\n        t = val & QUANT_MASK;\n        seg = (val & SEG_MASK) >>> SEG_SHIFT;\n        if (seg) {\n          t = (t + t + 1 + 32) << (seg + 2);\n        } else {\n          t = (t + t + 1) << 3;\n        }\n        table[i] = val & SIGN_BIT ? t : -t;\n      }\n    }\n  };\n\n  XLAWDecoder.prototype.readChunk = function() {\n    var i, output, samples, stream, table, _i;\n\n    stream = this.stream, table = this.table;\n    samples = Math.min(4096, this.stream.remainingBytes());\n    if (samples === 0) {\n      return;\n    }\n    output = new Int16Array(samples);\n    for (i = _i = 0; _i < samples; i = _i += 1) {\n      output[i] = table[stream.readUInt8()];\n    }\n    return output;\n  };\n\n  return XLAWDecoder;\n\n})(AV.Decoder);\n//import \"decoders/xlaw.coffee\";\n//import \"src/aurora.coffee\";\n  var __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.HTTPSource = (function(_super) {\n  __extends(HTTPSource, _super);\n\n  function HTTPSource(url) {\n    this.url = url;\n    this.chunkSize = 1 << 20;\n    this.inflight = false;\n    this.reset();\n  }\n\n  HTTPSource.prototype.start = function() {\n    var _this = this;\n\n    if (this.length) {\n      if (!this.inflight) {\n        return this.loop();\n      }\n    }\n    this.inflight = true;\n    this.xhr = new XMLHttpRequest();\n    this.xhr.onload = function(event) {\n      _this.length = parseInt(_this.xhr.getResponseHeader(\"Content-Length\"));\n      _this.inflight = false;\n      return _this.loop();\n    };\n    this.xhr.onerror = function(err) {\n      _this.pause();\n      return _this.emit('error', err);\n    };\n    this.xhr.onabort = function(event) {\n      return _this.inflight = false;\n    };\n    this.xhr.open(\"HEAD\", this.url, true);\n    return this.xhr.send(null);\n  };\n\n  HTTPSource.prototype.loop = function() {\n    var endPos,\n      _this = this;\n\n    if (this.inflight || !this.length) {\n      return this.emit('error', 'Something is wrong in HTTPSource.loop');\n    }\n    this.inflight = true;\n    this.xhr = new XMLHttpRequest();\n    this.xhr.onload = function(event) {\n      var buf, buffer, i, txt, _i, _ref;\n\n      if (_this.xhr.response) {\n        buf = new Uint8Array(_this.xhr.response);\n      } else {\n        txt = _this.xhr.responseText;\n        buf = new Uint8Array(txt.length);\n        for (i = _i = 0, _ref = txt.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          buf[i] = txt.charCodeAt(i) & 0xff;\n        }\n      }\n      buffer = new AV.Buffer(buf);\n      _this.offset += buffer.length;\n      _this.emit('data', buffer);\n      if (_this.offset >= _this.length) {\n        _this.emit('end');\n      }\n      _this.inflight = false;\n      if (!(_this.offset >= _this.length)) {\n        return _this.loop();\n      }\n    };\n    this.xhr.onprogress = function(event) {\n      return _this.emit('progress', (_this.offset + event.loaded) / _this.length * 100);\n    };\n    this.xhr.onerror = function(err) {\n      _this.emit('error', err);\n      return _this.pause();\n    };\n    this.xhr.onabort = function(event) {\n      return _this.inflight = false;\n    };\n    this.xhr.open(\"GET\", this.url, true);\n    this.xhr.responseType = \"arraybuffer\";\n    endPos = Math.min(this.offset + this.chunkSize, this.length);\n    this.xhr.setRequestHeader(\"Range\", \"bytes=\" + this.offset + \"-\" + endPos);\n    this.xhr.overrideMimeType('text/plain; charset=x-user-defined');\n    return this.xhr.send(null);\n  };\n\n  HTTPSource.prototype.pause = function() {\n    var _ref;\n\n    this.inflight = false;\n    return (_ref = this.xhr) != null ? _ref.abort() : void 0;\n  };\n\n  HTTPSource.prototype.reset = function() {\n    this.pause();\n    return this.offset = 0;\n  };\n\n  return HTTPSource;\n\n})(AV.EventEmitter);\n//import \"src/sources/browser/http.coffee\";\n  var __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nAV.FileSource = (function(_super) {\n  __extends(FileSource, _super);\n\n  function FileSource(file) {\n    this.file = file;\n    if (typeof FileReader === \"undefined\" || FileReader === null) {\n      return this.emit('error', 'This browser does not have FileReader support.');\n    }\n    this.offset = 0;\n    this.length = this.file.size;\n    this.chunkSize = 1 << 20;\n  }\n\n  FileSource.prototype.start = function() {\n    var _this = this;\n\n    if (this.reader) {\n      if (!this.active) {\n        return this.loop();\n      }\n    }\n    this.reader = new FileReader;\n    this.active = true;\n    this.reader.onload = function(e) {\n      var buf;\n\n      buf = new AV.Buffer(new Uint8Array(e.target.result));\n      _this.offset += buf.length;\n      _this.emit('data', buf);\n      _this.active = false;\n      if (_this.offset < _this.length) {\n        return _this.loop();\n      }\n    };\n    this.reader.onloadend = function() {\n      if (_this.offset === _this.length) {\n        _this.emit('end');\n        return _this.reader = null;\n      }\n    };\n    this.reader.onerror = function(e) {\n      return _this.emit('error', e);\n    };\n    this.reader.onprogress = function(e) {\n      return _this.emit('progress', (_this.offset + e.loaded) / _this.length * 100);\n    };\n    return this.loop();\n  };\n\n  FileSource.prototype.loop = function() {\n    var blob, endPos, slice;\n\n    this.active = true;\n    this.file[slice = 'slice'] || this.file[slice = 'webkitSlice'] || this.file[slice = 'mozSlice'];\n    endPos = Math.min(this.offset + this.chunkSize, this.length);\n    blob = this.file[slice](this.offset, endPos);\n    return this.reader.readAsArrayBuffer(blob);\n  };\n\n  FileSource.prototype.pause = function() {\n    var _ref;\n\n    this.active = false;\n    return (_ref = this.reader) != null ? _ref.abort() : void 0;\n  };\n\n  FileSource.prototype.reset = function() {\n    this.pause();\n    return this.offset = 0;\n  };\n\n  return FileSource;\n\n})(AV.EventEmitter);\n//import \"src/sources/browser/file.coffee\";\n  return global.AV = AV;\n})();\n";
var aac = "/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n(function() {\n    \nconst SAMPLE_RATES = new Int32Array([\n    96000, 88200, 64000, 48000, 44100, 32000,\n    24000, 22050, 16000, 12000, 11025, 8000, 7350    \n]);\n    \nvar ADTSDemuxer = AV.Demuxer.extend(function() {\n    AV.Demuxer.register(this);\n    \n    this.probe = function(stream) {\n        var offset = stream.offset;\n        \n        // attempt to find ADTS syncword\n        while (stream.available(2)) {\n            if ((stream.readUInt16() & 0xfff6) === 0xfff0) {\n                stream.seek(offset);\n                return true;\n            }\n        }\n        \n        stream.seek(offset);\n        return false;\n    };\n        \n    this.prototype.init = function() {\n        this.bitstream = new AV.Bitstream(this.stream);\n    };\n    \n    // Reads an ADTS header\n    // See http://wiki.multimedia.cx/index.php?title=ADTS\n    this.readHeader = function(stream) {\n        if (stream.read(12) !== 0xfff)\n            throw new Error('Invalid ADTS header.');\n            \n        var ret = {};\n        stream.advance(3); // mpeg version and layer\n        var protectionAbsent = !!stream.read(1);\n        \n        ret.profile = stream.read(2) + 1;\n        ret.samplingIndex = stream.read(4);\n        \n        stream.advance(1); // private\n        ret.chanConfig = stream.read(3);\n        stream.advance(4); // original/copy, home, copywrite, and copywrite start\n        \n        ret.frameLength = stream.read(13);\n        stream.advance(11); // fullness\n        \n        ret.numFrames = stream.read(2) + 1;\n        \n        if (!protectionAbsent)\n            stream.advance(16);\n        \n        return ret;\n    };\n    \n    this.prototype.readChunk = function() {\n        if (!this.sentHeader) {\n            var offset = this.stream.offset;\n            var header = ADTSDemuxer.readHeader(this.bitstream);\n            \n            this.emit('format', {\n                formatID: 'aac ',\n                sampleRate: SAMPLE_RATES[header.samplingIndex],\n                channelsPerFrame: header.chanConfig,\n                bitsPerChannel: 16,\n            });\n            \n            // generate a magic cookie from the ADTS header\n            var cookie = new Uint8Array(2);\n            cookie[0] = (header.profile << 3) | ((header.samplingIndex >> 1) & 7);\n            cookie[1] = ((header.samplingIndex & 1) << 7) | (header.chanConfig << 3);\n            this.emit('cookie', new AV.Buffer(cookie));\n            \n            this.stream.seek(offset);\n            this.sentHeader = true;\n        }\n        \n        while (this.stream.available(1)) {\n            var buffer = this.stream.readSingleBuffer(this.stream.remainingBytes());\n            this.emit('data', buffer);\n        }\n    };\n});//import \"adts_demuxer.js\"\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n/********************************************************************************\n * Sample offset into the window indicating the beginning of a scalefactor\n * window band\n *\n * scalefactor window band - term for scalefactor bands within a window,\n * given in Table 4.110 to Table 4.128.\n *\n * scalefactor band - a set of spectral coefficients which are scaled by one\n * scalefactor. In case of EIGHT_SHORT_SEQUENCE and grouping a scalefactor band\n * may contain several scalefactor window bands of corresponding frequency. For\n * all other window_sequences scalefactor bands and scalefactor window bands are\n * identical.\n *******************************************************************************/\nconst SWB_OFFSET_1024_96 = new Uint16Array([\n      0,   4,   8,  12,  16,  20,  24,  28,\n     32,  36,  40,  44,  48,  52,  56,  64,\n     72,  80,  88,  96, 108, 120, 132, 144,\n    156, 172, 188, 212, 240, 276, 320, 384,\n    448, 512, 576, 640, 704, 768, 832, 896,\n    960, 1024\n]);\n\nconst SWB_OFFSET_128_96 = new Uint16Array([\n    0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128\n]);\n\nconst SWB_OFFSET_1024_64 = new Uint16Array([\n      0,   4,   8,  12,  16,  20,  24,  28,\n     32,  36,  40,  44,  48,  52,  56,  64,\n     72,  80,  88, 100, 112, 124, 140, 156,\n    172, 192, 216, 240, 268, 304, 344, 384,\n    424, 464, 504, 544, 584, 624, 664, 704,\n    744, 784, 824, 864, 904, 944, 984, 1024\n]);\n\nconst SWB_OFFSET_128_64 = new Uint16Array([\n    0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128\n]);\n\nconst SWB_OFFSET_1024_48 = new Uint16Array([\n      0,   4,   8,  12,  16,  20,  24,  28,\n     32,  36,  40,  48,  56,  64,  72,  80,\n     88,  96, 108, 120, 132, 144, 160, 176,\n    196, 216, 240, 264, 292, 320, 352, 384,\n    416, 448, 480, 512, 544, 576, 608, 640,\n    672, 704, 736, 768, 800, 832, 864, 896,\n    928, 1024\n]);\n\nconst SWB_OFFSET_128_48 = new Uint16Array([\n     0,   4,   8,  12,  16,  20,  28,  36,\n    44,  56,  68,  80,  96, 112, 128\n]);\n\nconst SWB_OFFSET_1024_32 = new Uint16Array([\n      0,   4,   8,  12,  16,  20,  24,  28,\n     32,  36,  40,  48,  56,  64,  72,  80,\n     88,  96, 108, 120, 132, 144, 160, 176,\n    196, 216, 240, 264, 292, 320, 352, 384,\n    416, 448, 480, 512, 544, 576, 608, 640,\n    672, 704, 736, 768, 800, 832, 864, 896,\n    928, 960, 992, 1024\n]);\n\nconst SWB_OFFSET_1024_24 = new Uint16Array([\n      0,   4,   8,  12,  16,  20,  24,  28,\n     32,  36,  40,  44,  52,  60,  68,  76,\n     84,  92, 100, 108, 116, 124, 136, 148,\n    160, 172, 188, 204, 220, 240, 260, 284,\n    308, 336, 364, 396, 432, 468, 508, 552,\n    600, 652, 704, 768, 832, 896, 960, 1024\n]);\n\nconst SWB_OFFSET_128_24 = new Uint16Array([\n     0,   4,   8,  12,  16,  20,  24,  28,\n    36,  44,  52,  64,  76,  92, 108, 128\n]);\n\nconst SWB_OFFSET_1024_16 = new Uint16Array([\n      0,   8,  16,  24,  32,  40,  48,  56,\n     64,  72,  80,  88, 100, 112, 124, 136,\n    148, 160, 172, 184, 196, 212, 228, 244,\n    260, 280, 300, 320, 344, 368, 396, 424,\n    456, 492, 532, 572, 616, 664, 716, 772,\n    832, 896, 960, 1024\n]);\n\nconst SWB_OFFSET_128_16 = new Uint16Array([\n     0,   4,   8,  12,  16,  20,  24,  28,\n    32,  40,  48,  60,  72,  88, 108, 128\n]);\n\nconst SWB_OFFSET_1024_8 = new Uint16Array([\n      0,  12,  24,  36,  48,  60,  72,  84,\n     96, 108, 120, 132, 144, 156, 172, 188,\n    204, 220, 236, 252, 268, 288, 308, 328,\n    348, 372, 396, 420, 448, 476, 508, 544,\n    580, 620, 664, 712, 764, 820, 880, 944,\n    1024\n]);\n\nconst SWB_OFFSET_128_8 = new Uint16Array([\n     0,   4,   8,  12,  16,  20,  24,  28,\n    36,  44,  52,  60,  72,  88, 108, 128\n]);\n\nconst SWB_OFFSET_1024 = [\n    SWB_OFFSET_1024_96,\n    SWB_OFFSET_1024_96,\n    SWB_OFFSET_1024_64,\n    SWB_OFFSET_1024_48,\n    SWB_OFFSET_1024_48,\n    SWB_OFFSET_1024_32,\n    SWB_OFFSET_1024_24,\n    SWB_OFFSET_1024_24,\n    SWB_OFFSET_1024_16,\n    SWB_OFFSET_1024_16,\n    SWB_OFFSET_1024_16,\n    SWB_OFFSET_1024_8\n];\n\nconst SWB_OFFSET_128 = [\n    SWB_OFFSET_128_96,\n    SWB_OFFSET_128_96,\n    SWB_OFFSET_128_64,\n    SWB_OFFSET_128_48,\n    SWB_OFFSET_128_48,\n    SWB_OFFSET_128_48,\n    SWB_OFFSET_128_24,\n    SWB_OFFSET_128_24,\n    SWB_OFFSET_128_16,\n    SWB_OFFSET_128_16,\n    SWB_OFFSET_128_16,\n    SWB_OFFSET_128_8\n];\n\nconst SWB_SHORT_WINDOW_COUNT = new Uint8Array([\n    12, 12, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15\n]);\n\nconst SWB_LONG_WINDOW_COUNT = new Uint8Array([\n    41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40\n]);\n\n/*\n * Scalefactor lookup table\n */\nconst SCALEFACTOR_TABLE = (function() {\n    var table = new Float32Array(428);\n    \n    for (var i = 0; i < 428; i++) {\n        table[i] = Math.pow(2, (i - 200) / 4);\n    }\n    \n    return table;\n})();\n\n\n/**\n * Inverse quantization lookup table\n */\nconst IQ_TABLE = (function() {\n    var table = new Float32Array(8191),\n        four_thirds = 4/3;\n        \n    for (var i = 0; i < 8191; i++) {\n        table[i] = Math.pow(i, four_thirds);\n    }\n    \n    return table;\n})();//import \"tables.js\"\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar Huffman = (function() {\n\n    // [bit length, codeword, values...]\n    const HCB1 = [\n        [1, 0, 0, 0, 0, 0],\n        [5, 16, 1, 0, 0, 0],\n        [5, 17, -1, 0, 0, 0],\n        [5, 18, 0, 0, 0, -1],\n        [5, 19, 0, 1, 0, 0],\n        [5, 20, 0, 0, 0, 1],\n        [5, 21, 0, 0, -1, 0],\n        [5, 22, 0, 0, 1, 0],\n        [5, 23, 0, -1, 0, 0],\n        [7, 96, 1, -1, 0, 0],\n        [7, 97, -1, 1, 0, 0],\n        [7, 98, 0, 0, -1, 1],\n        [7, 99, 0, 1, -1, 0],\n        [7, 100, 0, -1, 1, 0],\n        [7, 101, 0, 0, 1, -1],\n        [7, 102, 1, 1, 0, 0],\n        [7, 103, 0, 0, -1, -1],\n        [7, 104, -1, -1, 0, 0],\n        [7, 105, 0, -1, -1, 0],\n        [7, 106, 1, 0, -1, 0],\n        [7, 107, 0, 1, 0, -1],\n        [7, 108, -1, 0, 1, 0],\n        [7, 109, 0, 0, 1, 1],\n        [7, 110, 1, 0, 1, 0],\n        [7, 111, 0, -1, 0, 1],\n        [7, 112, 0, 1, 1, 0],\n        [7, 113, 0, 1, 0, 1],\n        [7, 114, -1, 0, -1, 0],\n        [7, 115, 1, 0, 0, 1],\n        [7, 116, -1, 0, 0, -1],\n        [7, 117, 1, 0, 0, -1],\n        [7, 118, -1, 0, 0, 1],\n        [7, 119, 0, -1, 0, -1],\n        [9, 480, 1, 1, -1, 0],\n        [9, 481, -1, 1, -1, 0],\n        [9, 482, 1, -1, 1, 0],\n        [9, 483, 0, 1, 1, -1],\n        [9, 484, 0, 1, -1, 1],\n        [9, 485, 0, -1, 1, 1],\n        [9, 486, 0, -1, 1, -1],\n        [9, 487, 1, -1, -1, 0],\n        [9, 488, 1, 0, -1, 1],\n        [9, 489, 0, 1, -1, -1],\n        [9, 490, -1, 1, 1, 0],\n        [9, 491, -1, 0, 1, -1],\n        [9, 492, -1, -1, 1, 0],\n        [9, 493, 0, -1, -1, 1],\n        [9, 494, 1, -1, 0, 1],\n        [9, 495, 1, -1, 0, -1],\n        [9, 496, -1, 1, 0, -1],\n        [9, 497, -1, -1, -1, 0],\n        [9, 498, 0, -1, -1, -1],\n        [9, 499, 0, 1, 1, 1],\n        [9, 500, 1, 0, 1, -1],\n        [9, 501, 1, 1, 0, 1],\n        [9, 502, -1, 1, 0, 1],\n        [9, 503, 1, 1, 1, 0],\n        [10, 1008, -1, -1, 0, 1],\n        [10, 1009, -1, 0, -1, -1],\n        [10, 1010, 1, 1, 0, -1],\n        [10, 1011, 1, 0, -1, -1],\n        [10, 1012, -1, 0, -1, 1],\n        [10, 1013, -1, -1, 0, -1],\n        [10, 1014, -1, 0, 1, 1],\n        [10, 1015, 1, 0, 1, 1],\n        [11, 2032, 1, -1, 1, -1],\n        [11, 2033, -1, 1, -1, 1],\n        [11, 2034, -1, 1, 1, -1],\n        [11, 2035, 1, -1, -1, 1],\n        [11, 2036, 1, 1, 1, 1],\n        [11, 2037, -1, -1, 1, 1],\n        [11, 2038, 1, 1, -1, -1],\n        [11, 2039, -1, -1, 1, -1],\n        [11, 2040, -1, -1, -1, -1],\n        [11, 2041, 1, 1, -1, 1],\n        [11, 2042, 1, -1, 1, 1],\n        [11, 2043, -1, 1, 1, 1],\n        [11, 2044, -1, 1, -1, -1],\n        [11, 2045, -1, -1, -1, 1],\n        [11, 2046, 1, -1, -1, -1],\n        [11, 2047, 1, 1, 1, -1]\n    ];\n    \n    const HCB2 = [\n        [3, 0, 0, 0, 0, 0],\n        [4, 2, 1, 0, 0, 0],\n        [5, 6, -1, 0, 0, 0],\n        [5, 7, 0, 0, 0, 1],\n        [5, 8, 0, 0, -1, 0],\n        [5, 9, 0, 0, 0, -1],\n        [5, 10, 0, -1, 0, 0],\n        [5, 11, 0, 0, 1, 0],\n        [5, 12, 0, 1, 0, 0],\n        [6, 26, 0, -1, 1, 0],\n        [6, 27, -1, 1, 0, 0],\n        [6, 28, 0, 1, -1, 0],\n        [6, 29, 0, 0, 1, -1],\n        [6, 30, 0, 1, 0, -1],\n        [6, 31, 0, 0, -1, 1],\n        [6, 32, -1, 0, 0, -1],\n        [6, 33, 1, -1, 0, 0],\n        [6, 34, 1, 0, -1, 0],\n        [6, 35, -1, -1, 0, 0],\n        [6, 36, 0, 0, -1, -1],\n        [6, 37, 1, 0, 1, 0],\n        [6, 38, 1, 0, 0, 1],\n        [6, 39, 0, -1, 0, 1],\n        [6, 40, -1, 0, 1, 0],\n        [6, 41, 0, 1, 0, 1],\n        [6, 42, 0, -1, -1, 0],\n        [6, 43, -1, 0, 0, 1],\n        [6, 44, 0, -1, 0, -1],\n        [6, 45, -1, 0, -1, 0],\n        [6, 46, 1, 1, 0, 0],\n        [6, 47, 0, 1, 1, 0],\n        [6, 48, 0, 0, 1, 1],\n        [6, 49, 1, 0, 0, -1],\n        [7, 100, 0, 1, -1, 1],\n        [7, 101, 1, 0, -1, 1],\n        [7, 102, -1, 1, -1, 0],\n        [7, 103, 0, -1, 1, -1],\n        [7, 104, 1, -1, 1, 0],\n        [7, 105, 1, 1, 0, -1],\n        [7, 106, 1, 0, 1, 1],\n        [7, 107, -1, 1, 1, 0],\n        [7, 108, 0, -1, -1, 1],\n        [7, 109, 1, 1, 1, 0],\n        [7, 110, -1, 0, 1, -1],\n        [7, 111, -1, -1, -1, 0],\n        [7, 112, -1, 0, -1, 1],\n        [7, 113, 1, -1, -1, 0],\n        [7, 114, 1, 1, -1, 0],\n        [8, 230, 1, -1, 0, 1],\n        [8, 231, -1, 1, 0, -1],\n        [8, 232, -1, -1, 1, 0],\n        [8, 233, -1, 0, 1, 1],\n        [8, 234, -1, -1, 0, 1],\n        [8, 235, -1, -1, 0, -1],\n        [8, 236, 0, -1, -1, -1],\n        [8, 237, 1, 0, 1, -1],\n        [8, 238, 1, 0, -1, -1],\n        [8, 239, 0, 1, -1, -1],\n        [8, 240, 0, 1, 1, 1],\n        [8, 241, -1, 1, 0, 1],\n        [8, 242, -1, 0, -1, -1],\n        [8, 243, 0, 1, 1, -1],\n        [8, 244, 1, -1, 0, -1],\n        [8, 245, 0, -1, 1, 1],\n        [8, 246, 1, 1, 0, 1],\n        [8, 247, 1, -1, 1, -1],\n        [8, 248, -1, 1, -1, 1],\n        [9, 498, 1, -1, -1, 1],\n        [9, 499, -1, -1, -1, -1],\n        [9, 500, -1, 1, 1, -1],\n        [9, 501, -1, 1, 1, 1],\n        [9, 502, 1, 1, 1, 1],\n        [9, 503, -1, -1, 1, -1],\n        [9, 504, 1, -1, 1, 1],\n        [9, 505, -1, 1, -1, -1],\n        [9, 506, -1, -1, 1, 1],\n        [9, 507, 1, 1, -1, -1],\n        [9, 508, 1, -1, -1, -1],\n        [9, 509, -1, -1, -1, 1],\n        [9, 510, 1, 1, -1, 1],\n        [9, 511, 1, 1, 1, -1]\n    ];\n    \n    const HCB3 = [\n        [1, 0, 0, 0, 0, 0],\n        [4, 8, 1, 0, 0, 0],\n        [4, 9, 0, 0, 0, 1],\n        [4, 10, 0, 1, 0, 0],\n        [4, 11, 0, 0, 1, 0],\n        [5, 24, 1, 1, 0, 0],\n        [5, 25, 0, 0, 1, 1],\n        [6, 52, 0, 1, 1, 0],\n        [6, 53, 0, 1, 0, 1],\n        [6, 54, 1, 0, 1, 0],\n        [6, 55, 0, 1, 1, 1],\n        [6, 56, 1, 0, 0, 1],\n        [6, 57, 1, 1, 1, 0],\n        [7, 116, 1, 1, 1, 1],\n        [7, 117, 1, 0, 1, 1],\n        [7, 118, 1, 1, 0, 1],\n        [8, 238, 2, 0, 0, 0],\n        [8, 239, 0, 0, 0, 2],\n        [8, 240, 0, 0, 1, 2],\n        [8, 241, 2, 1, 0, 0],\n        [8, 242, 1, 2, 1, 0],\n        [9, 486, 0, 0, 2, 1],\n        [9, 487, 0, 1, 2, 1],\n        [9, 488, 1, 2, 0, 0],\n        [9, 489, 0, 1, 1, 2],\n        [9, 490, 2, 1, 1, 0],\n        [9, 491, 0, 0, 2, 0],\n        [9, 492, 0, 2, 1, 0],\n        [9, 493, 0, 1, 2, 0],\n        [9, 494, 0, 2, 0, 0],\n        [9, 495, 0, 1, 0, 2],\n        [9, 496, 2, 0, 1, 0],\n        [9, 497, 1, 2, 1, 1],\n        [9, 498, 0, 2, 1, 1],\n        [9, 499, 1, 1, 2, 0],\n        [9, 500, 1, 1, 2, 1],\n        [10, 1002, 1, 2, 0, 1],\n        [10, 1003, 1, 0, 2, 0],\n        [10, 1004, 1, 0, 2, 1],\n        [10, 1005, 0, 2, 0, 1],\n        [10, 1006, 2, 1, 1, 1],\n        [10, 1007, 1, 1, 1, 2],\n        [10, 1008, 2, 1, 0, 1],\n        [10, 1009, 1, 0, 1, 2],\n        [10, 1010, 0, 0, 2, 2],\n        [10, 1011, 0, 1, 2, 2],\n        [10, 1012, 2, 2, 1, 0],\n        [10, 1013, 1, 2, 2, 0],\n        [10, 1014, 1, 0, 0, 2],\n        [10, 1015, 2, 0, 0, 1],\n        [10, 1016, 0, 2, 2, 1],\n        [11, 2034, 2, 2, 0, 0],\n        [11, 2035, 1, 2, 2, 1],\n        [11, 2036, 1, 1, 0, 2],\n        [11, 2037, 2, 0, 1, 1],\n        [11, 2038, 1, 1, 2, 2],\n        [11, 2039, 2, 2, 1, 1],\n        [11, 2040, 0, 2, 2, 0],\n        [11, 2041, 0, 2, 1, 2],\n        [12, 4084, 1, 0, 2, 2],\n        [12, 4085, 2, 2, 0, 1],\n        [12, 4086, 2, 1, 2, 0],\n        [12, 4087, 2, 2, 2, 0],\n        [12, 4088, 0, 2, 2, 2],\n        [12, 4089, 2, 2, 2, 1],\n        [12, 4090, 2, 1, 2, 1],\n        [12, 4091, 1, 2, 1, 2],\n        [12, 4092, 1, 2, 2, 2],\n        [13, 8186, 0, 2, 0, 2],\n        [13, 8187, 2, 0, 2, 0],\n        [13, 8188, 1, 2, 0, 2],\n        [14, 16378, 2, 0, 2, 1],\n        [14, 16379, 2, 1, 1, 2],\n        [14, 16380, 2, 1, 0, 2],\n        [15, 32762, 2, 2, 2, 2],\n        [15, 32763, 2, 2, 1, 2],\n        [15, 32764, 2, 1, 2, 2],\n        [15, 32765, 2, 0, 1, 2],\n        [15, 32766, 2, 0, 0, 2],\n        [16, 65534, 2, 2, 0, 2],\n        [16, 65535, 2, 0, 2, 2]\n    ];\n    \n    const HCB4 = [\n        [4, 0, 1, 1, 1, 1],\n        [4, 1, 0, 1, 1, 1],\n        [4, 2, 1, 1, 0, 1],\n        [4, 3, 1, 1, 1, 0],\n        [4, 4, 1, 0, 1, 1],\n        [4, 5, 1, 0, 0, 0],\n        [4, 6, 1, 1, 0, 0],\n        [4, 7, 0, 0, 0, 0],\n        [4, 8, 0, 0, 1, 1],\n        [4, 9, 1, 0, 1, 0],\n        [5, 20, 1, 0, 0, 1],\n        [5, 21, 0, 1, 1, 0],\n        [5, 22, 0, 0, 0, 1],\n        [5, 23, 0, 1, 0, 1],\n        [5, 24, 0, 0, 1, 0],\n        [5, 25, 0, 1, 0, 0],\n        [7, 104, 2, 1, 1, 1],\n        [7, 105, 1, 1, 2, 1],\n        [7, 106, 1, 2, 1, 1],\n        [7, 107, 1, 1, 1, 2],\n        [7, 108, 2, 1, 1, 0],\n        [7, 109, 2, 1, 0, 1],\n        [7, 110, 1, 2, 1, 0],\n        [7, 111, 2, 0, 1, 1],\n        [7, 112, 0, 1, 2, 1],\n        [8, 226, 0, 1, 1, 2],\n        [8, 227, 1, 1, 2, 0],\n        [8, 228, 0, 2, 1, 1],\n        [8, 229, 1, 0, 1, 2],\n        [8, 230, 1, 2, 0, 1],\n        [8, 231, 1, 1, 0, 2],\n        [8, 232, 1, 0, 2, 1],\n        [8, 233, 2, 1, 0, 0],\n        [8, 234, 2, 0, 1, 0],\n        [8, 235, 1, 2, 0, 0],\n        [8, 236, 2, 0, 0, 1],\n        [8, 237, 0, 1, 0, 2],\n        [8, 238, 0, 2, 1, 0],\n        [8, 239, 0, 0, 1, 2],\n        [8, 240, 0, 1, 2, 0],\n        [8, 241, 0, 2, 0, 1],\n        [8, 242, 1, 0, 0, 2],\n        [8, 243, 0, 0, 2, 1],\n        [8, 244, 1, 0, 2, 0],\n        [8, 245, 2, 0, 0, 0],\n        [8, 246, 0, 0, 0, 2],\n        [9, 494, 0, 2, 0, 0],\n        [9, 495, 0, 0, 2, 0],\n        [9, 496, 1, 2, 2, 1],\n        [9, 497, 2, 2, 1, 1],\n        [9, 498, 2, 1, 2, 1],\n        [9, 499, 1, 1, 2, 2],\n        [9, 500, 1, 2, 1, 2],\n        [9, 501, 2, 1, 1, 2],\n        [10, 1004, 1, 2, 2, 0],\n        [10, 1005, 2, 2, 1, 0],\n        [10, 1006, 2, 1, 2, 0],\n        [10, 1007, 0, 2, 2, 1],\n        [10, 1008, 0, 1, 2, 2],\n        [10, 1009, 2, 2, 0, 1],\n        [10, 1010, 0, 2, 1, 2],\n        [10, 1011, 2, 0, 2, 1],\n        [10, 1012, 1, 0, 2, 2],\n        [10, 1013, 2, 2, 2, 1],\n        [10, 1014, 1, 2, 0, 2],\n        [10, 1015, 2, 0, 1, 2],\n        [10, 1016, 2, 1, 0, 2],\n        [10, 1017, 1, 2, 2, 2],\n        [11, 2036, 2, 1, 2, 2],\n        [11, 2037, 2, 2, 1, 2],\n        [11, 2038, 0, 2, 2, 0],\n        [11, 2039, 2, 2, 0, 0],\n        [11, 2040, 0, 0, 2, 2],\n        [11, 2041, 2, 0, 2, 0],\n        [11, 2042, 0, 2, 0, 2],\n        [11, 2043, 2, 0, 0, 2],\n        [11, 2044, 2, 2, 2, 2],\n        [11, 2045, 0, 2, 2, 2],\n        [11, 2046, 2, 2, 2, 0],\n        [12, 4094, 2, 2, 0, 2],\n        [12, 4095, 2, 0, 2, 2]\n    ];\n    \n    const HCB5 = [\n        [1, 0, 0, 0],\n        [4, 8, -1, 0],\n        [4, 9, 1, 0],\n        [4, 10, 0, 1],\n        [4, 11, 0, -1],\n        [5, 24, 1, -1],\n        [5, 25, -1, 1],\n        [5, 26, -1, -1],\n        [5, 27, 1, 1],\n        [7, 112, -2, 0],\n        [7, 113, 0, 2],\n        [7, 114, 2, 0],\n        [7, 115, 0, -2],\n        [8, 232, -2, -1],\n        [8, 233, 2, 1],\n        [8, 234, -1, -2],\n        [8, 235, 1, 2],\n        [8, 236, -2, 1],\n        [8, 237, 2, -1],\n        [8, 238, -1, 2],\n        [8, 239, 1, -2],\n        [8, 240, -3, 0],\n        [8, 241, 3, 0],\n        [8, 242, 0, -3],\n        [8, 243, 0, 3],\n        [9, 488, -3, -1],\n        [9, 489, 1, 3],\n        [9, 490, 3, 1],\n        [9, 491, -1, -3],\n        [9, 492, -3, 1],\n        [9, 493, 3, -1],\n        [9, 494, 1, -3],\n        [9, 495, -1, 3],\n        [9, 496, -2, 2],\n        [9, 497, 2, 2],\n        [9, 498, -2, -2],\n        [9, 499, 2, -2],\n        [10, 1000, -3, -2],\n        [10, 1001, 3, -2],\n        [10, 1002, -2, 3],\n        [10, 1003, 2, -3],\n        [10, 1004, 3, 2],\n        [10, 1005, 2, 3],\n        [10, 1006, -3, 2],\n        [10, 1007, -2, -3],\n        [10, 1008, 0, -4],\n        [10, 1009, -4, 0],\n        [10, 1010, 4, 1],\n        [10, 1011, 4, 0],\n        [11, 2024, -4, -1],\n        [11, 2025, 0, 4],\n        [11, 2026, 4, -1],\n        [11, 2027, -1, -4],\n        [11, 2028, 1, 4],\n        [11, 2029, -1, 4],\n        [11, 2030, -4, 1],\n        [11, 2031, 1, -4],\n        [11, 2032, 3, -3],\n        [11, 2033, -3, -3],\n        [11, 2034, -3, 3],\n        [11, 2035, -2, 4],\n        [11, 2036, -4, -2],\n        [11, 2037, 4, 2],\n        [11, 2038, 2, -4],\n        [11, 2039, 2, 4],\n        [11, 2040, 3, 3],\n        [11, 2041, -4, 2],\n        [12, 4084, -2, -4],\n        [12, 4085, 4, -2],\n        [12, 4086, 3, -4],\n        [12, 4087, -4, -3],\n        [12, 4088, -4, 3],\n        [12, 4089, 3, 4],\n        [12, 4090, -3, 4],\n        [12, 4091, 4, 3],\n        [12, 4092, 4, -3],\n        [12, 4093, -3, -4],\n        [13, 8188, 4, -4],\n        [13, 8189, -4, 4],\n        [13, 8190, 4, 4],\n        [13, 8191, -4, -4]\n    ];\n    \n    const HCB6 = [\n        [4, 0, 0, 0],\n        [4, 1, 1, 0],\n        [4, 2, 0, -1],\n        [4, 3, 0, 1],\n        [4, 4, -1, 0],\n        [4, 5, 1, 1],\n        [4, 6, -1, 1],\n        [4, 7, 1, -1],\n        [4, 8, -1, -1],\n        [6, 36, 2, -1],\n        [6, 37, 2, 1],\n        [6, 38, -2, 1],\n        [6, 39, -2, -1],\n        [6, 40, -2, 0],\n        [6, 41, -1, 2],\n        [6, 42, 2, 0],\n        [6, 43, 1, -2],\n        [6, 44, 1, 2],\n        [6, 45, 0, -2],\n        [6, 46, -1, -2],\n        [6, 47, 0, 2],\n        [6, 48, 2, -2],\n        [6, 49, -2, 2],\n        [6, 50, -2, -2],\n        [6, 51, 2, 2],\n        [7, 104, -3, 1],\n        [7, 105, 3, 1],\n        [7, 106, 3, -1],\n        [7, 107, -1, 3],\n        [7, 108, -3, -1],\n        [7, 109, 1, 3],\n        [7, 110, 1, -3],\n        [7, 111, -1, -3],\n        [7, 112, 3, 0],\n        [7, 113, -3, 0],\n        [7, 114, 0, -3],\n        [7, 115, 0, 3],\n        [7, 116, 3, 2],\n        [8, 234, -3, -2],\n        [8, 235, -2, 3],\n        [8, 236, 2, 3],\n        [8, 237, 3, -2],\n        [8, 238, 2, -3],\n        [8, 239, -2, -3],\n        [8, 240, -3, 2],\n        [8, 241, 3, 3],\n        [9, 484, 3, -3],\n        [9, 485, -3, -3],\n        [9, 486, -3, 3],\n        [9, 487, 1, -4],\n        [9, 488, -1, -4],\n        [9, 489, 4, 1],\n        [9, 490, -4, 1],\n        [9, 491, -4, -1],\n        [9, 492, 1, 4],\n        [9, 493, 4, -1],\n        [9, 494, -1, 4],\n        [9, 495, 0, -4],\n        [9, 496, -4, 2],\n        [9, 497, -4, -2],\n        [9, 498, 2, 4],\n        [9, 499, -2, -4],\n        [9, 500, -4, 0],\n        [9, 501, 4, 2],\n        [9, 502, 4, -2],\n        [9, 503, -2, 4],\n        [9, 504, 4, 0],\n        [9, 505, 2, -4],\n        [9, 506, 0, 4],\n        [10, 1014, -3, -4],\n        [10, 1015, -3, 4],\n        [10, 1016, 3, -4],\n        [10, 1017, 4, -3],\n        [10, 1018, 3, 4],\n        [10, 1019, 4, 3],\n        [10, 1020, -4, 3],\n        [10, 1021, -4, -3],\n        [11, 2044, 4, 4],\n        [11, 2045, -4, 4],\n        [11, 2046, -4, -4],\n        [11, 2047, 4, -4]\n    ];\n    \n    const HCB7 = [\n        [1, 0, 0, 0],\n        [3, 4, 1, 0],\n        [3, 5, 0, 1],\n        [4, 12, 1, 1],\n        [6, 52, 2, 1],\n        [6, 53, 1, 2],\n        [6, 54, 2, 0],\n        [6, 55, 0, 2],\n        [7, 112, 3, 1],\n        [7, 113, 1, 3],\n        [7, 114, 2, 2],\n        [7, 115, 3, 0],\n        [7, 116, 0, 3],\n        [8, 234, 2, 3],\n        [8, 235, 3, 2],\n        [8, 236, 1, 4],\n        [8, 237, 4, 1],\n        [8, 238, 1, 5],\n        [8, 239, 5, 1],\n        [8, 240, 3, 3],\n        [8, 241, 2, 4],\n        [8, 242, 0, 4],\n        [8, 243, 4, 0],\n        [9, 488, 4, 2],\n        [9, 489, 2, 5],\n        [9, 490, 5, 2],\n        [9, 491, 0, 5],\n        [9, 492, 6, 1],\n        [9, 493, 5, 0],\n        [9, 494, 1, 6],\n        [9, 495, 4, 3],\n        [9, 496, 3, 5],\n        [9, 497, 3, 4],\n        [9, 498, 5, 3],\n        [9, 499, 2, 6],\n        [9, 500, 6, 2],\n        [9, 501, 1, 7],\n        [10, 1004, 3, 6],\n        [10, 1005, 0, 6],\n        [10, 1006, 6, 0],\n        [10, 1007, 4, 4],\n        [10, 1008, 7, 1],\n        [10, 1009, 4, 5],\n        [10, 1010, 7, 2],\n        [10, 1011, 5, 4],\n        [10, 1012, 6, 3],\n        [10, 1013, 2, 7],\n        [10, 1014, 7, 3],\n        [10, 1015, 6, 4],\n        [10, 1016, 5, 5],\n        [10, 1017, 4, 6],\n        [10, 1018, 3, 7],\n        [11, 2038, 7, 0],\n        [11, 2039, 0, 7],\n        [11, 2040, 6, 5],\n        [11, 2041, 5, 6],\n        [11, 2042, 7, 4],\n        [11, 2043, 4, 7],\n        [11, 2044, 5, 7],\n        [11, 2045, 7, 5],\n        [12, 4092, 7, 6],\n        [12, 4093, 6, 6],\n        [12, 4094, 6, 7],\n        [12, 4095, 7, 7]\n    ];\n    \n    const HCB8 = [\n        [3, 0, 1, 1],\n        [4, 2, 2, 1],\n        [4, 3, 1, 0],\n        [4, 4, 1, 2],\n        [4, 5, 0, 1],\n        [4, 6, 2, 2],\n        [5, 14, 0, 0],\n        [5, 15, 2, 0],\n        [5, 16, 0, 2],\n        [5, 17, 3, 1],\n        [5, 18, 1, 3],\n        [5, 19, 3, 2],\n        [5, 20, 2, 3],\n        [6, 42, 3, 3],\n        [6, 43, 4, 1],\n        [6, 44, 1, 4],\n        [6, 45, 4, 2],\n        [6, 46, 2, 4],\n        [6, 47, 3, 0],\n        [6, 48, 0, 3],\n        [6, 49, 4, 3],\n        [6, 50, 3, 4],\n        [6, 51, 5, 2],\n        [7, 104, 5, 1],\n        [7, 105, 2, 5],\n        [7, 106, 1, 5],\n        [7, 107, 5, 3],\n        [7, 108, 3, 5],\n        [7, 109, 4, 4],\n        [7, 110, 5, 4],\n        [7, 111, 0, 4],\n        [7, 112, 4, 5],\n        [7, 113, 4, 0],\n        [7, 114, 2, 6],\n        [7, 115, 6, 2],\n        [7, 116, 6, 1],\n        [7, 117, 1, 6],\n        [8, 236, 3, 6],\n        [8, 237, 6, 3],\n        [8, 238, 5, 5],\n        [8, 239, 5, 0],\n        [8, 240, 6, 4],\n        [8, 241, 0, 5],\n        [8, 242, 4, 6],\n        [8, 243, 7, 1],\n        [8, 244, 7, 2],\n        [8, 245, 2, 7],\n        [8, 246, 6, 5],\n        [8, 247, 7, 3],\n        [8, 248, 1, 7],\n        [8, 249, 5, 6],\n        [8, 250, 3, 7],\n        [9, 502, 6, 6],\n        [9, 503, 7, 4],\n        [9, 504, 6, 0],\n        [9, 505, 4, 7],\n        [9, 506, 0, 6],\n        [9, 507, 7, 5],\n        [9, 508, 7, 6],\n        [9, 509, 6, 7],\n        [10, 1020, 5, 7],\n        [10, 1021, 7, 0],\n        [10, 1022, 0, 7],\n        [10, 1023, 7, 7]\n    ];\n    \n    const HCB9 = [\n        [1, 0, 0, 0],\n        [3, 4, 1, 0],\n        [3, 5, 0, 1],\n        [4, 12, 1, 1],\n        [6, 52, 2, 1],\n        [6, 53, 1, 2],\n        [6, 54, 2, 0],\n        [6, 55, 0, 2],\n        [7, 112, 3, 1],\n        [7, 113, 2, 2],\n        [7, 114, 1, 3],\n        [8, 230, 3, 0],\n        [8, 231, 0, 3],\n        [8, 232, 2, 3],\n        [8, 233, 3, 2],\n        [8, 234, 1, 4],\n        [8, 235, 4, 1],\n        [8, 236, 2, 4],\n        [8, 237, 1, 5],\n        [9, 476, 4, 2],\n        [9, 477, 3, 3],\n        [9, 478, 0, 4],\n        [9, 479, 4, 0],\n        [9, 480, 5, 1],\n        [9, 481, 2, 5],\n        [9, 482, 1, 6],\n        [9, 483, 3, 4],\n        [9, 484, 5, 2],\n        [9, 485, 6, 1],\n        [9, 486, 4, 3],\n        [10, 974, 0, 5],\n        [10, 975, 2, 6],\n        [10, 976, 5, 0],\n        [10, 977, 1, 7],\n        [10, 978, 3, 5],\n        [10, 979, 1, 8],\n        [10, 980, 8, 1],\n        [10, 981, 4, 4],\n        [10, 982, 5, 3],\n        [10, 983, 6, 2],\n        [10, 984, 7, 1],\n        [10, 985, 0, 6],\n        [10, 986, 8, 2],\n        [10, 987, 2, 8],\n        [10, 988, 3, 6],\n        [10, 989, 2, 7],\n        [10, 990, 4, 5],\n        [10, 991, 9, 1],\n        [10, 992, 1, 9],\n        [10, 993, 7, 2],\n        [11, 1988, 6, 0],\n        [11, 1989, 5, 4],\n        [11, 1990, 6, 3],\n        [11, 1991, 8, 3],\n        [11, 1992, 0, 7],\n        [11, 1993, 9, 2],\n        [11, 1994, 3, 8],\n        [11, 1995, 4, 6],\n        [11, 1996, 3, 7],\n        [11, 1997, 0, 8],\n        [11, 1998, 10, 1],\n        [11, 1999, 6, 4],\n        [11, 2000, 2, 9],\n        [11, 2001, 5, 5],\n        [11, 2002, 8, 0],\n        [11, 2003, 7, 0],\n        [11, 2004, 7, 3],\n        [11, 2005, 10, 2],\n        [11, 2006, 9, 3],\n        [11, 2007, 8, 4],\n        [11, 2008, 1, 10],\n        [11, 2009, 7, 4],\n        [11, 2010, 6, 5],\n        [11, 2011, 5, 6],\n        [11, 2012, 4, 8],\n        [11, 2013, 4, 7],\n        [11, 2014, 3, 9],\n        [11, 2015, 11, 1],\n        [11, 2016, 5, 8],\n        [11, 2017, 9, 0],\n        [11, 2018, 8, 5],\n        [12, 4038, 10, 3],\n        [12, 4039, 2, 10],\n        [12, 4040, 0, 9],\n        [12, 4041, 11, 2],\n        [12, 4042, 9, 4],\n        [12, 4043, 6, 6],\n        [12, 4044, 12, 1],\n        [12, 4045, 4, 9],\n        [12, 4046, 8, 6],\n        [12, 4047, 1, 11],\n        [12, 4048, 9, 5],\n        [12, 4049, 10, 4],\n        [12, 4050, 5, 7],\n        [12, 4051, 7, 5],\n        [12, 4052, 2, 11],\n        [12, 4053, 1, 12],\n        [12, 4054, 12, 2],\n        [12, 4055, 11, 3],\n        [12, 4056, 3, 10],\n        [12, 4057, 5, 9],\n        [12, 4058, 6, 7],\n        [12, 4059, 8, 7],\n        [12, 4060, 11, 4],\n        [12, 4061, 0, 10],\n        [12, 4062, 7, 6],\n        [12, 4063, 12, 3],\n        [12, 4064, 10, 0],\n        [12, 4065, 10, 5],\n        [12, 4066, 4, 10],\n        [12, 4067, 6, 8],\n        [12, 4068, 2, 12],\n        [12, 4069, 9, 6],\n        [12, 4070, 9, 7],\n        [12, 4071, 4, 11],\n        [12, 4072, 11, 0],\n        [12, 4073, 6, 9],\n        [12, 4074, 3, 11],\n        [12, 4075, 5, 10],\n        [13, 8152, 8, 8],\n        [13, 8153, 7, 8],\n        [13, 8154, 12, 5],\n        [13, 8155, 3, 12],\n        [13, 8156, 11, 5],\n        [13, 8157, 7, 7],\n        [13, 8158, 12, 4],\n        [13, 8159, 11, 6],\n        [13, 8160, 10, 6],\n        [13, 8161, 4, 12],\n        [13, 8162, 7, 9],\n        [13, 8163, 5, 11],\n        [13, 8164, 0, 11],\n        [13, 8165, 12, 6],\n        [13, 8166, 6, 10],\n        [13, 8167, 12, 0],\n        [13, 8168, 10, 7],\n        [13, 8169, 5, 12],\n        [13, 8170, 7, 10],\n        [13, 8171, 9, 8],\n        [13, 8172, 0, 12],\n        [13, 8173, 11, 7],\n        [13, 8174, 8, 9],\n        [13, 8175, 9, 9],\n        [13, 8176, 10, 8],\n        [13, 8177, 7, 11],\n        [13, 8178, 12, 7],\n        [13, 8179, 6, 11],\n        [13, 8180, 8, 11],\n        [13, 8181, 11, 8],\n        [13, 8182, 7, 12],\n        [13, 8183, 6, 12],\n        [14, 16368, 8, 10],\n        [14, 16369, 10, 9],\n        [14, 16370, 8, 12],\n        [14, 16371, 9, 10],\n        [14, 16372, 9, 11],\n        [14, 16373, 9, 12],\n        [14, 16374, 10, 11],\n        [14, 16375, 12, 9],\n        [14, 16376, 10, 10],\n        [14, 16377, 11, 9],\n        [14, 16378, 12, 8],\n        [14, 16379, 11, 10],\n        [14, 16380, 12, 10],\n        [14, 16381, 12, 11],\n        [15, 32764, 10, 12],\n        [15, 32765, 11, 11],\n        [15, 32766, 11, 12],\n        [15, 32767, 12, 12]\n    ];\n    \n    const HCB10 = [\n        [4, 0, 1, 1],\n        [4, 1, 1, 2],\n        [4, 2, 2, 1],\n        [5, 6, 2, 2],\n        [5, 7, 1, 0],\n        [5, 8, 0, 1],\n        [5, 9, 1, 3],\n        [5, 10, 3, 2],\n        [5, 11, 3, 1],\n        [5, 12, 2, 3],\n        [5, 13, 3, 3],\n        [6, 28, 2, 0],\n        [6, 29, 0, 2],\n        [6, 30, 2, 4],\n        [6, 31, 4, 2],\n        [6, 32, 1, 4],\n        [6, 33, 4, 1],\n        [6, 34, 0, 0],\n        [6, 35, 4, 3],\n        [6, 36, 3, 4],\n        [6, 37, 3, 0],\n        [6, 38, 0, 3],\n        [6, 39, 4, 4],\n        [6, 40, 2, 5],\n        [6, 41, 5, 2],\n        [7, 84, 1, 5],\n        [7, 85, 5, 1],\n        [7, 86, 5, 3],\n        [7, 87, 3, 5],\n        [7, 88, 5, 4],\n        [7, 89, 4, 5],\n        [7, 90, 6, 2],\n        [7, 91, 2, 6],\n        [7, 92, 6, 3],\n        [7, 93, 4, 0],\n        [7, 94, 6, 1],\n        [7, 95, 0, 4],\n        [7, 96, 1, 6],\n        [7, 97, 3, 6],\n        [7, 98, 5, 5],\n        [7, 99, 6, 4],\n        [7, 100, 4, 6],\n        [8, 202, 6, 5],\n        [8, 203, 7, 2],\n        [8, 204, 3, 7],\n        [8, 205, 2, 7],\n        [8, 206, 5, 6],\n        [8, 207, 8, 2],\n        [8, 208, 7, 3],\n        [8, 209, 5, 0],\n        [8, 210, 7, 1],\n        [8, 211, 0, 5],\n        [8, 212, 8, 1],\n        [8, 213, 1, 7],\n        [8, 214, 8, 3],\n        [8, 215, 7, 4],\n        [8, 216, 4, 7],\n        [8, 217, 2, 8],\n        [8, 218, 6, 6],\n        [8, 219, 7, 5],\n        [8, 220, 1, 8],\n        [8, 221, 3, 8],\n        [8, 222, 8, 4],\n        [8, 223, 4, 8],\n        [8, 224, 5, 7],\n        [8, 225, 8, 5],\n        [8, 226, 5, 8],\n        [9, 454, 7, 6],\n        [9, 455, 6, 7],\n        [9, 456, 9, 2],\n        [9, 457, 6, 0],\n        [9, 458, 6, 8],\n        [9, 459, 9, 3],\n        [9, 460, 3, 9],\n        [9, 461, 9, 1],\n        [9, 462, 2, 9],\n        [9, 463, 0, 6],\n        [9, 464, 8, 6],\n        [9, 465, 9, 4],\n        [9, 466, 4, 9],\n        [9, 467, 10, 2],\n        [9, 468, 1, 9],\n        [9, 469, 7, 7],\n        [9, 470, 8, 7],\n        [9, 471, 9, 5],\n        [9, 472, 7, 8],\n        [9, 473, 10, 3],\n        [9, 474, 5, 9],\n        [9, 475, 10, 4],\n        [9, 476, 2, 10],\n        [9, 477, 10, 1],\n        [9, 478, 3, 10],\n        [9, 479, 9, 6],\n        [9, 480, 6, 9],\n        [9, 481, 8, 0],\n        [9, 482, 4, 10],\n        [9, 483, 7, 0],\n        [9, 484, 11, 2],\n        [10, 970, 7, 9],\n        [10, 971, 11, 3],\n        [10, 972, 10, 6],\n        [10, 973, 1, 10],\n        [10, 974, 11, 1],\n        [10, 975, 9, 7],\n        [10, 976, 0, 7],\n        [10, 977, 8, 8],\n        [10, 978, 10, 5],\n        [10, 979, 3, 11],\n        [10, 980, 5, 10],\n        [10, 981, 8, 9],\n        [10, 982, 11, 5],\n        [10, 983, 0, 8],\n        [10, 984, 11, 4],\n        [10, 985, 2, 11],\n        [10, 986, 7, 10],\n        [10, 987, 6, 10],\n        [10, 988, 10, 7],\n        [10, 989, 4, 11],\n        [10, 990, 1, 11],\n        [10, 991, 12, 2],\n        [10, 992, 9, 8],\n        [10, 993, 12, 3],\n        [10, 994, 11, 6],\n        [10, 995, 5, 11],\n        [10, 996, 12, 4],\n        [10, 997, 11, 7],\n        [10, 998, 12, 5],\n        [10, 999, 3, 12],\n        [10, 1000, 6, 11],\n        [10, 1001, 9, 0],\n        [10, 1002, 10, 8],\n        [10, 1003, 10, 0],\n        [10, 1004, 12, 1],\n        [10, 1005, 0, 9],\n        [10, 1006, 4, 12],\n        [10, 1007, 9, 9],\n        [10, 1008, 12, 6],\n        [10, 1009, 2, 12],\n        [10, 1010, 8, 10],\n        [11, 2022, 9, 10],\n        [11, 2023, 1, 12],\n        [11, 2024, 11, 8],\n        [11, 2025, 12, 7],\n        [11, 2026, 7, 11],\n        [11, 2027, 5, 12],\n        [11, 2028, 6, 12],\n        [11, 2029, 10, 9],\n        [11, 2030, 8, 11],\n        [11, 2031, 12, 8],\n        [11, 2032, 0, 10],\n        [11, 2033, 7, 12],\n        [11, 2034, 11, 0],\n        [11, 2035, 10, 10],\n        [11, 2036, 11, 9],\n        [11, 2037, 11, 10],\n        [11, 2038, 0, 11],\n        [11, 2039, 11, 11],\n        [11, 2040, 9, 11],\n        [11, 2041, 10, 11],\n        [11, 2042, 12, 0],\n        [11, 2043, 8, 12],\n        [12, 4088, 12, 9],\n        [12, 4089, 10, 12],\n        [12, 4090, 9, 12],\n        [12, 4091, 11, 12],\n        [12, 4092, 12, 11],\n        [12, 4093, 0, 12],\n        [12, 4094, 12, 10],\n        [12, 4095, 12, 12]\n    ];\n    \n    const HCB11 = [\n        [4, 0, 0, 0],\n        [4, 1, 1, 1],\n        [5, 4, 16, 16],\n        [5, 5, 1, 0],\n        [5, 6, 0, 1],\n        [5, 7, 2, 1],\n        [5, 8, 1, 2],\n        [5, 9, 2, 2],\n        [6, 20, 1, 3],\n        [6, 21, 3, 1],\n        [6, 22, 3, 2],\n        [6, 23, 2, 0],\n        [6, 24, 2, 3],\n        [6, 25, 0, 2],\n        [6, 26, 3, 3],\n        [7, 54, 4, 1],\n        [7, 55, 1, 4],\n        [7, 56, 4, 2],\n        [7, 57, 2, 4],\n        [7, 58, 4, 3],\n        [7, 59, 3, 4],\n        [7, 60, 3, 0],\n        [7, 61, 0, 3],\n        [7, 62, 5, 1],\n        [7, 63, 5, 2],\n        [7, 64, 2, 5],\n        [7, 65, 4, 4],\n        [7, 66, 1, 5],\n        [7, 67, 5, 3],\n        [7, 68, 3, 5],\n        [7, 69, 5, 4],\n        [8, 140, 4, 5],\n        [8, 141, 6, 2],\n        [8, 142, 2, 6],\n        [8, 143, 6, 1],\n        [8, 144, 6, 3],\n        [8, 145, 3, 6],\n        [8, 146, 1, 6],\n        [8, 147, 4, 16],\n        [8, 148, 3, 16],\n        [8, 149, 16, 5],\n        [8, 150, 16, 3],\n        [8, 151, 16, 4],\n        [8, 152, 6, 4],\n        [8, 153, 16, 6],\n        [8, 154, 4, 0],\n        [8, 155, 4, 6],\n        [8, 156, 0, 4],\n        [8, 157, 2, 16],\n        [8, 158, 5, 5],\n        [8, 159, 5, 16],\n        [8, 160, 16, 7],\n        [8, 161, 16, 2],\n        [8, 162, 16, 8],\n        [8, 163, 2, 7],\n        [8, 164, 7, 2],\n        [8, 165, 3, 7],\n        [8, 166, 6, 5],\n        [8, 167, 5, 6],\n        [8, 168, 6, 16],\n        [8, 169, 16, 10],\n        [8, 170, 7, 3],\n        [8, 171, 7, 1],\n        [8, 172, 16, 9],\n        [8, 173, 7, 16],\n        [8, 174, 1, 16],\n        [8, 175, 1, 7],\n        [8, 176, 4, 7],\n        [8, 177, 16, 11],\n        [8, 178, 7, 4],\n        [8, 179, 16, 12],\n        [8, 180, 8, 16],\n        [8, 181, 16, 1],\n        [8, 182, 6, 6],\n        [8, 183, 9, 16],\n        [8, 184, 2, 8],\n        [8, 185, 5, 7],\n        [8, 186, 10, 16],\n        [8, 187, 16, 13],\n        [8, 188, 8, 3],\n        [8, 189, 8, 2],\n        [8, 190, 3, 8],\n        [8, 191, 5, 0],\n        [8, 192, 16, 14],\n        [8, 193, 11, 16],\n        [8, 194, 7, 5],\n        [8, 195, 4, 8],\n        [8, 196, 6, 7],\n        [8, 197, 7, 6],\n        [8, 198, 0, 5],\n        [9, 398, 8, 4],\n        [9, 399, 16, 15],\n        [9, 400, 12, 16],\n        [9, 401, 1, 8],\n        [9, 402, 8, 1],\n        [9, 403, 14, 16],\n        [9, 404, 5, 8],\n        [9, 405, 13, 16],\n        [9, 406, 3, 9],\n        [9, 407, 8, 5],\n        [9, 408, 7, 7],\n        [9, 409, 2, 9],\n        [9, 410, 8, 6],\n        [9, 411, 9, 2],\n        [9, 412, 9, 3],\n        [9, 413, 15, 16],\n        [9, 414, 4, 9],\n        [9, 415, 6, 8],\n        [9, 416, 6, 0],\n        [9, 417, 9, 4],\n        [9, 418, 5, 9],\n        [9, 419, 8, 7],\n        [9, 420, 7, 8],\n        [9, 421, 1, 9],\n        [9, 422, 10, 3],\n        [9, 423, 0, 6],\n        [9, 424, 10, 2],\n        [9, 425, 9, 1],\n        [9, 426, 9, 5],\n        [9, 427, 4, 10],\n        [9, 428, 2, 10],\n        [9, 429, 9, 6],\n        [9, 430, 3, 10],\n        [9, 431, 6, 9],\n        [9, 432, 10, 4],\n        [9, 433, 8, 8],\n        [9, 434, 10, 5],\n        [9, 435, 9, 7],\n        [9, 436, 11, 3],\n        [9, 437, 1, 10],\n        [9, 438, 7, 0],\n        [9, 439, 10, 6],\n        [9, 440, 7, 9],\n        [9, 441, 3, 11],\n        [9, 442, 5, 10],\n        [9, 443, 10, 1],\n        [9, 444, 4, 11],\n        [9, 445, 11, 2],\n        [9, 446, 13, 2],\n        [9, 447, 6, 10],\n        [9, 448, 13, 3],\n        [9, 449, 2, 11],\n        [9, 450, 16, 0],\n        [9, 451, 5, 11],\n        [9, 452, 11, 5],\n        [10, 906, 11, 4],\n        [10, 907, 9, 8],\n        [10, 908, 7, 10],\n        [10, 909, 8, 9],\n        [10, 910, 0, 16],\n        [10, 911, 4, 13],\n        [10, 912, 0, 7],\n        [10, 913, 3, 13],\n        [10, 914, 11, 6],\n        [10, 915, 13, 1],\n        [10, 916, 13, 4],\n        [10, 917, 12, 3],\n        [10, 918, 2, 13],\n        [10, 919, 13, 5],\n        [10, 920, 8, 10],\n        [10, 921, 6, 11],\n        [10, 922, 10, 8],\n        [10, 923, 10, 7],\n        [10, 924, 14, 2],\n        [10, 925, 12, 4],\n        [10, 926, 1, 11],\n        [10, 927, 4, 12],\n        [10, 928, 11, 1],\n        [10, 929, 3, 12],\n        [10, 930, 1, 13],\n        [10, 931, 12, 2],\n        [10, 932, 7, 11],\n        [10, 933, 3, 14],\n        [10, 934, 5, 12],\n        [10, 935, 5, 13],\n        [10, 936, 14, 4],\n        [10, 937, 4, 14],\n        [10, 938, 11, 7],\n        [10, 939, 14, 3],\n        [10, 940, 12, 5],\n        [10, 941, 13, 6],\n        [10, 942, 12, 6],\n        [10, 943, 8, 0],\n        [10, 944, 11, 8],\n        [10, 945, 2, 12],\n        [10, 946, 9, 9],\n        [10, 947, 14, 5],\n        [10, 948, 6, 13],\n        [10, 949, 10, 10],\n        [10, 950, 15, 2],\n        [10, 951, 8, 11],\n        [10, 952, 9, 10],\n        [10, 953, 14, 6],\n        [10, 954, 10, 9],\n        [10, 955, 5, 14],\n        [10, 956, 11, 9],\n        [10, 957, 14, 1],\n        [10, 958, 2, 14],\n        [10, 959, 6, 12],\n        [10, 960, 1, 12],\n        [10, 961, 13, 8],\n        [10, 962, 0, 8],\n        [10, 963, 13, 7],\n        [10, 964, 7, 12],\n        [10, 965, 12, 7],\n        [10, 966, 7, 13],\n        [10, 967, 15, 3],\n        [10, 968, 12, 1],\n        [10, 969, 6, 14],\n        [10, 970, 2, 15],\n        [10, 971, 15, 5],\n        [10, 972, 15, 4],\n        [10, 973, 1, 14],\n        [10, 974, 9, 11],\n        [10, 975, 4, 15],\n        [10, 976, 14, 7],\n        [10, 977, 8, 13],\n        [10, 978, 13, 9],\n        [10, 979, 8, 12],\n        [10, 980, 5, 15],\n        [10, 981, 3, 15],\n        [10, 982, 10, 11],\n        [10, 983, 11, 10],\n        [10, 984, 12, 8],\n        [10, 985, 15, 6],\n        [10, 986, 15, 7],\n        [10, 987, 8, 14],\n        [10, 988, 15, 1],\n        [10, 989, 7, 14],\n        [10, 990, 9, 0],\n        [10, 991, 0, 9],\n        [10, 992, 9, 13],\n        [10, 993, 9, 12],\n        [10, 994, 12, 9],\n        [10, 995, 14, 8],\n        [10, 996, 10, 13],\n        [10, 997, 14, 9],\n        [10, 998, 12, 10],\n        [10, 999, 6, 15],\n        [10, 1000, 7, 15],\n        [11, 2002, 9, 14],\n        [11, 2003, 15, 8],\n        [11, 2004, 11, 11],\n        [11, 2005, 11, 14],\n        [11, 2006, 1, 15],\n        [11, 2007, 10, 12],\n        [11, 2008, 10, 14],\n        [11, 2009, 13, 11],\n        [11, 2010, 13, 10],\n        [11, 2011, 11, 13],\n        [11, 2012, 11, 12],\n        [11, 2013, 8, 15],\n        [11, 2014, 14, 11],\n        [11, 2015, 13, 12],\n        [11, 2016, 12, 13],\n        [11, 2017, 15, 9],\n        [11, 2018, 14, 10],\n        [11, 2019, 10, 0],\n        [11, 2020, 12, 11],\n        [11, 2021, 9, 15],\n        [11, 2022, 0, 10],\n        [11, 2023, 12, 12],\n        [11, 2024, 11, 0],\n        [11, 2025, 12, 14],\n        [11, 2026, 10, 15],\n        [11, 2027, 13, 13],\n        [11, 2028, 0, 13],\n        [11, 2029, 14, 12],\n        [11, 2030, 15, 10],\n        [11, 2031, 15, 11],\n        [11, 2032, 11, 15],\n        [11, 2033, 14, 13],\n        [11, 2034, 13, 0],\n        [11, 2035, 0, 11],\n        [11, 2036, 13, 14],\n        [11, 2037, 15, 12],\n        [11, 2038, 15, 13],\n        [11, 2039, 12, 15],\n        [11, 2040, 14, 0],\n        [11, 2041, 14, 14],\n        [11, 2042, 13, 15],\n        [11, 2043, 12, 0],\n        [11, 2044, 14, 15],\n        [12, 4090, 0, 14],\n        [12, 4091, 0, 12],\n        [12, 4092, 15, 14],\n        [12, 4093, 15, 0],\n        [12, 4094, 0, 15],\n        [12, 4095, 15, 15]\n    ];\n    \n    const HCB_SF = [\n        [1, 0, 60],\n        [3, 4, 59],\n        [4, 10, 61],\n        [4, 11, 58],\n        [4, 12, 62],\n        [5, 26, 57],\n        [5, 27, 63],\n        [6, 56, 56],\n        [6, 57, 64],\n        [6, 58, 55],\n        [6, 59, 65],\n        [7, 120, 66],\n        [7, 121, 54],\n        [7, 122, 67],\n        [8, 246, 53],\n        [8, 247, 68],\n        [8, 248, 52],\n        [8, 249, 69],\n        [8, 250, 51],\n        [9, 502, 70],\n        [9, 503, 50],\n        [9, 504, 49],\n        [9, 505, 71],\n        [10, 1012, 72],\n        [10, 1013, 48],\n        [10, 1014, 73],\n        [10, 1015, 47],\n        [10, 1016, 74],\n        [10, 1017, 46],\n        [11, 2036, 76],\n        [11, 2037, 75],\n        [11, 2038, 77],\n        [11, 2039, 78],\n        [11, 2040, 45],\n        [11, 2041, 43],\n        [12, 4084, 44],\n        [12, 4085, 79],\n        [12, 4086, 42],\n        [12, 4087, 41],\n        [12, 4088, 80],\n        [12, 4089, 40],\n        [13, 8180, 81],\n        [13, 8181, 39],\n        [13, 8182, 82],\n        [13, 8183, 38],\n        [13, 8184, 83],\n        [14, 16370, 37],\n        [14, 16371, 35],\n        [14, 16372, 85],\n        [14, 16373, 33],\n        [14, 16374, 36],\n        [14, 16375, 34],\n        [14, 16376, 84],\n        [14, 16377, 32],\n        [15, 32756, 87],\n        [15, 32757, 89],\n        [15, 32758, 30],\n        [15, 32759, 31],\n        [16, 65520, 86],\n        [16, 65521, 29],\n        [16, 65522, 26],\n        [16, 65523, 27],\n        [16, 65524, 28],\n        [16, 65525, 24],\n        [16, 65526, 88],\n        [17, 131054, 25],\n        [17, 131055, 22],\n        [17, 131056, 23],\n        [18, 262114, 90],\n        [18, 262115, 21],\n        [18, 262116, 19],\n        [18, 262117, 3],\n        [18, 262118, 1],\n        [18, 262119, 2],\n        [18, 262120, 0],\n        [19, 524242, 98],\n        [19, 524243, 99],\n        [19, 524244, 100],\n        [19, 524245, 101],\n        [19, 524246, 102],\n        [19, 524247, 117],\n        [19, 524248, 97],\n        [19, 524249, 91],\n        [19, 524250, 92],\n        [19, 524251, 93],\n        [19, 524252, 94],\n        [19, 524253, 95],\n        [19, 524254, 96],\n        [19, 524255, 104],\n        [19, 524256, 111],\n        [19, 524257, 112],\n        [19, 524258, 113],\n        [19, 524259, 114],\n        [19, 524260, 115],\n        [19, 524261, 116],\n        [19, 524262, 110],\n        [19, 524263, 105],\n        [19, 524264, 106],\n        [19, 524265, 107],\n        [19, 524266, 108],\n        [19, 524267, 109],\n        [19, 524268, 118],\n        [19, 524269, 6],\n        [19, 524270, 8],\n        [19, 524271, 9],\n        [19, 524272, 10],\n        [19, 524273, 5],\n        [19, 524274, 103],\n        [19, 524275, 120],\n        [19, 524276, 119],\n        [19, 524277, 4],\n        [19, 524278, 7],\n        [19, 524279, 15],\n        [19, 524280, 16],\n        [19, 524281, 18],\n        [19, 524282, 20],\n        [19, 524283, 17],\n        [19, 524284, 11],\n        [19, 524285, 12],\n        [19, 524286, 14],\n        [19, 524287, 13]\n    ];\n    \n    const CODEBOOKS = [HCB1, HCB2, HCB3, HCB4, HCB5, HCB6, HCB7, HCB8, HCB9, HCB10, HCB11];\n    const UNSIGNED = [false, false, true, true, false, false, true, true, true, true, true],\n          QUAD_LEN = 4, \n          PAIR_LEN = 2;\n    \n    var Huffman = {\n        findOffset: function(stream, table) {\n            var off = 0,\n                len = table[off][0],\n                cw = stream.read(len);\n                \n            while (cw !== table[off][1]) {\n                var j = table[++off][0] - len;\n                len = table[off][0];\n                cw <<= j;\n                cw |= stream.read(j);\n            }\n            \n            return off;\n        },\n        \n        signValues: function(stream, data, off, len) {\n            for (var i = off; i < off + len; i++) {\n                if (data[i] && stream.read(1))\n                    data[i] = -data[i];\n            }\n        },\n        \n        getEscape: function(stream, s) {\n            var i = 4;\n            while (stream.read(1))\n                i++;\n                \n            var j = stream.read(i) | (1 << i);\n            return s < 0 ? -j : j;\n        },\n        \n        decodeScaleFactor: function(stream) {\n            var offset = this.findOffset(stream, HCB_SF);\n            return HCB_SF[offset][2];\n        },\n        \n        decodeSpectralData: function(stream, cb, data, off) {\n            var HCB = CODEBOOKS[cb - 1],\n                offset = this.findOffset(stream, HCB);\n                \n            data[off] = HCB[offset][2];\n            data[off + 1] = HCB[offset][3];\n            \n            if (cb < 5) {\n                data[off + 2] = HCB[offset][4];\n                data[off + 3] = HCB[offset][5];\n            }\n            \n            // sign and escape\n            if (cb < 11) {\n                if (UNSIGNED[cb - 1])\n                    this.signValues(stream, data, off, cb < 5 ? QUAD_LEN : PAIR_LEN);\n                    \n            } else if (cb === 11 || cb > 15) {\n                this.signValues(stream, data, off, cb < 5 ? QUAD_LEN : PAIR_LEN);\n                \n                if (Math.abs(data[off]) === 16) \n                    data[off] = this.getEscape(stream, data[off]);\n                    \n                if (Math.abs(data[off + 1]) === 16)\n                    data[off + 1] = this.getEscape(stream, data[off + 1]);\n            } else {\n                throw new Error(\"Huffman: unknown spectral codebook: \" + cb);\n            }\n        }\n    };\n    \n    return Huffman;\n    \n})();//import \"huffman.js\"\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar TNS = (function() {\n    \n    // Temporal Noise Shaping\n    function TNS(config) {\n        this.maxBands = TNS_MAX_BANDS_1024[config.sampleIndex]\n        this.nFilt = new Int32Array(8);\n        this.length = new Array(8);\n        this.direction = new Array(8);\n        this.order = new Array(8);\n        this.coef = new Array(8);\n        \n        // Probably could allocate these as needed\n        for (var w = 0; w < 8; w++) {\n            this.length[w] = new Int32Array(4);\n            this.direction[w] = new Array(4);\n            this.order[w] = new Int32Array(4);\n            this.coef[w] = new Array(4);\n            \n            for (var filt = 0; filt < 4; filt++) {\n                this.coef[w][filt] = new Float32Array(TNS_MAX_ORDER);\n            }\n        }\n        \n        this.lpc = new Float32Array(TNS_MAX_ORDER);\n        this.tmp = new Float32Array(TNS_MAX_ORDER);\n    }\n\n    const TNS_MAX_ORDER = 20,\n          SHORT_BITS = [1, 4, 3],\n          LONG_BITS = [2, 6, 5];\n          \n    const TNS_COEF_1_3 = [0.00000000, -0.43388373, 0.64278758, 0.34202015],\n\n          TNS_COEF_0_3 = [0.00000000, -0.43388373, -0.78183150, -0.97492790,\n                          0.98480773, 0.86602539, 0.64278758, 0.34202015],\n                          \n          TNS_COEF_1_4 = [0.00000000, -0.20791170, -0.40673664, -0.58778524,\n                          0.67369562, 0.52643216, 0.36124167, 0.18374951],\n                          \n          TNS_COEF_0_4 = [0.00000000, -0.20791170, -0.40673664, -0.58778524,\n                          -0.74314481, -0.86602539, -0.95105654, -0.99452192,\n                          0.99573416, 0.96182561, 0.89516330, 0.79801720,\n                          0.67369562, 0.52643216, 0.36124167, 0.18374951],\n                          \n          TNS_TABLES = [TNS_COEF_0_3, TNS_COEF_0_4, TNS_COEF_1_3, TNS_COEF_1_4];\n          \n    const TNS_MAX_BANDS_1024 = [31, 31, 34, 40, 42, 51, 46, 46, 42, 42, 42, 39, 39],\n          TNS_MAX_BANDS_128 = [9, 9, 10, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14];\n    \n    TNS.prototype.decode = function(stream, info) {\n        var windowCount = info.windowCount,\n            bits = info.windowSequence === ICStream.EIGHT_SHORT_SEQUENCE ? SHORT_BITS : LONG_BITS;\n        \n        for (var w = 0; w < windowCount; w++) {\n            if (this.nFilt[w] = stream.read(bits[0])) {\n                var coefRes = stream.read(1),\n                    nFilt_w = this.nFilt[w],\n                    length_w = this.length[w],\n                    order_w = this.order[w],\n                    direction_w = this.direction[w],\n                    coef_w = this.coef[w];\n                \n                for (var filt = 0; filt < nFilt_w; filt++) {\n                    length_w[filt] = stream.read(bits[1]);\n                    \n                    if ((order_w[filt] = stream.read(bits[2])) > 20)\n                        throw new Error(\"TNS filter out of range: \" + order_w[filt]);\n                    \n                    if (order_w[filt]) {\n                        direction_w[filt] = !!stream.read(1);\n                        var coefCompress = stream.read(1),\n                            coefLen = coefRes + 3 - coefCompress,\n                            tmp = 2 * coefCompress + coefRes,\n                            table = TNS_TABLES[tmp],\n                            order_w_filt = order_w[filt],\n                            coef_w_filt = coef_w[filt];\n                            \n                        for (var i = 0; i < order_w_filt; i++)\n                            coef_w_filt[i] = table[stream.read(coefLen)];\n                    }\n                        \n                }\n            }\n        }\n    };\n    \n    TNS.prototype.process = function(ics, data, decode) {\n        var mmm = Math.min(this.maxBands, ics.maxSFB),\n            lpc = this.lpc,\n            tmp = this.tmp,\n            info = ics.info,\n            windowCount = info.windowCount;\n            \n        for (var w = 0; w < windowCount; w++) {\n            var bottom = info.swbCount,\n                nFilt_w = this.nFilt[w],\n                length_w = this.length[w],\n                order_w = this.order[w],\n                coef_w = this.coef[w],\n                direction_w = this.direction[w];\n            \n            for (var filt = 0; filt < nFilt_w; filt++) {\n                var top = bottom,\n                    bottom = Math.max(0, tmp - length_w[filt]),\n                    order = order_w[filt];\n                    \n                if (order === 0) continue;\n                \n                // calculate lpc coefficients\n                var autoc = coef_w[filt];\n                for (var i = 0; i < order; i++) {\n                    var r = -autoc[i];\n                    lpc[i] = r;\n    \n                    for (var j = 0, len = (i + 1) >> 1; j < len; j++) {\n                        var f = lpc[j],\n                            b = lpc[i - 1 - j];\n    \n                        lpc[j] = f + r * b;\n                        lpc[i - 1 - j] = b + r * f;\n                    }\n                }\n                \n                var start = info.swbOffsets[Math.min(bottom, mmm)],\n                    end = info.swbOffsets[Math.min(top, mmm)],\n                    size,\n                    inc = 1;\n                    \n                if ((size = end - start) <= 0) continue;\n                \n                if (direction_w[filt]) {\n                    inc = -1;\n                    start = end - 1;\n                }\n                \n                start += w * 128;\n                \n                if (decode) {\n                    // ar filter\n                    for (var m = 0; m < size; m++, start += inc) {\n                        for (var i = 1; i <= Math.min(m, order); i++) {\n                            data[start] -= data[start - i * inc] * lpc[i - 1];\n                        }\n                    }\n                } else {\n                    // ma filter\n                    for (var m = 0; m < size; m++, start += inc) {\n                        tmp[0] = data[start];\n                        \n                        for (var i = 1; i <= Math.min(m, order); i++)\n                            data[start] += tmp[i] * lpc[i - 1];\n                        \n                        for (var i = order; i > 0; i--)\n                            tmp[i] = tmp[i - 1];\n                    }\n                }\n            }\n        }\n    };\n    \n    return TNS;\n\n})();//import \"tns.js\"\n\nvar ICStream = (function() {\n    \n    // Individual Channel Stream\n    function ICStream(config) {\n        this.info = new ICSInfo();\n        this.bandTypes = new Int32Array(MAX_SECTIONS);\n        this.sectEnd = new Int32Array(MAX_SECTIONS);\n        this.data = new Float32Array(config.frameLength);\n        this.scaleFactors = new Float32Array(MAX_SECTIONS);\n        this.randomState = 0x1F2E3D4C;\n        this.tns = new TNS(config);\n        this.specBuf = new Int32Array(4);\n    }\n          \n    ICStream.ZERO_BT = 0;         // Scalefactors and spectral data are all zero.\n    ICStream.FIRST_PAIR_BT = 5;   // This and later band types encode two values (rather than four) with one code word.\n    ICStream.ESC_BT = 11;         // Spectral data are coded with an escape sequence.\n    ICStream.NOISE_BT = 13;       // Spectral data are scaled white noise not coded in the bitstream.\n    ICStream.INTENSITY_BT2 = 14;  // Scalefactor data are intensity stereo positions.\n    ICStream.INTENSITY_BT = 15;   // Scalefactor data are intensity stereo positions.\n    \n    ICStream.ONLY_LONG_SEQUENCE = 0;\n    ICStream.LONG_START_SEQUENCE = 1;\n    ICStream.EIGHT_SHORT_SEQUENCE = 2;\n    ICStream.LONG_STOP_SEQUENCE = 3;\n    \n    const MAX_SECTIONS = 120,\n          MAX_WINDOW_GROUP_COUNT = 8;\n    \n    const SF_DELTA = 60,\n          SF_OFFSET = 200;\n    \n    ICStream.prototype = {\n        decode: function(stream, config, commonWindow) {\n            this.globalGain = stream.read(8);\n            \n            if (!commonWindow)\n                this.info.decode(stream, config, commonWindow);\n                \n            this.decodeBandTypes(stream, config);\n            this.decodeScaleFactors(stream);\n            \n            if (this.pulsePresent = stream.read(1)) {\n                if (this.info.windowSequence === ICStream.EIGHT_SHORT_SEQUENCE)\n                    throw new Error(\"Pulse tool not allowed in eight short sequence.\");\n                    \n                this.decodePulseData(stream);\n            }\n            \n            if (this.tnsPresent = stream.read(1)) {\n                this.tns.decode(stream, this.info);\n            }\n            \n            if (this.gainPresent = stream.read(1)) {\n                throw new Error(\"TODO: decode gain control/SSR\");\n            }\n            \n            this.decodeSpectralData(stream);\n        },\n        \n        decodeBandTypes: function(stream, config) {\n            var bits = this.info.windowSequence === ICStream.EIGHT_SHORT_SEQUENCE ? 3 : 5,\n                groupCount = this.info.groupCount,\n                maxSFB = this.info.maxSFB,\n                bandTypes = this.bandTypes,\n                sectEnd = this.sectEnd,\n                idx = 0,\n                escape = (1 << bits) - 1;\n            \n            for (var g = 0; g < groupCount; g++) {\n                var k = 0;\n                while (k < maxSFB) {\n                    var end = k,\n                        bandType = stream.read(4);\n                        \n                    if (bandType === 12)\n                        throw new Error(\"Invalid band type: 12\");\n                        \n                    var incr;\n                    while ((incr = stream.read(bits)) === escape)\n                        end += incr;\n                        \n                    end += incr;\n                    \n                    if (end > maxSFB)\n                        throw new Error(\"Too many bands (\" + end + \" > \" + maxSFB + \")\");\n                        \n                    for (; k < end; k++) {\n                        bandTypes[idx] = bandType;\n                        sectEnd[idx++] = end;\n                    }\n                }\n            }\n        },\n        \n        decodeScaleFactors: function(stream) {\n            var groupCount = this.info.groupCount,\n                maxSFB = this.info.maxSFB,\n                offset = [this.globalGain, this.globalGain - 90, 0], // spectrum, noise, intensity\n                idx = 0,\n                noiseFlag = true,\n                scaleFactors = this.scaleFactors,\n                sectEnd = this.sectEnd,\n                bandTypes = this.bandTypes;\n                            \n            for (var g = 0; g < groupCount; g++) {\n                for (var i = 0; i < maxSFB;) {\n                    var runEnd = sectEnd[idx];\n                    \n                    switch (bandTypes[idx]) {\n                        case ICStream.ZERO_BT:\n                            for (; i < runEnd; i++, idx++) {\n                                scaleFactors[idx] = 0;\n                            }\n                            break;\n                            \n                        case ICStream.INTENSITY_BT:\n                        case ICStream.INTENSITY_BT2:\n                            for(; i < runEnd; i++, idx++) {\n                                offset[2] += Huffman.decodeScaleFactor(stream) - SF_DELTA;\n                                var tmp = Math.min(Math.max(offset[2], -155), 100);\n                                scaleFactors[idx] = SCALEFACTOR_TABLE[-tmp + SF_OFFSET];\n                            }\n                            break;\n                            \n                        case ICStream.NOISE_BT:\n                            for(; i < runEnd; i++, idx++) {\n                                if (noiseFlag) {\n                                    offset[1] += stream.read(9) - 256;\n                                    noiseFlag = false;\n                                } else {\n                                    offset[1] += Huffman.decodeScaleFactor(stream) - SF_DELTA;\n                                }\n                                var tmp = Math.min(Math.max(offset[1], -100), 155);\n                                scaleFactors[idx] = -SCALEFACTOR_TABLE[tmp + SF_OFFSET];\n                            }\n                            break;\n                            \n                        default:\n                            for(; i < runEnd; i++, idx++) {\n                                offset[0] += Huffman.decodeScaleFactor(stream) - SF_DELTA;\n                                if(offset[0] > 255) \n                                    throw new Error(\"Scalefactor out of range: \" + offset[0]);\n                                    \n                                scaleFactors[idx] = SCALEFACTOR_TABLE[offset[0] - 100 + SF_OFFSET];\n                            }\n                            break;\n                    }\n                }\n            }\n        },\n        \n        decodePulseData: function(stream) {\n            var pulseCount = stream.read(2) + 1,\n                pulseSWB = stream.read(6);\n                \n            if (pulseSWB >= this.info.swbCount)\n                throw new Error(\"Pulse SWB out of range: \" + pulseSWB);\n                \n            if (!this.pulseOffset || this.pulseOffset.length !== pulseCount) {\n                // only reallocate if needed\n                this.pulseOffset = new Int32Array(pulseCount);\n                this.pulseAmp = new Int32Array(pulseCount);\n            }\n            \n            this.pulseOffset[0] = this.info.swbOffsets[pulseSWB] + stream.read(5);\n            this.pulseAmp[0] = stream.read(4);\n            \n            if (this.pulseOffset[0] > 1023)\n                throw new Error(\"Pulse offset out of range: \" + this.pulseOffset[0]);\n            \n            for (var i = 1; i < pulseCount; i++) {\n                this.pulseOffset[i] = stream.read(5) + this.pulseOffset[i - 1];\n                if (this.pulseOffset[i] > 1023)\n                    throw new Error(\"Pulse offset out of range: \" + this.pulseOffset[i]);\n                    \n                this.pulseAmp[i] = stream.read(4);\n            }\n        },\n        \n        decodeSpectralData: function(stream) {\n            var data = this.data,\n                info = this.info,\n                maxSFB = info.maxSFB,\n                windowGroups = info.groupCount,\n                offsets = info.swbOffsets,\n                bandTypes = this.bandTypes,\n                scaleFactors = this.scaleFactors,\n                buf = this.specBuf;\n                \n            var groupOff = 0, idx = 0;\n            for (var g = 0; g < windowGroups; g++) {\n                var groupLen = info.groupLength[g];\n                \n                for (var sfb = 0; sfb < maxSFB; sfb++, idx++) {\n                    var hcb = bandTypes[idx],\n                        off = groupOff + offsets[sfb],\n                        width = offsets[sfb + 1] - offsets[sfb];\n                        \n                    if (hcb === ICStream.ZERO_BT || hcb === ICStream.INTENSITY_BT || hcb === ICStream.INTENSITY_BT2) {\n                        for (var group = 0; group < groupLen; group++, off += 128) {\n                            for (var i = off; i < off + width; i++) {\n                                data[i] = 0;\n                            }\n                        }\n                    } else if (hcb === ICStream.NOISE_BT) {\n                        // fill with random values\n                        for (var group = 0; group < groupLen; group++, off += 128) {\n                            var energy = 0;\n                            \n                            for (var k = 0; k < width; k++) {\n                                this.randomState *= 1664525 + 1013904223;\n                                data[off + k] = this.randomState;\n                                energy += data[off + k] * data[off + k];\n                            }\n                            \n                            var scale = scaleFactors[idx] / Math.sqrt(energy);\n                            for (var k = 0; k < width; k++) {\n                                data[off + k] *= scale;\n                            }\n                        }\n                    } else {\n                        for (var group = 0; group < groupLen; group++, off += 128) {\n                            var num = (hcb >= ICStream.FIRST_PAIR_BT) ? 2 : 4;\n                            for (var k = 0; k < width; k += num) {\n                                Huffman.decodeSpectralData(stream, hcb, buf, 0);\n                                \n                                // inverse quantization & scaling\n                                for (var j = 0; j < num; j++) {\n                                    data[off + k + j] = (buf[j] > 0) ? IQ_TABLE[buf[j]] : -IQ_TABLE[-buf[j]];\n                                    data[off + k + j] *= scaleFactors[idx];\n                                }\n                            }\n                        }\n                    }\n                }\n                groupOff += groupLen << 7;\n            }\n            \n            // add pulse data, if present\n            if (this.pulsePresent) {\n                throw new Error('TODO: add pulse data');\n            }\n        }\n    }\n    \n    // Individual Channel Stream Info\n    function ICSInfo() {\n        this.windowShape = new Int32Array(2);\n        this.windowSequence = ICStream.ONLY_LONG_SEQUENCE;\n        this.groupLength = new Int32Array(MAX_WINDOW_GROUP_COUNT);\n        this.ltpData1Present = false;\n        this.ltpData2Present = false;\n    }\n    \n    ICSInfo.prototype = {\n        decode: function(stream, config, commonWindow) {\n            stream.advance(1); // reserved\n            \n            this.windowSequence = stream.read(2);\n            this.windowShape[0] = this.windowShape[1];\n            this.windowShape[1] = stream.read(1);\n            \n            this.groupCount = 1;\n            this.groupLength[0] = 1;\n            \n            if (this.windowSequence === ICStream.EIGHT_SHORT_SEQUENCE) {\n                this.maxSFB = stream.read(4);\n                for (var i = 0; i < 7; i++) {\n                    if (stream.read(1)) {\n                        this.groupLength[this.groupCount - 1]++;\n                    } else {\n                        this.groupCount++;\n                        this.groupLength[this.groupCount - 1] = 1;\n                    }\n                }\n                \n                this.windowCount = 8;\n                this.swbOffsets = SWB_OFFSET_128[config.sampleIndex];\n                this.swbCount = SWB_SHORT_WINDOW_COUNT[config.sampleIndex];\n                this.predictorPresent = false;\n            } else {\n                this.maxSFB = stream.read(6);\n                this.windowCount = 1;\n                this.swbOffsets = SWB_OFFSET_1024[config.sampleIndex];\n                this.swbCount = SWB_LONG_WINDOW_COUNT[config.sampleIndex];\n                this.predictorPresent = !!stream.read(1);\n                \n                if (this.predictorPresent)\n                    this.decodePrediction(stream, config, commonWindow);\n            }\n        },\n        \n        decodePrediction: function(stream, config, commonWindow) {\n            throw new Error('Prediction not implemented.');\n            \n            switch (config.profile) {\n                case AOT_AAC_MAIN:\n                    throw new Error('Prediction not implemented.');\n                    break;\n                    \n                case AOT_AAC_LTP:\n                    throw new Error('LTP prediction not implemented.');\n                    break;\n                    \n                default:\n                    throw new Error('Unsupported profile for prediction ' + config.profile);\n            }\n        }\n    };\n    \n    return ICStream;\n    \n})();//import \"ics.js\"\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n//import \"ics.js\"\n\nvar CPEElement = (function() {\n    \n    // Channel Pair Element\n    function CPEElement(config) {\n        this.ms_used = [];\n        this.left = new ICStream(config);\n        this.right = new ICStream(config);\n    }\n    \n    const MAX_MS_MASK = 128;\n    \n    const MASK_TYPE_ALL_0 = 0,\n          MASK_TYPE_USED = 1,\n          MASK_TYPE_ALL_1 = 2,\n          MASK_TYPE_RESERVED = 3;\n    \n    CPEElement.prototype.decode = function(stream, config) {\n        var left = this.left,\n            right = this.right,\n            ms_used = this.ms_used;\n            \n        if (this.commonWindow = !!stream.read(1)) {\n            left.info.decode(stream, config, true);\n            right.info = left.info;\n    \n            var mask = stream.read(2);\n            this.maskPresent = !!mask;\n            \n            switch (mask) {\n                case MASK_TYPE_USED:\n                    var len = left.info.groupCount * left.info.maxSFB;\n                    for (var i = 0; i < len; i++) {\n                        ms_used[i] = !!stream.read(1);\n                    }\n                    break;\n                \n                case MASK_TYPE_ALL_0:    \n                case MASK_TYPE_ALL_1:\n                    var val = !!mask;\n                    for (var i = 0; i < MAX_MS_MASK; i++) {\n                        ms_used[i] = val;\n                    }\n                    break;\n                    \n                default:\n                    throw new Error(\"Reserved ms mask type: \" + mask);\n            }\n        } else {\n            for (var i = 0; i < MAX_MS_MASK; i++)\n                ms_used[i] = false;\n        }\n        \n        left.decode(stream, config, this.commonWindow);\n        right.decode(stream, config, this.commonWindow);\n    };\n    \n    return CPEElement;\n    \n})();//import \"cpe.js\"\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar CCEElement = (function() {\n    \n    // Channel Coupling Element\n    function CCEElement(config) {\n        this.ics = new ICStream(config);\n        this.channelPair = new Array(8);\n        this.idSelect = new Int32Array(8);\n        this.chSelect = new Int32Array(8);\n        this.gain = new Array(16);\n    }\n    \n    CCEElement.BEFORE_TNS = 0;\n    CCEElement.AFTER_TNS = 1;\n    CCEElement.AFTER_IMDCT = 2;\n    \n    const CCE_SCALE = new Float32Array([\n        1.09050773266525765921,\n        1.18920711500272106672,\n        1.4142135623730950488016887,\n        2.0\n    ]);\n    \n    CCEElement.prototype = {\n        decode: function(stream, config) {\n            var channelPair = this.channelPair,\n                idSelect = this.idSelect,\n                chSelect = this.chSelect;\n    \n            this.couplingPoint = 2 * stream.read(1);\n            this.coupledCount = stream.read(3);\n    \n            var gainCount = 0;\n            for (var i = 0; i <= this.coupledCount; i++) {\n                gainCount++;\n                channelPair[i] = stream.read(1);\n                idSelect[i] = stream.read(4);\n    \n                if (channelPair[i]) {\n                    chSelect[i] = stream.read(2);\n                    if (chSelect[i] === 3)\n                        gainCount++;\n    \n                } else {\n                    chSelect[i] = 2;\n                }\n            }\n    \n            this.couplingPoint += stream.read(1) || (this.couplingPoint >>> 1);\n    \n            var sign = stream.read(1),\n                scale = CCE_SCALE[stream.read(2)];\n    \n            this.ics.decode(stream, config, false);\n    \n            var groupCount = this.ics.info.groupCount,\n                maxSFB = this.ics.info.maxSFB,\n                bandTypes = this.ics.bandTypes;\n    \n            for (var i = 0; i < gainCount; i++) {\n                var idx = 0,\n                    cge = 1,\n                    gain = 0,\n                    gainCache = 1;\n    \n                if (i > 0) {\n                    cge = this.couplingPoint === CCEElement.AFTER_IMDCT ? 1 : stream.read(1);\n                    gain = cge ? Huffman.decodeScaleFactor(stream) - 60 : 0;\n                    gainCache = Math.pow(scale, -gain);\n                }\n    \n                var gain_i = this.gain[i] = new Float32Array(120);\n    \n                if (this.couplingPoint === CCEElement.AFTER_IMDCT) {\n                    gain_i[0] = gainCache;\n                } else {\n                    for (var g = 0; g < groupCount; g++) {\n                        for (var sfb = 0; sfb < maxSFB; sfb++) {\n                            if (bandTypes[idx] !== ICStream.ZERO_BT) {\n                                if (cge === 0) {\n                                    var t = Huffman.decodeScaleFactor(stream) - 60;\n                                    if (t !== 0) {\n                                        var s = 1;\n                                        t = gain += t;\n                                        if (sign) {\n                                            s -= 2 * (t * 0x1);\n                                            t >>>= 1;\n                                        }\n                                        gainCache = Math.pow(scale, -t) * s;\n                                    }\n                                }\n                                gain_i[idx++] = gainCache;\n                            }\n                        }\n                    }\n                }\n            }\n        },\n    \n        applyIndependentCoupling: function(index, data) {\n            var gain = this.gain[index][0],\n                iqData = this.ics.data;\n    \n            for (var i = 0; i < data.length; i++) {\n                data[i] += gain * iqData[i];\n            }\n        },\n    \n        applyDependentCoupling: function(index, data) {\n            var info = this.ics.info,\n                swbOffsets = info.swbOffsets,\n                groupCount = info.groupCount,\n                maxSFB = info.maxSFB,\n                bandTypes = this.ics.bandTypes,\n                iqData = this.ics.data;\n    \n            var idx = 0,\n                offset = 0,\n                gains = this.gain[index];\n    \n            for (var g = 0; g < groupCount; g++) {\n                var len = info.groupLength[g];\n    \n                for (var sfb = 0; sfb < maxSFB; sfb++, idx++) {\n                    if (bandTypes[idx] !== ICStream.ZERO_BT) {\n                        var gain = gains[idx];\n                        for (var group = 0; group < len; group++) {\n                            for (var k = swbOffsets[sfb]; k < swbOffsets[swb + 1]; k++) {\n                                data[offset + group * 128 + k] += gain * iqData[offset + group * 128 + k];\n                            }\n                        }\n                    }\n                }\n    \n                offset += len * 128;\n            }\n        }\n    };\n    \n    return CCEElement;\n    \n})();//import \"cce.js\"\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst MDCT_TABLE_2048 = [\n    [0.031249997702054, 0.000011984224612],\n    [0.031249813866531, 0.000107857810004],\n    [0.031249335895858, 0.000203730380198],\n    [0.031248563794535, 0.000299601032804],\n    [0.031247497569829, 0.000395468865451],\n    [0.031246137231775, 0.000491332975794],\n    [0.031244482793177, 0.000587192461525],\n    [0.031242534269608, 0.000683046420376],\n    [0.031240291679407, 0.000778893950134],\n    [0.031237755043684, 0.000874734148645],\n    [0.031234924386313, 0.000970566113826],\n    [0.031231799733938, 0.001066388943669],\n    [0.031228381115970, 0.001162201736253],\n    [0.031224668564585, 0.001258003589751],\n    [0.031220662114728, 0.001353793602441],\n    [0.031216361804108, 0.001449570872710],\n    [0.031211767673203, 0.001545334499065],\n    [0.031206879765253, 0.001641083580144],\n    [0.031201698126266, 0.001736817214719],\n    [0.031196222805014, 0.001832534501709],\n    [0.031190453853031, 0.001928234540186],\n    [0.031184391324617, 0.002023916429386],\n    [0.031178035276836, 0.002119579268713],\n    [0.031171385769513, 0.002215222157753],\n    [0.031164442865236, 0.002310844196278],\n    [0.031157206629353, 0.002406444484258],\n    [0.031149677129975, 0.002502022121865],\n    [0.031141854437973, 0.002597576209488],\n    [0.031133738626977, 0.002693105847734],\n    [0.031125329773375, 0.002788610137442],\n    [0.031116627956316, 0.002884088179689],\n    [0.031107633257703, 0.002979539075801],\n    [0.031098345762200, 0.003074961927355],\n    [0.031088765557222, 0.003170355836197],\n    [0.031078892732942, 0.003265719904442],\n    [0.031068727382288, 0.003361053234488],\n    [0.031058269600939, 0.003456354929021],\n    [0.031047519487329, 0.003551624091024],\n    [0.031036477142640, 0.003646859823790],\n    [0.031025142670809, 0.003742061230921],\n    [0.031013516178519, 0.003837227416347],\n    [0.031001597775203, 0.003932357484328],\n    [0.030989387573042, 0.004027450539462],\n    [0.030976885686963, 0.004122505686697],\n    [0.030964092234638, 0.004217522031340],\n    [0.030951007336485, 0.004312498679058],\n    [0.030937631115663, 0.004407434735897],\n    [0.030923963698074, 0.004502329308281],\n    [0.030910005212362, 0.004597181503027],\n    [0.030895755789908, 0.004691990427350],\n    [0.030881215564835, 0.004786755188872],\n    [0.030866384674000, 0.004881474895632],\n    [0.030851263256996, 0.004976148656090],\n    [0.030835851456154, 0.005070775579142],\n    [0.030820149416533, 0.005165354774124],\n    [0.030804157285929, 0.005259885350819],\n    [0.030787875214864, 0.005354366419469],\n    [0.030771303356593, 0.005448797090784],\n    [0.030754441867095, 0.005543176475946],\n    [0.030737290905077, 0.005637503686619],\n    [0.030719850631972, 0.005731777834961],\n    [0.030702121211932, 0.005825998033626],\n    [0.030684102811835, 0.005920163395780],\n    [0.030665795601276, 0.006014273035101],\n    [0.030647199752570, 0.006108326065793],\n    [0.030628315440748, 0.006202321602594],\n    [0.030609142843557, 0.006296258760782],\n    [0.030589682141455, 0.006390136656185],\n    [0.030569933517616, 0.006483954405188],\n    [0.030549897157919, 0.006577711124743],\n    [0.030529573250956, 0.006671405932375],\n    [0.030508961988022, 0.006765037946194],\n    [0.030488063563118, 0.006858606284900],\n    [0.030466878172949, 0.006952110067791],\n    [0.030445406016919, 0.007045548414774],\n    [0.030423647297133, 0.007138920446372],\n    [0.030401602218392, 0.007232225283733],\n    [0.030379270988192, 0.007325462048634],\n    [0.030356653816724, 0.007418629863497],\n    [0.030333750916869, 0.007511727851390],\n    [0.030310562504198, 0.007604755136040],\n    [0.030287088796968, 0.007697710841838],\n    [0.030263330016124, 0.007790594093851],\n    [0.030239286385293, 0.007883404017824],\n    [0.030214958130781, 0.007976139740197],\n    [0.030190345481576, 0.008068800388104],\n    [0.030165448669342, 0.008161385089390],\n    [0.030140267928416, 0.008253892972610],\n    [0.030114803495809, 0.008346323167047],\n    [0.030089055611203, 0.008438674802711],\n    [0.030063024516947, 0.008530947010354],\n    [0.030036710458054, 0.008623138921475],\n    [0.030010113682202, 0.008715249668328],\n    [0.029983234439732, 0.008807278383932],\n    [0.029956072983640, 0.008899224202078],\n    [0.029928629569580, 0.008991086257336],\n    [0.029900904455860, 0.009082863685067],\n    [0.029872897903441, 0.009174555621425],\n    [0.029844610175929, 0.009266161203371],\n    [0.029816041539579, 0.009357679568679],\n    [0.029787192263292, 0.009449109855944],\n    [0.029758062618606, 0.009540451204587],\n    [0.029728652879702, 0.009631702754871],\n    [0.029698963323395, 0.009722863647900],\n    [0.029668994229134, 0.009813933025633],\n    [0.029638745879000, 0.009904910030891],\n    [0.029608218557702, 0.009995793807363],\n    [0.029577412552575, 0.010086583499618],\n    [0.029546328153577, 0.010177278253107],\n    [0.029514965653285, 0.010267877214177],\n    [0.029483325346896, 0.010358379530076],\n    [0.029451407532220, 0.010448784348962],\n    [0.029419212509679, 0.010539090819911],\n    [0.029386740582307, 0.010629298092923],\n    [0.029353992055740, 0.010719405318933],\n    [0.029320967238220, 0.010809411649818],\n    [0.029287666440590, 0.010899316238403],\n    [0.029254089976290, 0.010989118238474],\n    [0.029220238161353, 0.011078816804778],\n    [0.029186111314406, 0.011168411093039],\n    [0.029151709756664, 0.011257900259961],\n    [0.029117033811927, 0.011347283463239],\n    [0.029082083806579, 0.011436559861563],\n    [0.029046860069582, 0.011525728614630],\n    [0.029011362932476, 0.011614788883150],\n    [0.028975592729373, 0.011703739828853],\n    [0.028939549796957, 0.011792580614500],\n    [0.028903234474475, 0.011881310403886],\n    [0.028866647103744, 0.011969928361855],\n    [0.028829788029135, 0.012058433654299],\n    [0.028792657597583, 0.012146825448172],\n    [0.028755256158571, 0.012235102911499],\n    [0.028717584064137, 0.012323265213377],\n    [0.028679641668864, 0.012411311523990],\n    [0.028641429329882, 0.012499241014612],\n    [0.028602947406859, 0.012587052857618],\n    [0.028564196262001, 0.012674746226488],\n    [0.028525176260050, 0.012762320295819],\n    [0.028485887768276, 0.012849774241331],\n    [0.028446331156478, 0.012937107239875],\n    [0.028406506796976, 0.013024318469437],\n    [0.028366415064615, 0.013111407109155],\n    [0.028326056336751, 0.013198372339315],\n    [0.028285430993258, 0.013285213341368],\n    [0.028244539416515, 0.013371929297933],\n    [0.028203381991411, 0.013458519392807],\n    [0.028161959105334, 0.013544982810971],\n    [0.028120271148172, 0.013631318738598],\n    [0.028078318512309, 0.013717526363062],\n    [0.028036101592619, 0.013803604872943],\n    [0.027993620786463, 0.013889553458039],\n    [0.027950876493687, 0.013975371309367],\n    [0.027907869116616, 0.014061057619178],\n    [0.027864599060052, 0.014146611580959],\n    [0.027821066731270, 0.014232032389445],\n    [0.027777272540012, 0.014317319240622],\n    [0.027733216898487, 0.014402471331737],\n    [0.027688900221361, 0.014487487861307],\n    [0.027644322925762, 0.014572368029123],\n    [0.027599485431266, 0.014657111036262],\n    [0.027554388159903, 0.014741716085090],\n    [0.027509031536144, 0.014826182379271],\n    [0.027463415986904, 0.014910509123778],\n    [0.027417541941533, 0.014994695524894],\n    [0.027371409831816, 0.015078740790225],\n    [0.027325020091965, 0.015162644128704],\n    [0.027278373158618, 0.015246404750603],\n    [0.027231469470833, 0.015330021867534],\n    [0.027184309470088, 0.015413494692460],\n    [0.027136893600268, 0.015496822439704],\n    [0.027089222307671, 0.015580004324954],\n    [0.027041296040997, 0.015663039565269],\n    [0.026993115251345, 0.015745927379091],\n    [0.026944680392213, 0.015828666986247],\n    [0.026895991919487, 0.015911257607961],\n    [0.026847050291442, 0.015993698466859],\n    [0.026797855968734, 0.016075988786976],\n    [0.026748409414401, 0.016158127793763],\n    [0.026698711093851, 0.016240114714099],\n    [0.026648761474864, 0.016321948776289],\n    [0.026598561027585, 0.016403629210082],\n    [0.026548110224519, 0.016485155246669],\n    [0.026497409540530, 0.016566526118696],\n    [0.026446459452830, 0.016647741060271],\n    [0.026395260440982, 0.016728799306966],\n    [0.026343812986890, 0.016809700095831],\n    [0.026292117574797, 0.016890442665397],\n    [0.026240174691280, 0.016971026255683],\n    [0.026187984825246, 0.017051450108208],\n    [0.026135548467924, 0.017131713465990],\n    [0.026082866112867, 0.017211815573560],\n    [0.026029938255941, 0.017291755676967],\n    [0.025976765395322, 0.017371533023784],\n    [0.025923348031494, 0.017451146863116],\n    [0.025869686667242, 0.017530596445607],\n    [0.025815781807646, 0.017609881023449],\n    [0.025761633960080, 0.017688999850383],\n    [0.025707243634204, 0.017767952181715],\n    [0.025652611341960, 0.017846737274313],\n    [0.025597737597568, 0.017925354386623],\n    [0.025542622917522, 0.018003802778671],\n    [0.025487267820581, 0.018082081712071],\n    [0.025431672827768, 0.018160190450031],\n    [0.025375838462365, 0.018238128257362],\n    [0.025319765249906, 0.018315894400484],\n    [0.025263453718173, 0.018393488147432],\n    [0.025206904397193, 0.018470908767865],\n    [0.025150117819228, 0.018548155533070],\n    [0.025093094518776, 0.018625227715971],\n    [0.025035835032562, 0.018702124591135],\n    [0.024978339899534, 0.018778845434780],\n    [0.024920609660858, 0.018855389524780],\n    [0.024862644859912, 0.018931756140672],\n    [0.024804446042284, 0.019007944563666],\n    [0.024746013755764, 0.019083954076646],\n    [0.024687348550337, 0.019159783964183],\n    [0.024628450978184, 0.019235433512536],\n    [0.024569321593670, 0.019310902009663],\n    [0.024509960953345, 0.019386188745225],\n    [0.024450369615932, 0.019461293010596],\n    [0.024390548142329, 0.019536214098866],\n    [0.024330497095598, 0.019610951304848],\n    [0.024270217040961, 0.019685503925087],\n    [0.024209708545799, 0.019759871257867],\n    [0.024148972179639, 0.019834052603212],\n    [0.024088008514157, 0.019908047262901],\n    [0.024026818123164, 0.019981854540467],\n    [0.023965401582609, 0.020055473741208],\n    [0.023903759470567, 0.020128904172192],\n    [0.023841892367236, 0.020202145142264],\n    [0.023779800854935, 0.020275195962052],\n    [0.023717485518092, 0.020348055943974],\n    [0.023654946943242, 0.020420724402244],\n    [0.023592185719023, 0.020493200652878],\n    [0.023529202436167, 0.020565484013703],\n    [0.023465997687496, 0.020637573804361],\n    [0.023402572067918, 0.020709469346314],\n    [0.023338926174419, 0.020781169962854],\n    [0.023275060606058, 0.020852674979108],\n    [0.023210975963963, 0.020923983722044],\n    [0.023146672851322, 0.020995095520475],\n    [0.023082151873380, 0.021066009705072],\n    [0.023017413637435, 0.021136725608363],\n    [0.022952458752826, 0.021207242564742],\n    [0.022887287830934, 0.021277559910478],\n    [0.022821901485173, 0.021347676983716],\n    [0.022756300330983, 0.021417593124488],\n    [0.022690484985827, 0.021487307674717],\n    [0.022624456069185, 0.021556819978223],\n    [0.022558214202547, 0.021626129380729],\n    [0.022491760009405, 0.021695235229869],\n    [0.022425094115252, 0.021764136875192],\n    [0.022358217147572, 0.021832833668171],\n    [0.022291129735838, 0.021901324962204],\n    [0.022223832511501, 0.021969610112625],\n    [0.022156326107988, 0.022037688476709],\n    [0.022088611160696, 0.022105559413676],\n    [0.022020688306983, 0.022173222284699],\n    [0.021952558186166, 0.022240676452909],\n    [0.021884221439510, 0.022307921283403],\n    [0.021815678710228, 0.022374956143245],\n    [0.021746930643469, 0.022441780401478],\n    [0.021677977886316, 0.022508393429127],\n    [0.021608821087780, 0.022574794599206],\n    [0.021539460898790, 0.022640983286719],\n    [0.021469897972190, 0.022706958868676],\n    [0.021400132962735, 0.022772720724087],\n    [0.021330166527077, 0.022838268233979],\n    [0.021259999323769, 0.022903600781391],\n    [0.021189632013250, 0.022968717751391],\n    [0.021119065257845, 0.023033618531071],\n    [0.021048299721754, 0.023098302509561],\n    [0.020977336071050, 0.023162769078031],\n    [0.020906174973670, 0.023227017629698],\n    [0.020834817099409, 0.023291047559828],\n    [0.020763263119915, 0.023354858265748],\n    [0.020691513708680, 0.023418449146848],\n    [0.020619569541038, 0.023481819604585],\n    [0.020547431294155, 0.023544969042494],\n    [0.020475099647023, 0.023607896866186],\n    [0.020402575280455, 0.023670602483363],\n    [0.020329858877078, 0.023733085303813],\n    [0.020256951121327, 0.023795344739427],\n    [0.020183852699437, 0.023857380204193],\n    [0.020110564299439, 0.023919191114211],\n    [0.020037086611150, 0.023980776887692],\n    [0.019963420326171, 0.024042136944968],\n    [0.019889566137877, 0.024103270708495],\n    [0.019815524741412, 0.024164177602859],\n    [0.019741296833681, 0.024224857054779],\n    [0.019666883113346, 0.024285308493120],\n    [0.019592284280817, 0.024345531348888],\n    [0.019517501038246, 0.024405525055242],\n    [0.019442534089523, 0.024465289047500],\n    [0.019367384140264, 0.024524822763141],\n    [0.019292051897809, 0.024584125641809],\n    [0.019216538071215, 0.024643197125323],\n    [0.019140843371246, 0.024702036657681],\n    [0.019064968510369, 0.024760643685063],\n    [0.018988914202748, 0.024819017655836],\n    [0.018912681164234, 0.024877158020562],\n    [0.018836270112363, 0.024935064232003],\n    [0.018759681766343, 0.024992735745123],\n    [0.018682916847054, 0.025050172017095],\n    [0.018605976077037, 0.025107372507308],\n    [0.018528860180486, 0.025164336677369],\n    [0.018451569883247, 0.025221063991110],\n    [0.018374105912805, 0.025277553914591],\n    [0.018296468998280, 0.025333805916107],\n    [0.018218659870421, 0.025389819466194],\n    [0.018140679261596, 0.025445594037630],\n    [0.018062527905790, 0.025501129105445],\n    [0.017984206538592, 0.025556424146920],\n    [0.017905715897192, 0.025611478641598],\n    [0.017827056720375, 0.025666292071285],\n    [0.017748229748511, 0.025720863920056],\n    [0.017669235723550, 0.025775193674260],\n    [0.017590075389012, 0.025829280822525],\n    [0.017510749489986, 0.025883124855762],\n    [0.017431258773116, 0.025936725267170],\n    [0.017351603986600, 0.025990081552242],\n    [0.017271785880180, 0.026043193208768],\n    [0.017191805205132, 0.026096059736841],\n    [0.017111662714267, 0.026148680638861],\n    [0.017031359161915, 0.026201055419541],\n    [0.016950895303924, 0.026253183585908],\n    [0.016870271897651, 0.026305064647313],\n    [0.016789489701954, 0.026356698115431],\n    [0.016708549477186, 0.026408083504269],\n    [0.016627451985187, 0.026459220330167],\n    [0.016546197989277, 0.026510108111806],\n    [0.016464788254250, 0.026560746370212],\n    [0.016383223546365, 0.026611134628757],\n    [0.016301504633341, 0.026661272413168],\n    [0.016219632284346, 0.026711159251530],\n    [0.016137607269996, 0.026760794674288],\n    [0.016055430362340, 0.026810178214254],\n    [0.015973102334858, 0.026859309406613],\n    [0.015890623962454, 0.026908187788922],\n    [0.015807996021446, 0.026956812901119],\n    [0.015725219289558, 0.027005184285527],\n    [0.015642294545918, 0.027053301486856],\n    [0.015559222571044, 0.027101164052208],\n    [0.015476004146842, 0.027148771531083],\n    [0.015392640056594, 0.027196123475380],\n    [0.015309131084956, 0.027243219439406],\n    [0.015225478017946, 0.027290058979875],\n    [0.015141681642938, 0.027336641655915],\n    [0.015057742748656, 0.027382967029073],\n    [0.014973662125164, 0.027429034663317],\n    [0.014889440563862, 0.027474844125040],\n    [0.014805078857474, 0.027520394983066],\n    [0.014720577800046, 0.027565686808654],\n    [0.014635938186934, 0.027610719175499],\n    [0.014551160814797, 0.027655491659740],\n    [0.014466246481592, 0.027700003839960],\n    [0.014381195986567, 0.027744255297195],\n    [0.014296010130247, 0.027788245614933],\n    [0.014210689714436, 0.027831974379120],\n    [0.014125235542201, 0.027875441178165],\n    [0.014039648417870, 0.027918645602941],\n    [0.013953929147020, 0.027961587246792],\n    [0.013868078536476, 0.028004265705534],\n    [0.013782097394294, 0.028046680577462],\n    [0.013695986529763, 0.028088831463351],\n    [0.013609746753390, 0.028130717966461],\n    [0.013523378876898, 0.028172339692540],\n    [0.013436883713214, 0.028213696249828],\n    [0.013350262076462, 0.028254787249062],\n    [0.013263514781960, 0.028295612303478],\n    [0.013176642646205, 0.028336171028814],\n    [0.013089646486871, 0.028376463043317],\n    [0.013002527122799, 0.028416487967743],\n    [0.012915285373990, 0.028456245425361],\n    [0.012827922061597, 0.028495735041960],\n    [0.012740438007915, 0.028534956445849],\n    [0.012652834036379, 0.028573909267859],\n    [0.012565110971550, 0.028612593141354],\n    [0.012477269639111, 0.028651007702224],\n    [0.012389310865858, 0.028689152588899],\n    [0.012301235479693, 0.028727027442343],\n    [0.012213044309615, 0.028764631906065],\n    [0.012124738185712, 0.028801965626115],\n    [0.012036317939156, 0.028839028251097],\n    [0.011947784402191, 0.028875819432161],\n    [0.011859138408130, 0.028912338823015],\n    [0.011770380791341, 0.028948586079925],\n    [0.011681512387245, 0.028984560861718],\n    [0.011592534032306, 0.029020262829785],\n    [0.011503446564022, 0.029055691648087],\n    [0.011414250820918, 0.029090846983152],\n    [0.011324947642537, 0.029125728504087],\n    [0.011235537869437, 0.029160335882573],\n    [0.011146022343175, 0.029194668792871],\n    [0.011056401906305, 0.029228726911828],\n    [0.010966677402371, 0.029262509918876],\n    [0.010876849675891, 0.029296017496036],\n    [0.010786919572361, 0.029329249327922],\n    [0.010696887938235, 0.029362205101743],\n    [0.010606755620926, 0.029394884507308],\n    [0.010516523468793, 0.029427287237024],\n    [0.010426192331137, 0.029459412985906],\n    [0.010335763058187, 0.029491261451573],\n    [0.010245236501099, 0.029522832334255],\n    [0.010154613511943, 0.029554125336796],\n    [0.010063894943698, 0.029585140164654],\n    [0.009973081650240, 0.029615876525905],\n    [0.009882174486340, 0.029646334131247],\n    [0.009791174307650, 0.029676512694001],\n    [0.009700081970699, 0.029706411930116],\n    [0.009608898332881, 0.029736031558168],\n    [0.009517624252453, 0.029765371299366],\n    [0.009426260588521, 0.029794430877553],\n    [0.009334808201034, 0.029823210019210],\n    [0.009243267950778, 0.029851708453456],\n    [0.009151640699363, 0.029879925912053],\n    [0.009059927309220, 0.029907862129408],\n    [0.008968128643591, 0.029935516842573],\n    [0.008876245566520, 0.029962889791254],\n    [0.008784278942845, 0.029989980717805],\n    [0.008692229638191, 0.030016789367235],\n    [0.008600098518961, 0.030043315487212],\n    [0.008507886452329, 0.030069558828062],\n    [0.008415594306230, 0.030095519142772],\n    [0.008323222949351, 0.030121196186994],\n    [0.008230773251129, 0.030146589719046],\n    [0.008138246081733, 0.030171699499915],\n    [0.008045642312067, 0.030196525293257],\n    [0.007952962813750, 0.030221066865402],\n    [0.007860208459119, 0.030245323985357],\n    [0.007767380121212, 0.030269296424803],\n    [0.007674478673766, 0.030292983958103],\n    [0.007581504991203, 0.030316386362302],\n    [0.007488459948628, 0.030339503417126],\n    [0.007395344421816, 0.030362334904989],\n    [0.007302159287206, 0.030384880610993],\n    [0.007208905421891, 0.030407140322928],\n    [0.007115583703613, 0.030429113831278],\n    [0.007022195010752, 0.030450800929220],\n    [0.006928740222316, 0.030472201412626],\n    [0.006835220217939, 0.030493315080068],\n    [0.006741635877866, 0.030514141732814],\n    [0.006647988082948, 0.030534681174838],\n    [0.006554277714635, 0.030554933212813],\n    [0.006460505654964, 0.030574897656119],\n    [0.006366672786553, 0.030594574316845],\n    [0.006272779992593, 0.030613963009786],\n    [0.006178828156839, 0.030633063552447],\n    [0.006084818163601, 0.030651875765048],\n    [0.005990750897737, 0.030670399470520],\n    [0.005896627244644, 0.030688634494512],\n    [0.005802448090250, 0.030706580665388],\n    [0.005708214321004, 0.030724237814232],\n    [0.005613926823871, 0.030741605774849],\n    [0.005519586486321, 0.030758684383764],\n    [0.005425194196321, 0.030775473480228],\n    [0.005330750842327, 0.030791972906214],\n    [0.005236257313276, 0.030808182506425],\n    [0.005141714498576, 0.030824102128288],\n    [0.005047123288102, 0.030839731621963],\n    [0.004952484572181, 0.030855070840339],\n    [0.004857799241589, 0.030870119639036],\n    [0.004763068187541, 0.030884877876411],\n    [0.004668292301681, 0.030899345413553],\n    [0.004573472476075, 0.030913522114288],\n    [0.004478609603205, 0.030927407845180],\n    [0.004383704575956, 0.030941002475530],\n    [0.004288758287610, 0.030954305877381],\n    [0.004193771631837, 0.030967317925516],\n    [0.004098745502689, 0.030980038497461],\n    [0.004003680794587, 0.030992467473486],\n    [0.003908578402316, 0.031004604736602],\n    [0.003813439221017, 0.031016450172571],\n    [0.003718264146176, 0.031028003669899],\n    [0.003623054073616, 0.031039265119839],\n    [0.003527809899492, 0.031050234416394],\n    [0.003432532520278, 0.031060911456318],\n    [0.003337222832760, 0.031071296139114],\n    [0.003241881734029, 0.031081388367037],\n    [0.003146510121474, 0.031091188045095],\n    [0.003051108892766, 0.031100695081051],\n    [0.002955678945860, 0.031109909385419],\n    [0.002860221178978, 0.031118830871473],\n    [0.002764736490604, 0.031127459455239],\n    [0.002669225779478, 0.031135795055501],\n    [0.002573689944583, 0.031143837593803],\n    [0.002478129885137, 0.031151586994444],\n    [0.002382546500589, 0.031159043184484],\n    [0.002286940690606, 0.031166206093743],\n    [0.002191313355067, 0.031173075654800],\n    [0.002095665394051, 0.031179651802998],\n    [0.001999997707835, 0.031185934476438],\n    [0.001904311196878, 0.031191923615985],\n    [0.001808606761820, 0.031197619165268],\n    [0.001712885303465, 0.031203021070678],\n    [0.001617147722782, 0.031208129281370],\n    [0.001521394920889, 0.031212943749264],\n    [0.001425627799047, 0.031217464429043],\n    [0.001329847258653, 0.031221691278159],\n    [0.001234054201231, 0.031225624256825],\n    [0.001138249528420, 0.031229263328024],\n    [0.001042434141971, 0.031232608457502],\n    [0.000946608943736, 0.031235659613775],\n    [0.000850774835656, 0.031238416768124],\n    [0.000754932719759, 0.031240879894597],\n    [0.000659083498149, 0.031243048970010],\n    [0.000563228072993, 0.031244923973948],\n    [0.000467367346520, 0.031246504888762],\n    [0.000371502221008, 0.031247791699571],\n    [0.000275633598775, 0.031248784394264],\n    [0.000179762382174, 0.031249482963498],\n    [0.000083889473581, 0.031249887400697]\n];\n\nconst MDCT_TABLE_256 = [\n    [0.088387931675923, 0.000271171628935],\n    [0.088354655998507, 0.002440238387037],\n    [0.088268158780110, 0.004607835236780],\n    [0.088128492123423, 0.006772656498875],\n    [0.087935740158418, 0.008933398165942],\n    [0.087690018991670, 0.011088758687994],\n    [0.087391476636423, 0.013237439756448],\n    [0.087040292923427, 0.015378147086172],\n    [0.086636679392621, 0.017509591195118],\n    [0.086180879165703, 0.019630488181053],\n    [0.085673166799686, 0.021739560494940],\n    [0.085113848121515, 0.023835537710479],\n    [0.084503260043847, 0.025917157289369],\n    [0.083841770362110, 0.027983165341813],\n    [0.083129777532952, 0.030032317381813],\n    [0.082367710434230, 0.032063379076803],\n    [0.081556028106671, 0.034075126991164],\n    [0.080695219477356, 0.036066349323177],\n    [0.079785803065216, 0.038035846634965],\n    [0.078828326668693, 0.039982432574992],\n    [0.077823367035766, 0.041904934592675],\n    [0.076771529516540, 0.043802194644686],\n    [0.075673447698606, 0.045673069892513],\n    [0.074529783025390, 0.047516433390863],\n    [0.073341224397728, 0.049331174766491],\n    [0.072108487758894, 0.051116200887052],\n    [0.070832315663343, 0.052870436519557],\n    [0.069513476829429, 0.054592824978055],\n    [0.068152765676348, 0.056282328760143],\n    [0.066751001845620, 0.057937930171918],\n    [0.065309029707361, 0.059558631940996],\n    [0.063827717851668, 0.061143457817234],\n    [0.062307958565413, 0.062691453160784],\n    [0.060750667294763, 0.064201685517134],\n    [0.059156782093749, 0.065673245178784],\n    [0.057527263059216, 0.067105245733220],\n    [0.055863091752499, 0.068496824596852],\n    [0.054165270608165, 0.069847143534609],\n    [0.052434822330188, 0.071155389164853],\n    [0.050672789275903, 0.072420773449336],\n    [0.048880232828135, 0.073642534167879],\n    [0.047058232755862, 0.074819935377512],\n    [0.045207886563797, 0.075952267855771],\n    [0.043330308831298, 0.077038849527912],\n    [0.041426630540984, 0.078079025877766],\n    [0.039497998397473, 0.079072170341994],\n    [0.037545574136653, 0.080017684687506],\n    [0.035570533825892, 0.080914999371817],\n    [0.033574067155622, 0.081763573886112],\n    [0.031557376722714, 0.082562897080836],\n    [0.029521677306074, 0.083312487473584],\n    [0.027468195134911, 0.084011893539132],\n    [0.025398167150101, 0.084660693981419],\n    [0.023312840259098, 0.085258497987320],\n    [0.021213470584847, 0.085804945462053],\n    [0.019101322709138, 0.086299707246093],\n    [0.016977668910873, 0.086742485313442],\n    [0.014843788399692, 0.087133012951149],\n    [0.012700966545425, 0.087471054919968],\n    [0.010550494103830, 0.087756407596056],\n    [0.008393666439096, 0.087988899093631],\n    [0.006231782743558, 0.088168389368510],\n    [0.004066145255116, 0.088294770302461],\n    [0.001898058472816, 0.088367965768336]\n];                                      \n\nconst MDCT_TABLE_1920 = [             \n    [0.032274858518097, 0.000013202404176],\n    [0.032274642494505, 0.000118821372483],\n    [0.032274080835421, 0.000224439068308],\n    [0.032273173546860, 0.000330054360572],\n    [0.032271920638538, 0.000435666118218],\n    [0.032270322123873, 0.000541273210231],\n    [0.032268378019984, 0.000646874505642],\n    [0.032266088347691, 0.000752468873546],\n    [0.032263453131514, 0.000858055183114],\n    [0.032260472399674, 0.000963632303600],\n    [0.032257146184092, 0.001069199104358],\n    [0.032253474520390, 0.001174754454853],\n    [0.032249457447888, 0.001280297224671],\n    [0.032245095009606, 0.001385826283535],\n    [0.032240387252262, 0.001491340501313],\n    [0.032235334226272, 0.001596838748031],\n    [0.032229935985750, 0.001702319893890],\n    [0.032224192588507, 0.001807782809271],\n    [0.032218104096050, 0.001913226364749],\n    [0.032211670573582, 0.002018649431111],\n    [0.032204892090000, 0.002124050879359],\n    [0.032197768717898, 0.002229429580728],\n    [0.032190300533560, 0.002334784406698],\n    [0.032182487616965, 0.002440114229003],\n    [0.032174330051782, 0.002545417919644],\n    [0.032165827925374, 0.002650694350905],\n    [0.032156981328790, 0.002755942395358],\n    [0.032147790356771, 0.002861160925883],\n    [0.032138255107744, 0.002966348815672],\n    [0.032128375683825, 0.003071504938250],\n    [0.032118152190814, 0.003176628167476],\n    [0.032107584738196, 0.003281717377568],\n    [0.032096673439141, 0.003386771443102],\n    [0.032085418410500, 0.003491789239036],\n    [0.032073819772804, 0.003596769640711],\n    [0.032061877650267, 0.003701711523874],\n    [0.032049592170778, 0.003806613764680],\n    [0.032036963465906, 0.003911475239711],\n    [0.032023991670893, 0.004016294825985],\n    [0.032010676924657, 0.004121071400967],\n    [0.031997019369789, 0.004225803842586],\n    [0.031983019152549, 0.004330491029241],\n    [0.031968676422869, 0.004435131839816],\n    [0.031953991334348, 0.004539725153692],\n    [0.031938964044252, 0.004644269850758],\n    [0.031923594713510, 0.004748764811426],\n    [0.031907883506716, 0.004853208916638],\n    [0.031891830592124, 0.004957601047881],\n    [0.031875436141648, 0.005061940087200],\n    [0.031858700330859, 0.005166224917208],\n    [0.031841623338985, 0.005270454421097],\n    [0.031824205348907, 0.005374627482653],\n    [0.031806446547156, 0.005478742986267],\n    [0.031788347123916, 0.005582799816945],\n    [0.031769907273017, 0.005686796860323],\n    [0.031751127191935, 0.005790733002674],\n    [0.031732007081789, 0.005894607130928],\n    [0.031712547147340, 0.005998418132675],\n    [0.031692747596989, 0.006102164896182],\n    [0.031672608642773, 0.006205846310406],\n    [0.031652130500364, 0.006309461265002],\n    [0.031631313389067, 0.006413008650337],\n    [0.031610157531816, 0.006516487357501],\n    [0.031588663155172, 0.006619896278321],\n    [0.031566830489325, 0.006723234305370],\n    [0.031544659768083, 0.006826500331981],\n    [0.031522151228878, 0.006929693252258],\n    [0.031499305112758, 0.007032811961088],\n    [0.031476121664387, 0.007135855354151],\n    [0.031452601132040, 0.007238822327937],\n    [0.031428743767604, 0.007341711779751],\n    [0.031404549826572, 0.007444522607730],\n    [0.031380019568042, 0.007547253710853],\n    [0.031355153254712, 0.007649903988952],\n    [0.031329951152882, 0.007752472342725],\n    [0.031304413532445, 0.007854957673748],\n    [0.031278540666888, 0.007957358884484],\n    [0.031252332833290, 0.008059674878300],\n    [0.031225790312316, 0.008161904559473],\n    [0.031198913388214, 0.008264046833205],\n    [0.031171702348814, 0.008366100605636],\n    [0.031144157485525, 0.008468064783849],\n    [0.031116279093331, 0.008569938275893],\n    [0.031088067470786, 0.008671719990782],\n    [0.031059522920014, 0.008773408838517],\n    [0.031030645746705, 0.008875003730092],\n    [0.031001436260110, 0.008976503577507],\n    [0.030971894773039, 0.009077907293780],\n    [0.030942021601857, 0.009179213792959],\n    [0.030911817066483, 0.009280421990133],\n    [0.030881281490382, 0.009381530801444],\n    [0.030850415200566, 0.009482539144097],\n    [0.030819218527589, 0.009583445936373],\n    [0.030787691805541, 0.009684250097643],\n    [0.030755835372048, 0.009784950548375],\n    [0.030723649568268, 0.009885546210147],\n    [0.030691134738883, 0.009986036005661],\n    [0.030658291232103, 0.010086418858753],\n    [0.030625119399655, 0.010186693694402],\n    [0.030591619596781, 0.010286859438745],\n    [0.030557792182239, 0.010386915019088],\n    [0.030523637518292, 0.010486859363916],\n    [0.030489155970710, 0.010586691402906],\n    [0.030454347908763, 0.010686410066936],\n    [0.030419213705216, 0.010786014288099],\n    [0.030383753736329, 0.010885502999714],\n    [0.030347968381849, 0.010984875136338],\n    [0.030311858025010, 0.011084129633775],\n    [0.030275423052523, 0.011183265429088],\n    [0.030238663854579, 0.011282281460612],\n    [0.030201580824838, 0.011381176667967],\n    [0.030164174360430, 0.011479949992062],\n    [0.030126444861948, 0.011578600375117],\n    [0.030088392733446, 0.011677126760663],\n    [0.030050018382430, 0.011775528093563],\n    [0.030011322219859, 0.011873803320018],\n    [0.029972304660138, 0.011971951387578],\n    [0.029932966121114, 0.012069971245157],\n    [0.029893307024070, 0.012167861843041],\n    [0.029853327793724, 0.012265622132901],\n    [0.029813028858222, 0.012363251067801],\n    [0.029772410649132, 0.012460747602215],\n    [0.029731473601443, 0.012558110692033],\n    [0.029690218153558, 0.012655339294575],\n    [0.029648644747289, 0.012752432368600],\n    [0.029606753827855, 0.012849388874320],\n    [0.029564545843872, 0.012946207773407],\n    [0.029522021247356, 0.013042888029011],\n    [0.029479180493710, 0.013139428605762],\n    [0.029436024041725, 0.013235828469789],\n    [0.029392552353570, 0.013332086588727],\n    [0.029348765894794, 0.013428201931728],\n    [0.029304665134313, 0.013524173469475],\n    [0.029260250544412, 0.013620000174189],\n    [0.029215522600735, 0.013715681019643],\n    [0.029170481782283, 0.013811214981173],\n    [0.029125128571406, 0.013906601035686],\n    [0.029079463453801, 0.014001838161674],\n    [0.029033486918505, 0.014096925339225],\n    [0.028987199457889, 0.014191861550031],\n    [0.028940601567655, 0.014286645777401],\n    [0.028893693746829, 0.014381277006273],\n    [0.028846476497755, 0.014475754223221],\n    [0.028798950326094, 0.014570076416472],\n    [0.028751115740811, 0.014664242575910],\n    [0.028702973254178, 0.014758251693091],\n    [0.028654523381760, 0.014852102761253],\n    [0.028605766642418, 0.014945794775326],\n    [0.028556703558297, 0.015039326731945],\n    [0.028507334654823, 0.015132697629457],\n    [0.028457660460698, 0.015225906467935],\n    [0.028407681507891, 0.015318952249187],\n    [0.028357398331639, 0.015411833976768],\n    [0.028306811470432, 0.015504550655988],\n    [0.028255921466016, 0.015597101293927],\n    [0.028204728863381, 0.015689484899442],\n    [0.028153234210760, 0.015781700483179],\n    [0.028101438059619, 0.015873747057582],\n    [0.028049340964652, 0.015965623636907],\n    [0.027996943483779, 0.016057329237229],\n    [0.027944246178133, 0.016148862876456],\n    [0.027891249612061, 0.016240223574335],\n    [0.027837954353113, 0.016331410352467],\n    [0.027784360972039, 0.016422422234315],\n    [0.027730470042780, 0.016513258245214],\n    [0.027676282142466, 0.016603917412384],\n    [0.027621797851405, 0.016694398764938],\n    [0.027567017753080, 0.016784701333894],\n    [0.027511942434143, 0.016874824152183],\n    [0.027456572484404, 0.016964766254662],\n    [0.027400908496833, 0.017054526678124],\n    [0.027344951067546, 0.017144104461307],\n    [0.027288700795801, 0.017233498644904],\n    [0.027232158283994, 0.017322708271577],\n    [0.027175324137651, 0.017411732385960],\n    [0.027118198965418, 0.017500570034678],\n    [0.027060783379060, 0.017589220266351],\n    [0.027003077993454, 0.017677682131607],\n    [0.026945083426576, 0.017765954683088],\n    [0.026886800299502, 0.017854036975468],\n    [0.026828229236397, 0.017941928065456],\n    [0.026769370864511, 0.018029627011808],\n    [0.026710225814170, 0.018117132875340],\n    [0.026650794718768, 0.018204444718934],\n    [0.026591078214767, 0.018291561607551],\n    [0.026531076941680, 0.018378482608238],\n    [0.026470791542075, 0.018465206790142],\n    [0.026410222661558, 0.018551733224515],\n    [0.026349370948775, 0.018638060984730],\n    [0.026288237055398, 0.018724189146286],\n    [0.026226821636121, 0.018810116786819],\n    [0.026165125348656, 0.018895842986112],\n    [0.026103148853718, 0.018981366826109],\n    [0.026040892815028, 0.019066687390916],\n    [0.025978357899296, 0.019151803766819],\n    [0.025915544776223, 0.019236715042290],\n    [0.025852454118485, 0.019321420307998],\n    [0.025789086601733, 0.019405918656817],\n    [0.025725442904582, 0.019490209183837],\n    [0.025661523708606, 0.019574290986376],\n    [0.025597329698327, 0.019658163163984],\n    [0.025532861561211, 0.019741824818458],\n    [0.025468119987662, 0.019825275053848],\n    [0.025403105671008, 0.019908512976470],\n    [0.025337819307501, 0.019991537694913],\n    [0.025272261596305, 0.020074348320047],\n    [0.025206433239491, 0.020156943965039],\n    [0.025140334942028, 0.020239323745355],\n    [0.025073967411776, 0.020321486778774],\n    [0.025007331359476, 0.020403432185395],\n    [0.024940427498748, 0.020485159087650],\n    [0.024873256546079, 0.020566666610309],\n    [0.024805819220816, 0.020647953880491],\n    [0.024738116245157, 0.020729020027676],\n    [0.024670148344147, 0.020809864183709],\n    [0.024601916245669, 0.020890485482816],\n    [0.024533420680433, 0.020970883061607],\n    [0.024464662381971, 0.021051056059087],\n    [0.024395642086630, 0.021131003616670],\n    [0.024326360533561, 0.021210724878181],\n    [0.024256818464715, 0.021290218989868],\n    [0.024187016624830, 0.021369485100415],\n    [0.024116955761430, 0.021448522360944],\n    [0.024046636624808, 0.021527329925030],\n    [0.023976059968027, 0.021605906948708],\n    [0.023905226546906, 0.021684252590480],\n    [0.023834137120014, 0.021762366011328],\n    [0.023762792448662, 0.021840246374720],\n    [0.023691193296893, 0.021917892846620],\n    [0.023619340431478, 0.021995304595495],\n    [0.023547234621902, 0.022072480792330],\n    [0.023474876640361, 0.022149420610628],\n    [0.023402267261751, 0.022226123226426],\n    [0.023329407263659, 0.022302587818300],\n    [0.023256297426359, 0.022378813567377],\n    [0.023182938532797, 0.022454799657339],\n    [0.023109331368588, 0.022530545274437],\n    [0.023035476722006, 0.022606049607496],\n    [0.022961375383975, 0.022681311847926],\n    [0.022887028148061, 0.022756331189727],\n    [0.022812435810462, 0.022831106829504],\n    [0.022737599170003, 0.022905637966469],\n    [0.022662519028125, 0.022979923802453],\n    [0.022587196188874, 0.023053963541915],\n    [0.022511631458899, 0.023127756391950],\n    [0.022435825647437, 0.023201301562294],\n    [0.022359779566306, 0.023274598265338],\n    [0.022283494029900, 0.023347645716133],\n    [0.022206969855176, 0.023420443132400],\n    [0.022130207861645, 0.023492989734537],\n    [0.022053208871367, 0.023565284745628],\n    [0.021975973708940, 0.023637327391451],\n    [0.021898503201489, 0.023709116900488],\n    [0.021820798178663, 0.023780652503931],\n    [0.021742859472618, 0.023851933435691],\n    [0.021664687918017, 0.023922958932406],\n    [0.021586284352013, 0.023993728233451],\n    [0.021507649614247, 0.024064240580942],\n    [0.021428784546832, 0.024134495219750],\n    [0.021349689994350, 0.024204491397504],\n    [0.021270366803840, 0.024274228364600],\n    [0.021190815824791, 0.024343705374213],\n    [0.021111037909128, 0.024412921682298],\n    [0.021031033911210, 0.024481876547605],\n    [0.020950804687815, 0.024550569231683],\n    [0.020870351098134, 0.024618998998889],\n    [0.020789674003759, 0.024687165116394],\n    [0.020708774268678, 0.024755066854194],\n    [0.020627652759262, 0.024822703485116],\n    [0.020546310344257, 0.024890074284826],\n    [0.020464747894775, 0.024957178531837],\n    [0.020382966284284, 0.025024015507516],\n    [0.020300966388600, 0.025090584496093],\n    [0.020218749085876, 0.025156884784668],\n    [0.020136315256592, 0.025222915663218],\n    [0.020053665783549, 0.025288676424605],\n    [0.019970801551857, 0.025354166364584],\n    [0.019887723448925, 0.025419384781811],\n    [0.019804432364452, 0.025484330977848],\n    [0.019720929190419, 0.025549004257175],\n    [0.019637214821078, 0.025613403927192],\n    [0.019553290152943, 0.025677529298230],\n    [0.019469156084779, 0.025741379683559],\n    [0.019384813517595, 0.025804954399392],\n    [0.019300263354632, 0.025868252764895],\n    [0.019215506501354, 0.025931274102193],\n    [0.019130543865439, 0.025994017736379],\n    [0.019045376356769, 0.026056482995518],\n    [0.018960004887419, 0.026118669210657],\n    [0.018874430371648, 0.026180575715833],\n    [0.018788653725892, 0.026242201848076],\n    [0.018702675868750, 0.026303546947421],\n    [0.018616497720974, 0.026364610356909],\n    [0.018530120205464, 0.026425391422602],\n    [0.018443544247254, 0.026485889493583],\n    [0.018356770773502, 0.026546103921965],\n    [0.018269800713483, 0.026606034062902],\n    [0.018182634998576, 0.026665679274589],\n    [0.018095274562256, 0.026725038918274],\n    [0.018007720340083, 0.026784112358263],\n    [0.017919973269692, 0.026842898961926],\n    [0.017832034290785, 0.026901398099707],\n    [0.017743904345116, 0.026959609145127],\n    [0.017655584376488, 0.027017531474792],\n    [0.017567075330734, 0.027075164468401],\n    [0.017478378155718, 0.027132507508750],\n    [0.017389493801313, 0.027189559981742],\n    [0.017300423219401, 0.027246321276391],\n    [0.017211167363854, 0.027302790784828],\n    [0.017121727190533, 0.027358967902310],\n    [0.017032103657269, 0.027414852027226],\n    [0.016942297723858, 0.027470442561102],\n    [0.016852310352050, 0.027525738908608],\n    [0.016762142505537, 0.027580740477564],\n    [0.016671795149944, 0.027635446678948],\n    [0.016581269252819, 0.027689856926900],\n    [0.016490565783622, 0.027743970638730],\n    [0.016399685713714, 0.027797787234924],\n    [0.016308630016347, 0.027851306139149],\n    [0.016217399666655, 0.027904526778260],\n    [0.016125995641641, 0.027957448582309],\n    [0.016034418920170, 0.028010070984544],\n    [0.015942670482954, 0.028062393421421],\n    [0.015850751312545, 0.028114415332610],\n    [0.015758662393324, 0.028166136160998],\n    [0.015666404711489, 0.028217555352697],\n    [0.015573979255046, 0.028268672357047],\n    [0.015481387013797, 0.028319486626627],\n    [0.015388628979331, 0.028369997617257],\n    [0.015295706145012, 0.028420204788004],\n    [0.015202619505968, 0.028470107601191],\n    [0.015109370059084, 0.028519705522399],\n    [0.015015958802984, 0.028568998020472],\n    [0.014922386738030, 0.028617984567529],\n    [0.014828654866302, 0.028666664638963],\n    [0.014734764191593, 0.028715037713449],\n    [0.014640715719398, 0.028763103272951],\n    [0.014546510456900, 0.028810860802724],\n    [0.014452149412962, 0.028858309791325],\n    [0.014357633598114, 0.028905449730613],\n    [0.014262964024545, 0.028952280115756],\n    [0.014168141706090, 0.028998800445240],\n    [0.014073167658220, 0.029045010220868],\n    [0.013978042898030, 0.029090908947771],\n    [0.013882768444231, 0.029136496134411],\n    [0.013787345317136, 0.029181771292585],\n    [0.013691774538648, 0.029226733937433],\n    [0.013596057132255, 0.029271383587441],\n    [0.013500194123014, 0.029315719764447],\n    [0.013404186537539, 0.029359741993647],\n    [0.013308035403995, 0.029403449803598],\n    [0.013211741752084, 0.029446842726223],\n    [0.013115306613032, 0.029489920296820],\n    [0.013018731019584, 0.029532682054063],\n    [0.012922016005985, 0.029575127540008],\n    [0.012825162607977, 0.029617256300097],\n    [0.012728171862781, 0.029659067883165],\n    [0.012631044809089, 0.029700561841444],\n    [0.012533782487056, 0.029741737730567],\n    [0.012436385938281, 0.029782595109573],\n    [0.012338856205805, 0.029823133540913],\n    [0.012241194334091, 0.029863352590452],\n    [0.012143401369021, 0.029903251827477],\n    [0.012045478357878, 0.029942830824699],\n    [0.011947426349339, 0.029982089158259],\n    [0.011849246393462, 0.030021026407731],\n    [0.011750939541676, 0.030059642156129],\n    [0.011652506846768, 0.030097935989909],\n    [0.011553949362874, 0.030135907498976],\n    [0.011455268145464, 0.030173556276684],\n    [0.011356464251335, 0.030210881919845],\n    [0.011257538738598, 0.030247884028732],\n    [0.011158492666665, 0.030284562207083],\n    [0.011059327096240, 0.030320916062102],\n    [0.010960043089307, 0.030356945204470],\n    [0.010860641709118, 0.030392649248343],\n    [0.010761124020182, 0.030428027811361],\n    [0.010661491088253, 0.030463080514646],\n    [0.010561743980319, 0.030497806982812],\n    [0.010461883764593, 0.030532206843968],\n    [0.010361911510496, 0.030566279729717],\n    [0.010261828288652, 0.030600025275167],\n    [0.010161635170872, 0.030633443118931],\n    [0.010061333230142, 0.030666532903129],\n    [0.009960923540617, 0.030699294273397],\n    [0.009860407177603, 0.030731726878888],\n    [0.009759785217550, 0.030763830372273],\n    [0.009659058738038, 0.030795604409750],\n    [0.009558228817767, 0.030827048651045],\n    [0.009457296536545, 0.030858162759415],\n    [0.009356262975275, 0.030888946401653],\n    [0.009255129215945, 0.030919399248091],\n    [0.009153896341616, 0.030949520972603],\n    [0.009052565436412, 0.030979311252611],\n    [0.008951137585505, 0.031008769769084],\n    [0.008849613875105, 0.031037896206544],\n    [0.008747995392451, 0.031066690253072],\n    [0.008646283225794, 0.031095151600306],\n    [0.008544478464390, 0.031123279943448],\n    [0.008442582198486, 0.031151074981266],\n    [0.008340595519310, 0.031178536416098],\n    [0.008238519519057, 0.031205663953853],\n    [0.008136355290878, 0.031232457304017],\n    [0.008034103928871, 0.031258916179656],\n    [0.007931766528065, 0.031285040297416],\n    [0.007829344184412, 0.031310829377528],\n    [0.007726837994772, 0.031336283143813],\n    [0.007624249056906, 0.031361401323680],\n    [0.007521578469457, 0.031386183648135],\n    [0.007418827331946, 0.031410629851778],\n    [0.007315996744755, 0.031434739672811],\n    [0.007213087809115, 0.031458512853036],\n    [0.007110101627101, 0.031481949137863],\n    [0.007007039301610, 0.031505048276306],\n    [0.006903901936357, 0.031527810020993],\n    [0.006800690635862, 0.031550234128164],\n    [0.006697406505433, 0.031572320357675],\n    [0.006594050651161, 0.031594068473000],\n    [0.006490624179905, 0.031615478241233],\n    [0.006387128199278, 0.031636549433095],\n    [0.006283563817639, 0.031657281822929],\n    [0.006179932144080, 0.031677675188707],\n    [0.006076234288412, 0.031697729312034],\n    [0.005972471361157, 0.031717443978146],\n    [0.005868644473532, 0.031736818975914],\n    [0.005764754737440, 0.031755854097848],\n    [0.005660803265456, 0.031774549140098],\n    [0.005556791170816, 0.031792903902453],\n    [0.005452719567407, 0.031810918188350],\n    [0.005348589569753, 0.031828591804869],\n    [0.005244402293001, 0.031845924562742],\n    [0.005140158852914, 0.031862916276347],\n    [0.005035860365855, 0.031879566763717],\n    [0.004931507948778, 0.031895875846539],\n    [0.004827102719212, 0.031911843350155],\n    [0.004722645795254, 0.031927469103567],\n    [0.004618138295554, 0.031942752939435],\n    [0.004513581339303, 0.031957694694082],\n    [0.004408976046222, 0.031972294207493],\n    [0.004304323536549, 0.031986551323320],\n    [0.004199624931030, 0.032000465888879],\n    [0.004094881350902, 0.032014037755158],\n    [0.003990093917884, 0.032027266776813],\n    [0.003885263754166, 0.032040152812170],\n    [0.003780391982394, 0.032052695723232],\n    [0.003675479725661, 0.032064895375674],\n    [0.003570528107494, 0.032076751638847],\n    [0.003465538251839, 0.032088264385780],\n    [0.003360511283053, 0.032099433493181],\n    [0.003255448325892, 0.032110258841438],\n    [0.003150350505494, 0.032120740314619],\n    [0.003045218947373, 0.032130877800478],\n    [0.002940054777404, 0.032140671190449],\n    [0.002834859121810, 0.032150120379653],\n    [0.002729633107153, 0.032159225266897],\n    [0.002624377860318, 0.032167985754674],\n    [0.002519094508504, 0.032176401749168],\n    [0.002413784179212, 0.032184473160250],\n    [0.002308448000231, 0.032192199901481],\n    [0.002203087099626, 0.032199581890114],\n    [0.002097702605728, 0.032206619047093],\n    [0.001992295647121, 0.032213311297057],\n    [0.001886867352628, 0.032219658568338],\n    [0.001781418851302, 0.032225660792960],\n    [0.001675951272410, 0.032231317906644],\n    [0.001570465745428, 0.032236629848809],\n    [0.001464963400018, 0.032241596562566],\n    [0.001359445366028, 0.032246217994727],\n    [0.001253912773470, 0.032250494095799],\n    [0.001148366752513, 0.032254424819990],\n    [0.001042808433471, 0.032258010125204],\n    [0.000937238946789, 0.032261249973045],\n    [0.000831659423030, 0.032264144328817],\n    [0.000726070992868, 0.032266693161525],\n    [0.000620474787068, 0.032268896443871],\n    [0.000514871936481, 0.032270754152261],\n    [0.000409263572030, 0.032272266266801],\n    [0.000303650824695, 0.032273432771295],\n    [0.000198034825504, 0.032274253653254],\n    [0.000092416705518, 0.032274728903884]\n];\n\nconst MDCT_TABLE_240 = [              \n    [0.091286604111815, 0.000298735779793],\n    [0.091247502481454, 0.002688238127538],\n    [0.091145864370807, 0.005075898091152],\n    [0.090981759437558, 0.007460079287760],\n    [0.090755300151030, 0.009839147718664],\n    [0.090466641715108, 0.012211472889198],\n    [0.090115981961863, 0.014575428926191],\n    [0.089703561215976, 0.016929395692256],\n    [0.089229662130024, 0.019271759896156],\n    [0.088694609490769, 0.021600916198470],\n    [0.088098769996564, 0.023915268311810],\n    [0.087442552006035, 0.026213230094844],\n    [0.086726405258214, 0.028493226639351],\n    [0.085950820564309, 0.030753695349588],\n    [0.085116329471329, 0.032993087013213],\n    [0.084223503897785, 0.035209866863042],\n    [0.083272955741727, 0.037402515628894],\n    [0.082265336461381, 0.039569530578832],\n    [0.081201336628670, 0.041709426549053],\n    [0.080081685455930, 0.043820736961749],\n    [0.078907150296148, 0.045902014830227],\n    [0.077678536117054, 0.047951833750597],\n    [0.076396684949434, 0.049968788879362],\n    [0.075062475310050, 0.051951497896226],\n    [0.073676821599542, 0.053898601951466],\n    [0.072240673475749, 0.055808766597225],\n    [0.070755015202858, 0.057680682702068],\n    [0.069220864976840, 0.059513067348201],\n    [0.067639274227625, 0.061304664710718],\n    [0.066011326898512, 0.063054246918278],\n    [0.064338138703282, 0.064760614894630],\n    [0.062620856361546, 0.066422599180399],\n    [0.060860656812842, 0.068039060734572],\n    [0.059058746410016, 0.069608891715145],\n    [0.057216360092450, 0.071131016238378],\n    [0.055334760539699, 0.072604391116154],\n    [0.053415237306106, 0.074028006570930],\n    [0.051459105937014, 0.075400886927784],\n    [0.049467707067153, 0.076722091283096],\n    [0.047442405501835, 0.077990714149396],\n    [0.045384589281588, 0.079205886075941],\n    [0.043295668730857, 0.080366774244592],\n    [0.041177075491445, 0.081472583040586],\n    [0.039030261541332, 0.082522554597810],\n    [0.036856698199564, 0.083515969318206],\n    [0.034657875117883, 0.084452146364948],\n    [0.032435299259796, 0.085330444129049],\n    [0.030190493867775, 0.086150260669096],\n    [0.027924997419306, 0.086911034123781],\n    [0.025640362572491, 0.087612243096981],\n    [0.023338155101933, 0.088253407015092],\n    [0.021019952825636, 0.088834086456390],\n    [0.018687344523641, 0.089353883452193],\n    [0.016341928849164, 0.089812441759604],\n    [0.013985313232951, 0.090209447105664],\n    [0.011619112781631, 0.090544627402740],\n    [0.009244949170797, 0.090817752935000],\n    [0.006864449533597, 0.091028636515846],\n    [0.004479245345574, 0.091177133616206],\n    [0.002090971306534, 0.091263142463585]\n];                    //import \"mdct_tables.js\"\n/*\n * AAC.js - Advanced Audio Coding decoder in JavaScript\n * Created by Devon Govett\n * Copyright (c) 2012, Official.fm Labs\n *\n * AAC.js is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as \n * published by the Free Software Foundation; either version 3 of the \n * License, or (at your option) any later version.\n *\n * AAC.js is distributed in the hope that it will be useful, but WITHOUT \n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General \n * Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar FFT = (function() {\n    \n    function FFT(length) {\n        this.length = length;\n    \n        switch (length) {\n            case 64:\n                this.roots = generateFFTTableShort(64);\n                break;\n    \n            case 512:\n                this.roots = generateFFTTableLong(512);\n                break;\n    \n            case 60:\n                this.roots = generateFFTTableShort(60);\n                break;\n    \n            case 480:\n                this.roots = generateFFTTableLong(480);\n                break;\n    \n            default:\n                throw new Error(\"unexpected FFT length: \" + length);\n        }\n    \n        // processing buffers\n        this.rev = new Array(length);\n        for (var i = 0; i < length; i++) {\n            this.rev[i] = new Float32Array(2);\n        }\n    \n        this.a = new Float32Array(2);\n        this.b = new Float32Array(2);\n        this.c = new Float32Array(2);\n        this.d = new Float32Array(2);     \n        this.e1 = new Float32Array(2);\n        this.e2 = new Float32Array(2);\n    }\n    \n    function generateFFTTableShort(len) {\n        var t = 2 * Math.PI / len,\n            cosT = Math.cos(t),\n            sinT = Math.sin(t),\n            f = new Array(len);\n    \n        for (var i = 0; i < len; i++) {\n            f[i] = new Float32Array(2);\n        }\n    \n        f[0][0] = 1;\n        f[0][1] = 0;\n        var lastImag = 0;\n    \n        for (var i = 1; i < len; i++) {\n            f[i][0] = f[i - 1][0] * cosT + lastImag * sinT;\n            lastImag = lastImag * cosT - f[i - 1][0] * sinT;\n            f[i][1] = -lastImag;\n        }\n    \n        return f;\n    }\n    \n    function generateFFTTableLong(len) {\n        var t = 2 * Math.PI / len,\n            cosT = Math.cos(t),\n            sinT = Math.sin(t),\n            f = new Array(len);\n    \n        for (var i = 0; i < len; i++) {\n            f[i] = new Float32Array(3);\n        }\n    \n        f[0][0] = 1;\n        f[0][1] = 0;\n        f[0][2] = 0;\n    \n        for (var i = 1; i < len; i++) {\n            f[i][0] = f[i - 1][0] * cosT + f[i - 1][2] * sinT;\n            f[i][2] = f[i - 1][2] * cosT - f[i - 1][0] * sinT;\n            f[i][1] = -f[i][2];\n        }\n    \n        return f;\n    }\n    \n    FFT.prototype.process = function(input, forward) {\n        var length = this.length,\n            imOffset = (forward ? 2 : 1),\n            scale = (forward ? length : 1),\n            rev = this.rev,\n            roots = this.roots;\n    \n        // bit-reversal\n        var ii = 0;\n        for (var i = 0; i < length; i++) {\n            rev[i][0] = input[ii][0];\n            rev[i][1] = input[ii][1];\n    \n            var k = length >>> 1;\n            while (ii >= k && k > 0) {\n                ii -= k;\n                k >>= 1;\n            }\n    \n            ii += k;\n        }\n    \n        var a = this.a,\n            b = this.b,\n            c = this.c,\n            d = this.d,\n            e1 = this.e1,\n            e2 = this.e2;\n    \n        for (var i = 0; i < length; i++) {\n            input[i][0] = rev[i][0];\n            input[i][1] = rev[i][1];\n        }\n    \n        // bottom base-4 round\n        for (var i = 0; i < length; i += 4) {\n            a[0] = input[i][0] + input[i + 1][0];\n            a[1] = input[i][1] + input[i + 1][1];\n            b[0] = input[i + 2][0] + input[i + 3][0];\n            b[1] = input[i + 2][1] + input[i + 3][1];\n            c[0] = input[i][0] - input[i + 1][0];\n            c[1] = input[i][1] - input[i + 1][1];\n            d[0] = input[i + 2][0] - input[i + 3][0];\n            d[1] = input[i + 2][1] - input[i + 3][1];\n            input[i][0] = a[0] + b[0];\n            input[i][1] = a[1] + b[1];\n            input[i + 2][0] = a[0] - b[0];\n            input[i + 2][1] = a[1] - b[1];\n    \n            e1[0] = c[0] - d[1];\n            e1[1] = c[1] + d[0];\n            e2[0] = c[0] + d[1];\n            e2[1] = c[1] - d[0];\n    \n            if (forward) {\n                input[i + 1][0] = e2[0];\n                input[i + 1][1] = e2[1];\n                input[i + 3][0] = e1[0];\n                input[i + 3][1] = e1[1];\n            } else {\n                input[i + 1][0] = e1[0];\n                input[i + 1][1] = e1[1];\n                input[i + 3][0] = e2[0];\n                input[i + 3][1] = e2[1];\n            }\n        }\n    \n        // iterations from bottom to top\n        for (var i = 4; i < length; i <<= 1) {\n            var shift = i << 1,\n                m = length / shift;\n    \n            for(var j = 0; j < length; j += shift) {\n                for(var k = 0; k < i; k++) {\n                    var km = k * m,\n                        rootRe = roots[km][0],\n                        rootIm = roots[km][imOffset],\n                        zRe = input[i + j + k][0] * rootRe - input[i + j + k][1] * rootIm,\n                        zIm = input[i + j + k][0] * rootIm + input[i + j + k][1] * rootRe;\n    \n                    input[i + j + k][0] = (input[j + k][0] - zRe) * scale;\n                    input[i + j + k][1] = (input[j + k][1] - zIm) * scale;\n                    input[j + k][0] = (input[j + k][0] + zRe) * scale;\n                    input[j + k][1] = (input[j + k][1] + zIm) * scale;\n                }\n            }\n        }\n    };\n    \n    return FFT;\n    \n})();//import \"fft.js\"\n\n// Modified Discrete Cosine Transform\nfunction MDCT(length) {\n    this.N = length;\n    this.N2 = length >>> 1;\n    this.N4 = length >>> 2;\n    this.N8 = length >>> 3;\n    \n    switch (length) {\n        case 2048:\n            this.sincos = MDCT_TABLE_2048;\n            break;\n            \n        case 256:\n            this.sincos = MDCT_TABLE_256;\n            break;\n            \n        case 1920:\n            this.sincos = MDCT_TABLE_1920;\n            break;\n            \n        case 240:\n            this.sincos = MDCT_TABLE_240;\n            break;\n            \n        default:\n            throw new Error(\"unsupported MDCT length: \" + length);\n    }\n    \n    this.fft = new FFT(this.N4);\n    \n    this.buf = new Array(this.N4);\n    for (var i = 0; i < this.N4; i++) {\n        this.buf[i] = new Float32Array(2);\n    }\n    \n    this.tmp = new Float32Array(2);\n}\n\nMDCT.prototype.process = function(input, inOffset, output, outOffset) {\n    // local access\n    var N2 = this.N2,\n        N4 = this.N4,\n        N8 = this.N8,\n        buf = this.buf,\n        tmp = this.tmp,\n        sincos = this.sincos,\n        fft = this.fft;\n    \n    // pre-IFFT complex multiplication\n    for (var k = 0; k < N4; k++) {\n        buf[k][1] = (input[inOffset + 2 * k] * sincos[k][0]) + (input[inOffset + N2 - 1 - 2 * k] * sincos[k][1]);\n        buf[k][0] = (input[inOffset + N2 - 1 - 2 * k] * sincos[k][0]) - (input[inOffset + 2 * k] * sincos[k][1]);\n    }\n    \n    // complex IFFT, non-scaling\n    fft.process(buf, false);\n    \n    // post-IFFT complex multiplication\n    for (var k = 0; k < N4; k++) {\n        tmp[0] = buf[k][0];\n        tmp[1] = buf[k][1];\n        buf[k][1] = (tmp[1] * sincos[k][0]) + (tmp[0] * sincos[k][1]);\n        buf[k][0] = (tmp[0] * sincos[k][0]) - (tmp[1] * sincos[k][1]);\n    }\n    \n    // reordering\n    for (var k = 0; k < N8; k += 2) {\n        output[outOffset + 2 * k] = buf[N8 + k][1];\n        output[outOffset + 2 + 2 * k] = buf[N8 + 1 + k][1];\n\n        output[outOffset + 1 + 2 * k] = -buf[N8 - 1 - k][0];\n        output[outOffset + 3 + 2 * k] = -buf[N8 - 2 - k][0];\n\n        output[outOffset + N4 + 2 * k] = buf[k][0];\n        output[outOffset + N4 + 2 + 2 * k] = buf[1 + k][0];\n\n        output[outOffset + N4 + 1 + 2 * k] = -buf[N4 - 1 - k][1];\n        output[outOffset + N4 + 3 + 2 * k] = -buf[N4 - 2 - k][1];\n\n        output[outOffset + N2 + 2 * k] = buf[N8 + k][0];\n        output[outOffset + N2 + 2 + 2 * k] = buf[N8 + 1 + k][0];\n\n        output[outOffset + N2 + 1 + 2 * k] = -buf[N8 - 1 - k][1];\n        output[outOffset + N2 + 3 + 2 * k] = -buf[N8 - 2 - k][1];\n\n        output[outOffset + N2 + N4 + 2 * k] = -buf[k][1];\n        output[outOffset + N2 + N4 + 2 + 2 * k] = -buf[1 + k][1];\n\n        output[outOffset + N2 + N4 + 1 + 2 * k] = buf[N4 - 1 - k][0];\n        output[outOffset + N2 + N4 + 3 + 2 * k] = buf[N4 - 2 - k][0];\n    }\n};//import \"mdct.js\"\n\nvar FilterBank = (function() {\n  \n  function FilterBank(smallFrames, channels) {\n      if (smallFrames) {\n          throw new Error(\"WHA?? No small frames allowed.\");\n      }\n  \n      this.length = 1024;\n      this.shortLength = 128;\n  \n      this.mid = (this.length - this.shortLength) / 2;\n      this.trans = this.shortLength / 2;\n  \n      this.mdctShort = new MDCT(this.shortLength * 2);\n      this.mdctLong  = new MDCT(this.length * 2);\n  \n      this.overlaps = new Array(channels);\n      for (var i = 0; i < channels; i++) {\n          this.overlaps[i] = new Float32Array(this.length);\n      }\n  \n      this.buf = new Float32Array(2 * this.length);\n  }\n    \n  function generateSineWindow(len) {\n      var d = new Float32Array(len);\n      for (var i = 0; i < len; i++) {\n          d[i] = Math.sin((i + 0.5) * (Math.PI / (2.0 * len)))\n      }\n      return d;\n  }\n  \n  function generateKBDWindow(alpha, len) {\n      var PIN = Math.PI / len,\n          out = new Float32Array(len),\n          sum = 0,\n          f = new Float32Array(len),\n          alpha2 = (alpha * PIN) * (alpha * PIN);\n  \n      for (var n = 0; n < len; n++) {\n          var tmp = n * (len - n) * alpha2,\n              bessel = 1;\n  \n          for (var j = 50; j > 0; j--) {\n              bessel = bessel * tmp / (j * j) + 1;\n          }\n  \n          sum += bessel;\n          f[n] = sum;\n      }\n  \n      sum++;\n      for (var n = 0; n < len; n++) {\n          out[n] = Math.sqrt(f[n] / sum);\n      }\n  \n      return out;\n  }\n  \n  const SINE_1024 = generateSineWindow(1024),\n        SINE_128  = generateSineWindow(128),\n        KBD_1024  = generateKBDWindow(4, 1024),\n        KBD_128   = generateKBDWindow(6, 128),\n        LONG_WINDOWS = [SINE_1024, KBD_1024],\n        SHORT_WINDOWS = [SINE_128, KBD_128];\n  \n  FilterBank.prototype.process = function(info, input, output, channel) {\n      var overlap = this.overlaps[channel],\n          windowShape = info.windowShape[1],\n          windowShapePrev = info.windowShape[0],\n          longWindows = LONG_WINDOWS[windowShape],\n          shortWindows = SHORT_WINDOWS[windowShape],\n          longWindowsPrev = LONG_WINDOWS[windowShapePrev],\n          shortWindowsPrev = SHORT_WINDOWS[windowShapePrev],\n          length = this.length,\n          shortLen = this.shortLength,\n          mid = this.mid,\n          trans = this.trans,\n          buf = this.buf,\n          mdctLong = this.mdctLong,\n          mdctShort = this.mdctShort;\n  \n      switch (info.windowSequence) {\n          case ICStream.ONLY_LONG_SEQUENCE:\n              mdctLong.process(input, 0, buf, 0);\n  \n              // add second half output of previous frame to windowed output of current frame\n              for (var i = 0; i < length; i++) {\n                  output[i] = overlap[i] + (buf[i] * longWindowsPrev[i]);\n              }\n  \n              // window the second half and save as overlap for next frame\n              for (var i = 0; i < length; i++) {\n                  overlap[i] = buf[length + i] * longWindows[length - 1 - i];\n              }\n  \n              break;\n  \n          case ICStream.LONG_START_SEQUENCE:\n              mdctLong.process(input, 0, buf, 0);\n  \n              // add second half output of previous frame to windowed output of current frame\n              for (var i = 0; i < length; i++) {\n                  output[i] = overlap[i] + (buf[i] * longWindowsPrev[i]);\n              }\n  \n              // window the second half and save as overlap for next frame\n              for (var i = 0; i < mid; i++) {\n                  overlap[i] = buf[length + i];\n              }\n  \n              for (var i = 0; i < shortLen; i++) {\n                  overlap[mid + i] = buf[length + mid + i] * shortWindows[shortLen - i - 1];\n              }\n  \n              for (var i = 0; i < mid; i++) {\n                  overlap[mid + shortLen + i] = 0;\n              }\n  \n              break;\n  \n          case ICStream.EIGHT_SHORT_SEQUENCE:\n              for (var i = 0; i < 8; i++) {\n                  mdctShort.process(input, i * shortLen, buf, 2 * i * shortLen);\n              }\n  \n              // add second half output of previous frame to windowed output of current frame\n              for (var i = 0; i < mid; i++) {\n                  output[i] = overlap[i];\n              }\n  \n              for (var i = 0; i < shortLen; i++) {\n                  output[mid + i] = overlap[mid + i] + buf[i] * shortWindowsPrev[i];\n                  output[mid + 1 * shortLen + i] = overlap[mid + shortLen * 1 + i] + (buf[shortLen * 1 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 2 + i]  * shortWindows[i]);\n                  output[mid + 2 * shortLen + i] = overlap[mid + shortLen * 2 + i] + (buf[shortLen * 3 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 4 + i] * shortWindows[i]);\n                  output[mid + 3 * shortLen + i] = overlap[mid + shortLen * 3 + i] + (buf[shortLen * 5 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 6 + i] * shortWindows[i]);\n  \n                  if (i < trans)\n                      output[mid + 4 * shortLen + i] = overlap[mid + shortLen * 4 + i] + (buf[shortLen * 7 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 8 + i] * shortWindows[i]);\n              }\n  \n              // window the second half and save as overlap for next frame\n              for (var i = 0; i < shortLen; i++) {\n                  if(i >= trans) \n                      overlap[mid + 4 * shortLen + i - length] = (buf[shortLen * 7 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 8 + i] * shortWindows[i]);\n  \n                  overlap[mid + 5 * shortLen + i - length] = (buf[shortLen * 9 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 10 + i] * shortWindows[i]);\n                  overlap[mid + 6 * shortLen + i - length] = (buf[shortLen * 11 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 12 + i]*shortWindows[i]);\n                  overlap[mid + 7 * shortLen + i - length] = (buf[shortLen * 13 + i] * shortWindows[shortLen - 1 - i]) + (buf[shortLen * 14 + i]*shortWindows[i]);\n                  overlap[mid + 8 * shortLen + i - length] = (buf[shortLen * 15 + i] * shortWindows[shortLen - 1 - i]);\n              }\n  \n              for (var i = 0; i < mid; i++) {\n                  overlap[mid + shortLen + i] = 0;\n              }\n  \n              break;\n  \n          case ICStream.LONG_STOP_SEQUENCE:\n              mdctLong.process(input, 0, buf, 0);\n  \n              // add second half output of previous frame to windowed output of current frame\n              // construct first half window using padding with 1's and 0's\n              for (var i = 0; i < mid; i++) {\n                  output[i] = overlap[i];\n              }\n  \n              for (var i = 0; i < shortLen; i++) {\n                  output[mid + i] = overlap[mid + i] + (buf[mid + i] * shortWindowsPrev[i]);\n              }\n  \n              for (var i = 0; i < mid; i++) {\n                  output[mid + shortLen + i] = overlap[mid + shortLen + i] + buf[mid + shortLen + i];\n              }\n  \n              // window the second half and save as overlap for next frame\n              for (var i = 0; i < length; i++) {\n                  overlap[i] = buf[length + i] * longWindows[length - 1 - i];\n              }\n  \n              break;\n      }\n  };\n  \n  return FilterBank;\n    \n})();//import \"filter_bank.js\"\n\nvar AACDecoder = AV.Decoder.extend(function() {\n    AV.Decoder.register('mp4a', this);\n    AV.Decoder.register('aac ', this);\n    \n    // AAC profiles\n    const AOT_AAC_MAIN = 1, // no\n          AOT_AAC_LC = 2,   // yes\n          AOT_AAC_LTP = 4,  // no\n          AOT_ESCAPE = 31;\n          \n    // Channel configurations\n    const CHANNEL_CONFIG_NONE = 0,\n          CHANNEL_CONFIG_MONO = 1,\n          CHANNEL_CONFIG_STEREO = 2,\n          CHANNEL_CONFIG_STEREO_PLUS_CENTER = 3,\n          CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO = 4,\n          CHANNEL_CONFIG_FIVE = 5,\n          CHANNEL_CONFIG_FIVE_PLUS_ONE = 6,\n          CHANNEL_CONFIG_SEVEN_PLUS_ONE = 8;\n    \n    this.prototype.setCookie = function(buffer) {\n        var data = AV.Stream.fromBuffer(buffer),\n            stream = new AV.Bitstream(data);\n        \n        this.format.bitsPerChannel = 16; // caf format doesn't encode this\n        this.config = {};\n        \n        this.config.profile = stream.read(5);\n        if (this.config.profile === AOT_ESCAPE)\n            this.config.profile = 32 + stream.read(6);\n            \n        this.config.sampleIndex = stream.read(4);\n        if (this.config.sampleIndex === 0x0f) {\n            this.config.sampleRate = 48000//stream.read(24);\n            for (var i = 0; i < SAMPLE_RATES.length; i++) {\n                if (SAMPLE_RATES[i] === this.config.sampleRate) {\n                    this.config.sampleIndex = i;\n                    break;\n                }\n            }\n        } else {\n            this.config.sampleRate = 48000//SAMPLE_RATES[this.config.sampleIndex];\n        }\n            \n        this.config.chanConfig = stream.read(4);\n        this.format.channelsPerFrame = this.config.chanConfig; // sometimes m4a files encode this wrong\n        \n        switch (this.config.profile) {\n            case AOT_AAC_MAIN:\n            case AOT_AAC_LC:\n            case AOT_AAC_LTP:\n                if (stream.read(1)) // frameLengthFlag\n                    throw new Error('frameLengthFlag not supported');\n                    \n                this.config.frameLength = 1024;\n                    \n                if (stream.read(1)) // dependsOnCoreCoder\n                    stream.advance(14); // coreCoderDelay\n                    \n                if (stream.read(1)) { // extensionFlag\n                    if (this.config.profile > 16) { // error resiliant profile\n                        this.config.sectionDataResilience = stream.read(1);\n                        this.config.scalefactorResilience = stream.read(1);\n                        this.config.spectralDataResilience = stream.read(1);\n                    }\n                    \n                    stream.advance(1);\n                }\n                \n                if (this.config.chanConfig === CHANNEL_CONFIG_NONE) {\n                    stream.advance(4) // element_instance_tag\n                    throw new Error('PCE unimplemented');\n                }\n                \n                break;\n                \n            default:\n                throw new Error('AAC profile ' + this.config.profile + ' not supported.');\n        }\n        \n        this.filter_bank = new FilterBank(false, this.config.chanConfig);        \n        this.ics = new ICStream(this.config);\n        this.cpe = new CPEElement(this.config);\n        this.cce = new CCEElement(this.config);\n    };\n    \n    const SCE_ELEMENT = 0,\n          CPE_ELEMENT = 1,\n          CCE_ELEMENT = 2,\n          LFE_ELEMENT = 3,\n          DSE_ELEMENT = 4,\n          PCE_ELEMENT = 5,\n          FIL_ELEMENT = 6,\n          END_ELEMENT = 7;\n    \n    // The main decoding function.\n    this.prototype.readChunk = function() {\n        var stream = this.bitstream;\n        \n        // check if there is an ADTS header, and read it if so\n        if (stream.peek(12) === 0xfff)\n            ADTSDemuxer.readHeader(stream);\n        \n        this.cces = [];\n        var elements = [],\n            config = this.config,\n            frameLength = config.frameLength,\n            elementType = null;\n\n        while ((elementType = stream.read(3)) !== END_ELEMENT) {\n            var id = stream.read(4);\n            \n            switch (elementType) {\n                // single channel and low frequency elements\n                case SCE_ELEMENT:\n                case LFE_ELEMENT:\n                    var ics = this.ics;\n                    ics.id = id;\n                    elements.push(ics);\n                    ics.decode(stream, config, false);\n                    break;\n                    \n                // channel pair element\n                case CPE_ELEMENT:\n                    var cpe = this.cpe;\n                    cpe.id = id;\n                    elements.push(cpe);\n                    cpe.decode(stream, config);\n                    break;\n                \n                // channel coupling element\n                case CCE_ELEMENT:\n                    var cce = this.cce;\n                    this.cces.push(cce);\n                    cce.decode(stream, config);\n                    break;\n                    \n                // data-stream element\n                case DSE_ELEMENT:\n                    var align = stream.read(1),\n                        count = stream.read(8);\n                        \n                    if (count === 255)\n                        count += stream.read(8);\n                        \n                    if (align)\n                        stream.align();\n                        \n                    // skip for now...\n                    stream.advance(count * 8);\n                    break;\n                    \n                // program configuration element\n                case PCE_ELEMENT:\n                    throw new Error(\"TODO: PCE_ELEMENT\")\n                    break;\n                    \n                // filler element\n                case FIL_ELEMENT:\n                    if (id === 15)\n                        id += stream.read(8) - 1;\n                        \n                    // skip for now...\n                    stream.advance(id * 8);\n                    break;\n                    \n                default:\n                    throw new Error('Unknown element')\n            }\n        }\n        \n        stream.align();\n        this.process(elements);\n        // Interleave channels\n        var data = this.data,\n            channels = data.length,\n            output = new Int16Array(frameLength * channels),\n            j = 0;\n            \n        for (var k = 0; k < frameLength; k++) {\n            for (var i = 0; i < channels; i++) {\n                data[i][k] = Math.max(Math.min(data[i][k], 32767), -32768) / 1000;\n            }\n        }\n        return data\n//        return output;\n    };\n    \n    this.prototype.process = function(elements) {\n        var channels = this.config.chanConfig;\n        \n        // if (channels === 1 && psPresent)\n        // TODO: sbrPresent (2)\n        var mult = 1;\n        \n        var len = mult * this.config.frameLength;\n        var data = this.data = [];\n        \n        // Initialize channels\n        for (var i = 0; i < channels; i++) {\n            data[i] = new Float32Array(len);\n        }\n        \n        var channel = 0;\n        for (var i = 0; i < elements.length && channel < channels; i++) {\n            var e = elements[i];\n            \n            if (e instanceof ICStream) { // SCE or LFE element\n                channel += this.processSingle(e, channel);\n            } else if (e instanceof CPEElement) {\n                this.processPair(e, channel);\n                channel += 2;\n            } else if (e instanceof CCEElement) {\n                channel++;\n            } else {\n                throw new Error(\"Unknown element found.\")\n            }\n        }\n    };\n    \n    this.prototype.processSingle = function(element, channel) {\n        var profile = this.config.profile,\n            info = element.info,\n            data = element.data;\n            \n        if (profile === AOT_AAC_MAIN)\n            throw new Error(\"Main prediction unimplemented\");\n            \n        if (profile === AOT_AAC_LTP)\n            throw new Error(\"LTP prediction unimplemented\");\n            \n        this.applyChannelCoupling(element, CCEElement.BEFORE_TNS, data, null);\n        \n        if (element.tnsPresent)\n            element.tns.process(element, data, false);\n            \n        this.applyChannelCoupling(element, CCEElement.AFTER_TNS, data, null);\n        \n        // filterbank\n        this.filter_bank.process(info, data, this.data[channel], channel);\n        \n        if (profile === AOT_AAC_LTP)\n            throw new Error(\"LTP prediction unimplemented\");\n        \n        this.applyChannelCoupling(element, CCEElement.AFTER_IMDCT, this.data[channel], null);\n        \n        if (element.gainPresent)\n            throw new Error(\"Gain control not implemented\");\n            \n        if (this.sbrPresent)\n            throw new Error(\"SBR not implemented\");\n            \n        return 1;\n    };\n    \n    this.prototype.processPair = function(element, channel) {\n        var profile = this.config.profile,\n            left = element.left,\n            right = element.right,\n            l_info = left.info,\n            r_info = right.info,\n            l_data = left.data,\n            r_data = right.data;\n            \n        // Mid-side stereo\n        if (element.commonWindow && element.maskPresent)\n            this.processMS(element, l_data, r_data);\n            \n        if (profile === AOT_AAC_MAIN)\n            throw new Error(\"Main prediction unimplemented\");\n        \n        // Intensity stereo    \n        this.processIS(element, l_data, r_data);\n            \n        if (profile === AOT_AAC_LTP)\n            throw new Error(\"LTP prediction unimplemented\");\n            \n        this.applyChannelCoupling(element, CCEElement.BEFORE_TNS, l_data, r_data);\n        \n        if (left.tnsPresent)\n            left.tns.process(left, l_data, false);\n            \n        if (right.tnsPresent)\n            right.tns.process(right, r_data, false);\n        \n        this.applyChannelCoupling(element, CCEElement.AFTER_TNS, l_data, r_data);\n        \n        // filterbank\n        this.filter_bank.process(l_info, l_data, this.data[channel], channel);\n        this.filter_bank.process(r_info, r_data, this.data[channel + 1], channel + 1);\n        \n        if (profile === AOT_AAC_LTP)\n            throw new Error(\"LTP prediction unimplemented\");\n        \n        this.applyChannelCoupling(element, CCEElement.AFTER_IMDCT, this.data[channel], this.data[channel + 1]);\n        \n        if (left.gainPresent)\n            throw new Error(\"Gain control not implemented\");\n            \n        if (right.gainPresent)\n            throw new Error(\"Gain control not implemented\");\n            \n        if (this.sbrPresent)\n            throw new Error(\"SBR not implemented\");\n    };\n    \n    // Intensity stereo\n    this.prototype.processIS = function(element, left, right) {\n        var ics = element.right,\n            info = ics.info,\n            offsets = info.swbOffsets,\n            windowGroups = info.groupCount,\n            maxSFB = info.maxSFB,\n            bandTypes = ics.bandTypes,\n            sectEnd = ics.sectEnd,\n            scaleFactors = ics.scaleFactors;\n        \n        var idx = 0, groupOff = 0;\n        for (var g = 0; g < windowGroups; g++) {\n            for (var i = 0; i < maxSFB;) {\n                var end = sectEnd[idx];\n                \n                if (bandTypes[idx] === ICStream.INTENSITY_BT || bandTypes[idx] === ICStream.INTENSITY_BT2) {\n                    for (; i < end; i++, idx++) {\n                        var c = bandTypes[idx] === ICStream.INTENSITY_BT ? 1 : -1;\n                        if (element.maskPresent)\n                            c *= element.ms_used[idx] ? -1 : 1;\n                            \n                        var scale = c * scaleFactors[idx];\n                        for (var w = 0; w < info.groupLength[g]; w++) {\n                            var off = groupOff + w * 128 + offsets[i],\n                                len = offsets[i + 1] - offsets[i];\n                                \n                            for (var j = 0; j < len; j++) {\n                                right[off + j] = left[off + j] * scale;\n                            }\n                        }\n                    }\n                } else  {\n                    idx += end - i;\n                    i = end;\n                }\n            }\n            \n            groupOff += info.groupLength[g] * 128;\n        }\n    };\n    \n    // Mid-side stereo\n    this.prototype.processMS = function(element, left, right) {\n        var ics = element.left,\n            info = ics.info,\n            offsets = info.swbOffsets,\n            windowGroups = info.groupCount,\n            maxSFB = info.maxSFB,\n            sfbCBl = ics.bandTypes,\n            sfbCBr = element.right.bandTypes;\n            \n        var groupOff = 0, idx = 0;\n        for (var g = 0; g < windowGroups; g++) {\n            for (var i = 0; i < maxSFB; i++, idx++) {\n                if (element.ms_used[idx] && sfbCBl[idx] < ICStream.NOISE_BT && sfbCBr[idx] < ICStream.NOISE_BT) {\n                    for (var w = 0; w < info.groupLength[g]; w++) {\n                        var off = groupOff + w * 128 + offsets[i];\n                        for (var j = 0; j < offsets[i + 1] - offsets[i]; j++) {\n                            var t = left[off + j] - right[off + j];\n                            left[off + j] += right[off + j];\n                            right[off + j] = t;\n                        }\n                    }\n                }\n            }\n            groupOff += info.groupLength[g] * 128;\n        }\n    };\n    \n    this.prototype.applyChannelCoupling = function(element, couplingPoint, data1, data2) {\n        var cces = this.cces,\n            isChannelPair = element instanceof CPEElement,\n            applyCoupling = couplingPoint === CCEElement.AFTER_IMDCT ? 'applyIndependentCoupling' : 'applyDependentCoupling';\n        \n        for (var i = 0; i < cces.length; i++) {\n            var cce = cces[i],\n                index = 0;\n                \n            if (cce.couplingPoint === couplingPoint) {\n                for (var c = 0; c < cce.coupledCount; c++) {\n                    var chSelect = cce.chSelect[c];\n                    if (cce.channelPair[c] === isChannelPair && cce.idSelect[c] === element.id) {\n                        if (chSelect !== 1) {\n                            cce[applyCoupling](index, data1);\n                            if (chSelect) index++;\n                        }\n                        \n                        if (chSelect !== 2)\n                            cce[applyCoupling](index++, data2);\n                            \n                    } else {\n                        index += 1 + (chSelect === 3 ? 1 : 0);\n                    }\n                }\n            }\n        }\n    };\n    \n});\n\n})();\n";

var code = aurora + aac + worker;

var slave = undefined 
var id = 0;

module.exports = function(master, uri, cb){
    var master = master;
    var source = Object.create(null);
    var slave = slave || enslave(code);

    slave.postMessage({id: id++, uri: uri, sampleRate: master.sampleRate});

    slave.onmessage = function(evt){
	if(evt.data.type == 'meta'){

	    var data = evt.data.data;
	    source.data = data;
	    source.buffers = new Array(data.channelsPerFrame);

	    for(var x = 0; x < source.buffers.length; x++){
		source.buffers[x] = buffers(6);
	    }

	    var startTime = new Date().getTime();

	    var bufSize = 256 * 2 * 2 * 2 * 2 * 2;

	    var synth = master.createScriptProcessor(bufSize, data.channelsPerFrame, data.channelsPerFrame);
	    synth.bufSize = bufSize;
	    synth.bufIndex = 0;
	    synth.id = id;
	    synth.currentTime = function(t){// t in seconds
		synth.bufIndex = t * master.sampleRate
	    };

	    synth.onaudioprocess = function(evt){
		var outputBuffer = event.outputBuffer;
		var channelCount = outputBuffer.numberOfChannels;
		var channels = new Array(channelCount);
		for (i = _i = 0; _i < channelCount; i = _i += 1) {
		    channels[i] = outputBuffer.getChannelData(i);
		}
		for(var x = 0; x < channels.length; x++){
		    channels[x].set(source.buffers[x].slice(this.bufIndex, this.bufIndex + this.bufSize));
		}
		this.bufIndex+=this.bufSize
	    };

	    cb(null, synth)

	}
	else if(evt.data.type == 'end'){

//	    alert((new Date().getTime() - startTime) / 1000)
	}
	else if(evt.data.type == 'progress'){
	    console.log(evt.data.data);
	}
	else {
	    var wsb = source.buffers;
	    for(x in evt.data.buffer){
		wsb[x].push(evt.data.buffer[x]);
	    }
	}
    }


}


})()
},{"./floatConcat.js":7,"buffers":12,"fs":31,"work-slave":28}],9:[function(require,module,exports){
module.exports = function(css, id){
    var es = document.getElementById(id);

    if(es){
	return false
//	es.parentNode.insertBefore(makeStyle(css), es.nextSibling)
    }
    else{
	var styleSheet = makeStyle(css, id)
	document.head.insertBefore(styleSheet, document.head.childNodes[0]);
	return styleSheet
    }

}


function makeStyle(str, id){
    var style = document.createElement('style');
    style.id = id || '';
    style.textContent = str;
    return style
}

},{}],10:[function(require,module,exports){
var getCSS = require('./getCSS');

module.exports = function(el){
    
    el.style['-webkit-box-sizing'] = 'border-box'
    el.parentElement.style['-webkit-box-sizing'] = 'border-box'
    el.style['box-sizing'] = 'border-box'
    el.parentElement.style['box-sizing'] = 'border-box'

    var w = getCSS(el, 'width').primitive.val
    ,   h = getCSS(el, 'height').primitive.val
    ;
    
    var pw = getCSS(el.parentElement, 'width').primitive.val
    ,   ph = getCSS(el.parentElement, 'height').primitive.val
    ;

    var dw = pw - w
    ,   dh = ph - h
    ;
    
    el.style.position = 'absolute';
    el.style['top'] = dh/2 + 'px';
    el.style['left'] = dw/2 + 'px';

}

},{"./getCSS":11}],11:[function(require,module,exports){
module.exports = function(el, param){

    var propValue = window.getComputedStyle(el).getPropertyCSSValue(param)
		if(!propValue) throw new Error("No prop valueValue. Is the element appended to the document yet?")
		if(!propValue) return false
    var valueType = '';
		for(var b in propValue.__proto__){
			if(propValue.__proto__[b] == propValue.cssValueType) {
				valueType = b;
				break;
			}
		};


    switch(valueType.toLowerCase()){
    case 'cssvaluelist':
	var l = propValue.length;
        var obj = {};
	obj.type = 'cssPrimitiveValue'
	obj.value = Array.prototype.slice.call(propValue).map(function(x){ return CSSGetPrimitiveValue(x)});
        return obj;
	break;
    case 'cssprimitivevalue':
	return {type: 'cssPrimitiveValue', value : CSSGetPrimitiveValue(propValue)};
	break;
    case 'svgpaint':
	return {type: 'SVGPaint', value : CSSGetPrimitiveValue(propValue)};
	break;
	 default:
	return {type: 'cssValue', primitive: CSSGetPrimitiveValue(propValue), value : {unit: '', type: propValue.cssValueType, val: propValue.cssText}};
	break;
    }

};

function CSSGetPrimitiveValue(value) {
		try {

				var valueType = value.primitiveType;

			  if (CSSPrimitiveValue.CSS_PX == valueType) {
					return {class: CSSPrimitiveValue.CSS_PX, unit : 'px', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (valueType == CSSPrimitiveValue.CSS_NUMBER) {
					return {class: CSSPrimitiveValue.CSS_NUMBER, unit : '', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (valueType == CSSPrimitiveValue.CSS_PERCENTAGE) {
					return {class: CSSPrimitiveValue.CSS_PERCENTAGE, unit : '%', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_EMS == valueType) {
					return {class: CSSPrimitiveValue.CSS_EMS, unit : 'em', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_CM == valueType) {
					return {class: CSSPrimitiveValue.CSS_CM, unit : 'cm', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_IDENT == valueType) {
					return {class: CSSPrimitiveValue.CSS_IDENT, unit : '', type: 'string', val : value.getStringValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_EXS == valueType) {
					return {class: CSSPrimitiveValue.CSS_EXS, unit : 'ex', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_IN == valueType) {
					return {class: CSSPrimitiveValue.CSS_IN, unit : 'in', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_MM == valueType) {
					return {class: CSSPrimitiveValue.CSS_MM, unit : 'mm', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_PC == valueType) {
					return {class: CSSPrimitiveValue.CSS_PC, unit : 'pc', type: 'float', val : value.getFloatValue (valueType)};
			  }

			  if (CSSPrimitiveValue.CSS_PT == valueType) {
					return {class: CSSPrimitiveValue.CSS_PT, unit : 'pt', type: 'float', val : value.getFloatValue (valueType)};
			  }

			 	if (valueType == CSSPrimitiveValue.CSS_DIMENSION){
					return {class: CSSPrimitiveValue.CSS_DIMENSION, unit : '', type: 'float', val : value.getFloatValue (valueType)};
				}

			  if (CSSPrimitiveValue.CSS_STRING <= valueType && valueType <= CSSPrimitiveValue.CSS_ATTR) {
			     return {unit : '', type: 'string', val: value.getStringValue (valueType)};
			  }

			  if (valueType == CSSPrimitiveValue.CSS_COUNTER) {
			    var counterValue = value.getCounterValue ();
					return {
						class: CSSPrimitiveValue.CSS_COUNTER,
						unit: '',
						type: 'counter',
						val : {
							identifier: counterValue.identifier,
							listStyle: counterValue.listStyle,
							separator: counterValue.separator
						}};
			   }

			   if (valueType == CSSPrimitiveValue.CSS_RECT) {
			      var rect = value.getRectValue ()
			       	,	topPX = rect.top.getFloatValue (CSSPrimitiveValue.CSS_PX)
			       	,	rightPX = rect.right.getFloatValue (CSSPrimitiveValue.CSS_PX)
			       	,	bottomPX = rect.bottom.getFloatValue (CSSPrimitiveValue.CSS_PX)
			       	,	leftPX = rect.left.getFloatValue (CSSPrimitiveValue.CSS_PX)
						;
						return {
							class: CSSPrimitiveValue.CSS_RECT,
							unit: 'px',
							type: 'rect',
							val: {
								top: topPX,
								right: rightPX,
								bottom: bottomPX,
								left: leftPX
							}};
			   }

			   if (valueType == CSSPrimitiveValue.CSS_RGBCOLOR) {
			      var rgb = value.getRGBColorValue ()
			       	,	r = rgb.red.getFloatValue (CSSPrimitiveValue.CSS_NUMBER)
			       	,	g = rgb.green.getFloatValue (CSSPrimitiveValue.CSS_NUMBER)
			       	, b = rgb.blue.getFloatValue (CSSPrimitiveValue.CSS_NUMBER)
						;

						return {
							class: CSSPrimitiveValue.CSS_RGBCOLOR,
							unit: '',
							type: 'rgb',
							val: {
								r: r,
								g: g,
								b: b,
							}};
			   }

				if (CSSPrimitiveValue.CSS_GRAD == valueType >= CSSPrimitiveValue.CSS_DEG ) {
					return {class: CSSPrimitiveValue.CSS_GRAD, unit : 'grad', type: 'angle', val : value.getFloatValue (valueType)};
				}

				if(valueType == CSSPrimitiveValue.CSS_DEG) {
					return {class: CSSPrimitiveValue.CSS_DEG, unit : 'deg', type: 'angle', val : value.getFloatValue (valueType)};
				}

				if(valueType == CSSPrimitiveValue.CSS_RAD) {
					return {class: CSSPrimitiveValue.CSS_RAD, unit : 'radian', type: 'angle', val : value.getFloatValue (valueType)};
				}

				if(CSSPrimitiveValue.CSS_S == valueType ) {
					return {class: CSSPrimitiveValue.CSS_S, unit : '', type: 'time', val : value.getFloatValue (valueType)};
				}

				if(valueType == CSSPrimitiveValue.CSS_MS ) {
					return {class: CSSPrimitiveValue.CSS_MS, unit : '', type: 'time', val : value.getFloatValue (valueType)};
				}

				if(!valueType) {
					return {class: undefined, unit : '', type: 'unknown', val : value.cssText};
				}

			return {class: undefined, unit : '', type: 'unknown', val : value.cssText};

		}

		catch (Err){	   
			return {class: 'unknown', unit : '', type: value.propValue.__proto__.constructor.name, val : value.cssText};
		}
};

},{}],12:[function(require,module,exports){
(function(){var Buffer = Buffer;

var types = [
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Float32Array,
    Float64Array
];

module.exports = Buffers;

function Buffers (bufs, type) {
    if (!(this instanceof Buffers)) return new Buffers(bufs);
    if ((!type && (!isNaN(bufs))) || !isNaN(type)) {
	type = bufs;
	bufs = null;
	Buffer = types[type]
	this.isNotANodeBuffer = true;

    };
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function (size, buf) {
        return size + buf.length
    }, 0);
}


Buffers.prototype.push = function () {    

    for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
    }
    return this.length;
};

Buffers.prototype.unshift = function () {

    
    for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
    }
    return this.length;
};

Buffers.prototype.copy = function (dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
};

Buffers.prototype.splice = function (i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    
    if (howMany === undefined) {
        howMany = this.length - index;
    }
    else if (howMany > this.length - index) {
        howMany = this.length - index;
    }
    
    for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
    }
    
    var removed = new Buffers();
    var bytes = 0;
    
    var startBytes = 0;
    for (
        var ii = 0;
        ii < buffers.length && startBytes + buffers[ii].length < index;
        ii ++
    ) { startBytes += buffers[ii].length }
    
    if (index - startBytes > 0) {
        var start = index - startBytes;
        
        if (start + howMany < buffers[ii].length) {
            removed.push(buffers[ii].slice(start, start + howMany));
            
            var orig = buffers[ii];
            //var buf = new Buffer(orig.length - howMany);
            var buf0 = new Buffer(start);
            for (var i = 0; i < start; i++) {
                buf0[i] = orig[i];
            }
            
            var buf1 = new Buffer(orig.length - start - howMany);
            for (var i = start + howMany; i < orig.length; i++) {
                buf1[ i - howMany - start ] = orig[i]
            }
            
            if (reps.length > 0) {
                var reps_ = reps.slice();
                reps_.unshift(buf0);
                reps_.push(buf1);
                buffers.splice.apply(buffers, [ ii, 1 ].concat(reps_));
                ii += reps_.length;
                reps = [];
            }
            else {
                buffers.splice(ii, 1, buf0, buf1);
                //buffers[ii] = buf;
                ii += 2;
            }
        }
        else {
            removed.push(buffers[ii].slice(start));
            buffers[ii] = buffers[ii].slice(0, start);
            ii ++;
        }
    }
    
    if (reps.length > 0) {
        buffers.splice.apply(buffers, [ ii, 0 ].concat(reps));
        ii += reps.length;
    }
    
    while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        
        if (take === len) {
            removed.push(buf);
            buffers.splice(ii, 1);
        }
        else {
            removed.push(buf.slice(0, take));
            buffers[ii] = buffers[ii].slice(take);
        }
    }
    
    this.length -= removed.length;
    
    return removed;
};
 
Buffers.prototype.slice = function (i, j) {
    var buffers = this.buffers;
    if (j === undefined) j = this.length;
    if (i === undefined) i = 0;
    
    if (j > this.length) j = this.length;
    
    var startBytes = 0;
    for (
        var si = 0;
        si < buffers.length && startBytes + buffers[si].length <= i;
        si ++
    ) { startBytes += buffers[si].length }
    
    var target = new Buffer(j - i);
    
    var ti = 0;
    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i
            ? Math.min(start + (j - i) - ti, len)
            : len
        ;

	if(this.isNotANodeBuffer) target.set(buffers[ii].subarray(start, end), ti);

        else buffers[ii].copy(target, ti, start, end);

        ti += end - start;

    }
    
    return target;
};

Buffers.prototype.pos = function (i) {
    if (i < 0 || i >= this.length) throw new Error('oob');
    var l = i, bi = 0, bu = null;
    for (;;) {
        bu = this.buffers[bi];
        if (l < bu.length) {
            return {buf: bi, offset: l};
        } else {
            l -= bu.length;
        }
        bi++;
    }
};

Buffers.prototype.get = function get (i) {
    var pos = this.pos(i);
    if(this.isNotANodeBuffer) return this.buffers[pos.buf][pos.offset]
    else return this.buffers[pos.buf].get(pos.offset);
};

Buffers.prototype.set = function set (i, b) {
    var pos = this.pos(i);
    if(this.isNotANodeBuffer) return this.buffers[pos.buf][pos.offset] = b
    else return this.buffers[pos.buf].set(pos.offset, b);
};

Buffers.prototype.indexOf = function (needle, offset) {
    if ("string" === typeof needle) {
        needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {
        // already a buffer
    } else {
        throw new Error('Invalid type for a search string');
    }

    if (!needle.length) {
        return 0;
    }

    if (!this.length) {
        return -1;
    }

    var i = 0, j = 0, match = 0, mstart, pos = 0;

    // start search from a particular point in the virtual buffer
    if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
    }

    // for each character in virtual buffer
    for (;;) {
        while (j >= this.buffers[i].length) {
            j = 0;
            i++;

            if (i >= this.buffers.length) {
                // search string not found
                return -1;
            }
        }

        var char = this.buffers[i][j];

        if (char == needle[match]) {
            // keep track where match started
            if (match == 0) {
                mstart = {
                    i: i,
                    j: j,
                    pos: pos
                };
            }
            match++;
            if (match == needle.length) {
                // full match
                return mstart.pos;
            }
        } else if (match != 0) {
            // a partial match ended, go back to match starting position
            // this will continue the search at the next character
            i = mstart.i;
            j = mstart.j;
            pos = mstart.pos;
            match = 0;
        }

        j++;
        pos++;
    }
};

Buffers.prototype.toBuffer = function() {
    return this.slice();
}

Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
}

})()
},{}],13:[function(require,module,exports){
(function(process,Buffer){var url = require('url');
var http = require('http');
var https = require('https');
var through = require('through');
var duplexer = require('duplexer');
var Stream = require('stream');

module.exports = hyperquest;

function bind (obj, fn) {
  var args = Array.prototype.slice.call(arguments, 2);
  return function () {
    args = args.concat(Array.prototype.slice.call(arguments));
    return fn.apply(obj, args);
  }
}

function hyperquest (uri, opts, cb, extra) {
    if (typeof uri === 'object') {
        cb = opts;
        opts = uri;
        uri = undefined;
    }
    if (typeof opts === 'function') {
      cb = opts;
      opts = undefined;
    }
    if (!opts) opts = {};
    if (uri !== undefined) opts.uri = uri;
    if (extra) opts.method = extra.method;
    
    var req = new Req(opts);
    var ws = req.duplex && through();
    if (ws) ws.pause();
    var rs = through();
    
    var dup = req.duplex ? duplexer(ws, rs) : rs;
    if (!req.duplex) {
        rs.writable = false;
    }
    dup.request = req;
    dup.setHeader = bind(req, req.setHeader);
    dup.setLocation = bind(req, req.setLocation);
    
    var closed = false;
    dup.on('close', function () { closed = true });
    
    process.nextTick(function () {
        if (closed) return;
        dup.on('close', function () { r.destroy() });
        
        var r = req._send();
        r.on('error', bind(dup, dup.emit, 'error'));
        
        r.on('response', function (res) {
            dup.response = res;
            dup.emit('response', res);
            if (req.duplex) res.pipe(rs)
            else {
                res.on('data', function (buf) { rs.queue(buf) });
                res.on('end', function () { rs.queue(null) });
            }
        });
        
        if (req.duplex) {
            ws.pipe(r);
            ws.resume();
        }
        else r.end();
    });
    
    if (cb) {
        dup.on('error', cb);
        dup.on('response', bind(dup, cb, null));
    }
    return dup;
}

hyperquest.get = hyperquest;

hyperquest.post = function (uri, opts, cb) {
    return hyperquest(uri, opts, cb, { method: 'POST' });
};

hyperquest.put = function (uri, opts, cb) {
    return hyperquest(uri, opts, cb, { method: 'PUT' });
};

hyperquest['delete'] = function (uri, opts, cb) {
    return hyperquest(uri, opts, cb, { method: 'DELETE' });
};

function Req (opts) {
    this.headers = opts.headers || {};
    
    var method = (opts.method || 'GET').toUpperCase();
    this.method = method;
    this.duplex = !(method === 'GET' || method === 'DELETE');
    this.auth = opts.auth;
    
    if (opts.uri) this.setLocation(opts.uri);
}

Req.prototype._send = function () {
    this._sent = true;
    
    var headers = this.headers || {};
    var u = url.parse(this.uri);
    var au = u.auth || this.auth;
    if (au) {
        headers.authorization = 'Basic ' + Buffer(au).toString('base64');
    }
    
    var interface = (u.protocol === 'https:') ? https : http;
    var req = interface.request({
        method: this.method,
        host: u.hostname,
        port: Number(u.port),
        path: u.path,
        agent: false,
        headers: headers
    });
    
    if (req.setTimeout) req.setTimeout(Math.pow(2, 32) * 1000);
    return req;
};

Req.prototype.setHeader = function (key, value) {
    if (this._sent) throw new Error('request already sent');
    this.headers[key] = value;
    return this;
};

Req.prototype.setLocation = function (uri) {
    this.uri = uri;
    return this;
};

})(require("__browserify_process"),require("__browserify_Buffer").Buffer)
},{"__browserify_Buffer":48,"__browserify_process":49,"duplexer":14,"http":44,"https":32,"stream":34,"through":15,"url":35}],14:[function(require,module,exports){
var Stream = require("stream")
    , writeMethods = ["write", "end", "destroy"]
    , readMethods = ["resume", "pause"]
    , readEvents = ["data", "close"]
    , slice = Array.prototype.slice

module.exports = duplex

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function duplex(writer, reader) {
    var stream = new Stream()
        , ended = false

    forEach(writeMethods, proxyWriter)

    forEach(readMethods, proxyReader)

    forEach(readEvents, proxyStream)

    reader.on("end", handleEnd)

    writer.on("drain", function() {
      stream.emit("drain")
    })

    writer.on("error", reemit)
    reader.on("error", reemit)

    stream.writable = writer.writable
    stream.readable = reader.readable

    return stream

    function proxyWriter(methodName) {
        stream[methodName] = method

        function method() {
            return writer[methodName].apply(writer, arguments)
        }
    }

    function proxyReader(methodName) {
        stream[methodName] = method

        function method() {
            stream.emit(methodName)
            var func = reader[methodName]
            if (func) {
                return func.apply(reader, arguments)
            }
            reader.emit(methodName)
        }
    }

    function proxyStream(methodName) {
        reader.on(methodName, reemit)

        function reemit() {
            var args = slice.call(arguments)
            args.unshift(methodName)
            stream.emit.apply(stream, args)
        }
    }

    function handleEnd() {
        if (ended) {
            return
        }
        ended = true
        var args = slice.call(arguments)
        args.unshift("end")
        stream.emit.apply(stream, args)
    }

    function reemit(err) {
        stream.emit("error", err)
    }
}

},{"stream":34}],15:[function(require,module,exports){
(function(process){var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)



exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = []
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    stream.emit('pause')
    return stream
  }
  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


})(require("__browserify_process"))
},{"__browserify_process":49,"stream":34}],16:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')
var DataSet = require('data-set')

module.exports = h

function h() {
  var args = [].slice.call(arguments), e = null
  function item (l) {
    var r
    function parseClass (string) {
      var m = split(string, /([\.#]?[a-zA-Z0-9_-]+)/)
      forEach(m, function (v) {
        var s = v.substring(1,v.length)
        if(!v) return
        if(!e)
          e = document.createElement(v)
        else if (v[0] === '.')
          ClassList(e).add(s)
        else if (v[0] === '#')
          e.setAttribute('id', s)
      })
    }

    if(l == null)
      ;
    else if('string' === typeof l) {
      if(!e)
        parseClass(l)
      else
        e.appendChild(r = document.createTextNode(l))
    }
    else if('number' === typeof l
      || 'boolean' === typeof l
      || l instanceof Date
      || l instanceof RegExp ) {
        e.appendChild(r = document.createTextNode(l.toString()))
    }
    //there might be a better way to handle this...
    else if (isArray(l))
      forEach(l, item)
    else if(isNode(l))
      e.appendChild(r = l)
    else if(l instanceof Text)
      e.appendChild(r = l)
    else if ('object' === typeof l) {
      for (var k in l) {
        if('function' === typeof l[k]) {
          if(/^on\w+/.test(k)) {
            e.addEventListener
              ? e.addEventListener(k.substring(2), l[k])
              : e.attachEvent(k, l[k])
          } else {
            e[k] = l[k]()
            l[k](function (v) {
              e[k] = v
            })
          }
        }
        else if(k === 'style') {
          for (var s in l[k]) (function(s, v) {
            if('function' === typeof v) {
              e.style.setProperty(s, v())
              v(function (val) {
                e.style.setProperty(s, val)
              })
            } else
              e.style.setProperty(s, l[k][s])
          })(s, l[k][s])
        } else if (k.substr(0, 5) === "data-") {
          DataSet(e)[k.substr(5)] = l[k]
        } else {
          e[k] = l[k]
        }
      }
    } else if ('function' === typeof l) {
      //assume it's an observable!
      var v = l()
      e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

      l(function (v) {
        if(isNode(v) && r.parentElement)
          r.parentElement.replaceChild(v, r), r = v
        else
          r.textContent = v
      })

    }

    return r
  }
  while(args.length)
    item(args.shift())

  return e
}

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}

},{"browser-split":17,"class-list":18,"data-set":19}],17:[function(require,module,exports){
(function(){/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

})()
},{}],18:[function(require,module,exports){
// contains, add, remove, toggle

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (list.indexOf(token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = list.indexOf(token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return getTokens().indexOf(token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{}],19:[function(require,module,exports){
var Weakmap = require("weakmap")
var Individual = require("individual")

var datasetMap = Individual("__DATA_SET_WEAKMAP", Weakmap())

module.exports = DataSet

function DataSet(elem) {
    if (elem.dataset) {
        return elem.dataset
    }

    var hash = datasetMap.get(elem)

    if (!hash) {
        hash = createHash(elem)
        datasetMap.set(elem, hash)
    }

    return hash
}

function createHash(elem) {
    var attributes = elem.attributes
    var hash = {}

    if (attributes === null || attributes === undefined) {
        return hash
    }

    for (var i = 0; i < attributes.length; i++) {
        var attr = attributes[i]

        if (attr.name.substr(0,5) !== "data-") {
            continue
        }

        hash[attr.name.substr(5)] = attr.value
    }

    return hash
}

},{"individual":20,"weakmap":22}],20:[function(require,module,exports){
(function(){var root = require("global")

module.exports = Individual

function Individual(key, value) {
    if (root[key]) {
        return root[key]
    }

    Object.defineProperty(root, key, {
        value: value
        , configurable: true
    })

    return value
}

})()
},{"global":21}],21:[function(require,module,exports){
(function(global){/*global window, global*/
if (typeof global !== "undefined") {
    module.exports = global
} else if (typeof window !== "undefined") {
    module.exports = window
}

})(self)
},{}],22:[function(require,module,exports){
(function(){/* (The MIT License)
 *
 * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the 'Software'), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included with all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991
// Updated and bugfixed by Raynos @ https://gist.github.com/1638059
// Expanded by Benvie @ https://github.com/Benvie/harmony-collections

void function(global, undefined_, undefined){
  var getProps = Object.getOwnPropertyNames,
      defProp  = Object.defineProperty,
      toSource = Function.prototype.toString,
      create   = Object.create,
      hasOwn   = Object.prototype.hasOwnProperty,
      funcName = /^\n?function\s?(\w*)?_?\(/;


  function define(object, key, value){
    if (typeof key === 'function') {
      value = key;
      key = nameOf(value).replace(/_$/, '');
    }
    return defProp(object, key, { configurable: true, writable: true, value: value });
  }

  function nameOf(func){
    return typeof func !== 'function'
          ? '' : 'name' in func
          ? func.name : toSource.call(func).match(funcName)[1];
  }

  // ############
  // ### Data ###
  // ############

  var Data = (function(){
    var dataDesc = { value: { writable: true, value: undefined } },
        datalock = 'return function(k){if(k===s)return l}',
        uids     = create(null),

        createUID = function(){
          var key = Math.random().toString(36).slice(2);
          return key in uids ? createUID() : uids[key] = key;
        },

        globalID = createUID(),

        storage = function(obj){
          if (hasOwn.call(obj, globalID))
            return obj[globalID];

          if (!Object.isExtensible(obj))
            throw new TypeError("Object must be extensible");

          var store = create(null);
          defProp(obj, globalID, { value: store });
          return store;
        };

    // common per-object storage area made visible by patching getOwnPropertyNames'
    define(Object, function getOwnPropertyNames(obj){
      var props = getProps(obj);
      if (hasOwn.call(obj, globalID))
        props.splice(props.indexOf(globalID), 1);
      return props;
    });

    function Data(){
      var puid = createUID(),
          secret = {};

      this.unlock = function(obj){
        var store = storage(obj);
        if (hasOwn.call(store, puid))
          return store[puid](secret);

        var data = create(null, dataDesc);
        defProp(store, puid, {
          value: new Function('s', 'l', datalock)(secret, data)
        });
        return data;
      }
    }

    define(Data.prototype, function get(o){ return this.unlock(o).value });
    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });

    return Data;
  }());


  var WM = (function(data){
    var validate = function(key){
      if (key == null || typeof key !== 'object' && typeof key !== 'function')
        throw new TypeError("Invalid WeakMap key");
    }

    var wrap = function(collection, value){
      var store = data.unlock(collection);
      if (store.value)
        throw new TypeError("Object is already a WeakMap");
      store.value = value;
    }

    var unwrap = function(collection){
      var storage = data.unlock(collection).value;
      if (!storage)
        throw new TypeError("WeakMap is not generic");
      return storage;
    }

    var initialize = function(weakmap, iterable){
      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {
        iterable.forEach(function(item, i){
          if (item instanceof Array && item.length === 2)
            set.call(weakmap, iterable[i][0], iterable[i][1]);
        });
      }
    }


    function WeakMap(iterable){
      if (this === global || this == null || this === WeakMap.prototype)
        return new WeakMap(iterable);

      wrap(this, new Data);
      initialize(this, iterable);
    }

    function get(key){
      validate(key);
      var value = unwrap(this).get(key);
      return value === undefined_ ? undefined : value;
    }

    function set(key, value){
      validate(key);
      // store a token for explicit undefined so that "has" works correctly
      unwrap(this).set(key, value === undefined ? undefined_ : value);
    }

    function has(key){
      validate(key);
      return unwrap(this).get(key) !== undefined;
    }

    function delete_(key){
      validate(key);
      var data = unwrap(this),
          had = data.get(key) !== undefined;
      data.set(key, undefined);
      return had;
    }

    function toString(){
      unwrap(this);
      return '[object WeakMap]';
    }

    try {
      var src = ('return '+delete_).replace('e_', '\\u0065'),
          del = new Function('unwrap', 'validate', src)(unwrap, validate);
    } catch (e) {
      var del = delete_;
    }

    var src = (''+Object).split('Object');
    var stringifier = function toString(){
      return src[0] + nameOf(this) + src[1];
    };

    define(stringifier, stringifier);

    var prep = { __proto__: [] } instanceof Array
      ? function(f){ f.__proto__ = stringifier }
      : function(f){ define(f, stringifier) };

    prep(WeakMap);

    [toString, get, set, has, del].forEach(function(method){
      define(WeakMap.prototype, method);
      prep(method);
    });

    return WeakMap;
  }(new Data));

  var defaultCreator = Object.create
    ? function(){ return Object.create(null) }
    : function(){ return {} };

  function createStorage(creator){
    var weakmap = new WM;
    creator || (creator = defaultCreator);

    function storage(object, value){
      if (value || arguments.length === 2) {
        weakmap.set(object, value);
      } else {
        value = weakmap.get(object);
        if (value === undefined) {
          value = creator(object);
          weakmap.set(object, value);
        }
      }
      return value;
    }

    return storage;
  }


  if (typeof module !== 'undefined') {
    module.exports = WM;
  } else if (typeof exports !== 'undefined') {
    exports.WeakMap = WM;
  } else if (!('WeakMap' in global)) {
    global.WeakMap = WM;
  }

  WM.createStorage = createStorage;
  if (global.WeakMap)
    global.WeakMap.createStorage = createStorage;
}((0, eval)('this'));

})()
},{}],23:[function(require,module,exports){
module.exports = inherits

function inherits (c, p, proto) {
  proto = proto || {}
  var e = {}
  ;[c.prototype, proto].forEach(function (s) {
    Object.getOwnPropertyNames(s).forEach(function (k) {
      e[k] = Object.getOwnPropertyDescriptor(s, k)
    })
  })
  c.prototype = Object.create(p.prototype, e)
  c.super = p
}

//function Child () {
//  Child.super.call(this)
//  console.error([this
//                ,this.constructor
//                ,this.constructor === Child
//                ,this.constructor.super === Parent
//                ,Object.getPrototypeOf(this) === Child.prototype
//                ,Object.getPrototypeOf(Object.getPrototypeOf(this))
//                 === Parent.prototype
//                ,this instanceof Child
//                ,this instanceof Parent])
//}
//function Parent () {}
//inherits(Child, Parent)
//new Child

},{}],24:[function(require,module,exports){
module.exports = function(node, fn){
	
	node.addEventListener('mouseover', onHover, true)
	
	node.addEventListener('mouseout', onExit, true)
	
	var node = node;
	
	var position = [0, 0];
	
	function mouseMove(evt){
	
		fn(evt, node, position, false, false)
	
	};
	
	function onExit(evt){
		
		window.removeEventListener('mousemove', mouseMove, true)
		
		fn(evt, node, position, false, true)
	};
	
	
	function onHover(evt){
		
		window.addEventListener('mousemove', mouseMove, true);
		
		position = findPos(evt.target);

		fn(evt, node, position, true, false)

		function findPos(obj) {

				var curleft = curtop = 0;

				if (obj.offsetParent) {

					do {

								curleft += obj.offsetLeft;

								curtop += obj.offsetTop;

							} 

					while (obj = obj.offsetParent);

					return [curleft,curtop];

				};
			};
	};
	
}
},{}],25:[function(require,module,exports){
(function(Buffer){//     uuid.js
//
//     (c) 2010-2012 Robert Kieffer
//     MIT License
//     https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (_global.define && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}());

})(require("__browserify_Buffer").Buffer)
},{"__browserify_Buffer":48,"crypto":40}],26:[function(require,module,exports){
var touchy = require('./touchy.js')
,   uuid = require('node-uuid')
;

module.exports = (function(){

  if(window._touch) return window._touch;

  else return new touch()

}());

function touch(){

  window._touch = this;

  this.elements = [];

  this.touchy = touchy(window, touchtest);

};

touch.prototype.start = touch.prototype.listen = function(el){

    if(!el.touch_id) el.touch_id = ('function' == typeof uuid.v1) ? uuid.v1() : uuid();

    this.elements.push(el);

    el.touch = 1;

};

touch.prototype.register = function(el){

    if(!el.touch_id) el.touch_id = uuid.v1();

    this.elements.push(el);

    el.touch = 0; // needs to be started

};


function touchtest(hand, finger){
	
	var lastPoint = [], allPoints = [];

  finger.on('start', function(point){
	
		var element = document.elementFromPoint(point.x, point.y);
			
    var el = search(element);

    if(el){
	
		  lastPoint = [point.x, point.y]
		
		  allPoints.push(lastPoint.slice(0))

      this.is = true;

      this.el = el;

      this.event.id = this.id;

      var evt = new CustomEvent('touchdown', { cancelable: true, bubbles: false, detail : point});
      
      el.dispatchEvent(evt);

    }

  });
 
  finger.on('move', function(point){

    if(this.is){
	
	
      var evt = new CustomEvent('deltavector', { cancelable: true, bubbles: false, detail : point});

			evt.detail.delta = [point.x - lastPoint[0], point.y - lastPoint[1]];

			evt.detail.vector = [point.x, point.y];

			evt.detail.allPoints = allPoints;
		
			evt.detail.lastPoint = lastPoint.splice(0)
						
			lastPoint = [point.x, point.y]
		
		  allPoints.push(lastPoint.slice())

      this.el.dispatchEvent(evt);

    }

  });

  finger.on('end', function(point){
 
    if(this.is){

      var evt = new CustomEvent('liftoff', { cancelable: true, bubbles: false, detail : point});

			evt.detail.delta = [point.x - lastPoint[0], point.y - lastPoint[1]];

			evt.detail.vector = [point.x, point.y];

			evt.detail.allPoints = allPoints;
		
			evt.detail.lastPoint = lastPoint.splice(0)
						
			lastPoint = [point.x, point.y]
		
		  allPoints.push(lastPoint.slice())

      this.el.dispatchEvent(evt);

    }

  });

};

function search(el){

  return scan(el)

  function scan(el){

    if(!el) return false;
  
    var x = window._touch.elements.reduce(function(val, i){	

      if(i.touch_id == el.touch_id && i.touch){

        val = i

      };

      return val

    }, false)

    return x || scan(el.parentElement)

  }

};


touch.prototype.pause = function(el){

  el.touch = 0

};

touch.prototype.resume = function(el){

  el.touch = 1

};

touch.prototype.end = function(el){

  delete el.touch

  delete el.touch_id

};

touch.prototype.handleMouse = function(x){

  if(Modernizr) Modernizr.touch = true;

  this.touchy.handleMouse(x);

};

},{"./touchy.js":27,"node-uuid":25}],27:[function(require,module,exports){
/* Modernizr 2.6.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-touch-teststyles-prefixes
 */
var Modernizr=function(a,b,c){function v(a){i.cssText=a}function w(a,b){return v(l.join(a+";")+(b||""))}function x(a,b){return typeof a===b}function y(a,b){return!!~(""+a).indexOf(b)}function z(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:x(f,"function")?f.bind(d||b):f}return!1}var d="2.6.2",e={},f=b.documentElement,g="modernizr",h=b.createElement(g),i=h.style,j,k={}.toString,l=" -webkit- -moz- -o- -ms- ".split(" "),m={},n={},o={},p=[],q=p.slice,r,s=function(a,c,d,e){var h,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:g+(d+1),l.appendChild(j);return h=["&#173;",'<style id="s',g,'">',a,"</style>"].join(""),l.id=g,(m?l:n).innerHTML+=h,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=f.style.overflow,f.style.overflow="hidden",f.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),f.style.overflow=k),!!i},t={}.hasOwnProperty,u;!x(t,"undefined")&&!x(t.call,"undefined")?u=function(a,b){return t.call(a,b)}:u=function(a,b){return b in a&&x(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=q.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(q.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(q.call(arguments)))};return e}),m.touch=function(){var c;return"ontouchstart"in a||a.DocumentTouch&&b instanceof DocumentTouch?c=!0:s(["@media (",l.join("touch-enabled),("),g,")","{#modernizr{top:9px;position:absolute}}"].join(""),function(a){c=a.offsetTop===9}),c};for(var A in m)u(m,A)&&(r=A.toLowerCase(),e[r]=m[A](),p.push((e[r]?"":"no-")+r));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)u(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof enableClasses!="undefined"&&enableClasses&&(f.className+=" "+(b?"":"no-")+a),e[a]=b}return e},v(""),h=j=null,e._version=d,e._prefixes=l,e.testStyles=s,e}(window,window.document);

/*
	Touchy.js
	Socket-style finger management for touch events

	Jairaj Sethi
	http://creativecommons.org/licenses/by/3.0/
*/



/* Make sure I can itereate through arrays */
var forEach = function () {
    if (Array.prototype.forEach) {
	return function (arr, callback, self) {
	    Array.prototype.forEach.call(arr, callback, self);
	};
    }

    else {
	return function (arr, callback, self) {
	    for (var i=0, len=arr.length; i<len; i++) {
		if (i in arr) {
		    callback.call(self, arr[i], i, arr);
		}
	    }
	};
    }
}();

/* Make sure I can search through arrays */
var indexOf = function () {
    if (Array.prototype.indexOf) {
	return function (arr, item, startIndex) {
	    return Array.prototype.indexOf.call(arr, item, startIndex);
	};
    }

    else {
	return function (arr, item, startIndex) {
	    for (var i=startIndex || 0, len=arr.length; i<len; i++) {
		if ((i in arr) && (arr[i] === item)) {
		    return i;
		}
	    }

	    return -1;
	};
    }
}();

/* Make sure I can map arrays */
var map = function () {
    if (Array.prototype.map) {
	return function (arr, callback, self) {
	    return Array.prototype.map.call(arr, callback, self);
	};
    }

    else {
	return function (arr, callback, self) {
	    var len = arr.length,
	    mapArr = new Array(len);

	    for (var i=0; i<len; i++) {
		if (i in arr) {
		    mapArr[i] = callback.call(self, arr[i], i, arr);
		}
	    }

	    return mapArr;
	};
    }
}();

/* Make sure I can filter arrays */
var filter = function () {
    if (Array.prototype.filter) {
	return function (arr, func, self) {
	    return Array.prototype.filter.call(arr, func, self);
	};
    }

    else {
	return function (arr, func, self) {
	    var filterArr = [];

	    for (var val, i=0, len=arr.length; i<len; i++) {
		val = arr[i];

		if ((i in arr) && func.call(self, val, i, arr)) {
		    filterArr.push(val);
		}
	    }

	    return filterArr;
	};
    }
}();

/* Bind event listener to element */
var boundEvents = {};

function bind (elem, eventName, callback) {
    if (elem.addEventListener) {
	elem.addEventListener(eventName, callback, false);
    }

    else if (elem.attachEvent) {
	var eID = elem.attachEvent('on'+eventName, callback);
	boundEvents[eID] = { name: eventName, callback: callback };
    }
}

function unbind (elem, eventName, callback) {
    if (elem.removeEventListener) {
	elem.removeEventListener(eventName, callback, false);
    }

    else if (elem.detachEvent) {
	for (var eID in boundEvents) {
	    if ((boundEvents[eID].name === eventName) &&
		(boundEvents[eID].callback === callback)) {
		elem.detachEvent(eID);
		delete boundEvents[eID];
	    }
	}
    }
}

/* Simple inheritance */
function inheritsFrom (func, parent) {
    var proto = func.prototype,
    superProto = parent.prototype,
    oldSuper;

    for (var prop in superProto) {
	proto[prop] = superProto[prop];
    }

    function superMethod (name) {
	var args = Array.prototype.slice.call(arguments, 1);

	if ( superProto[name] ) {
	    return superProto[name].apply(this, args);
	}
    }

    if (proto._super) {
	oldSuper = proto._super;

	proto._super = function () {
	    oldSuper.call(this, arguments);
	    superMethod.call(this, arguments);
	};
    }

    else {
	proto._super = superMethod;
    }
}



/* Event bus to handle finger event listeners */
function EventBus () {
    this.onEvents = {};
    this.onceEvents = {};
}

/* Attach a handler to listen for an event */
EventBus.prototype.on = function (name, callback) {
    if ( !callback ) {
	return;
    }

    if (name in this.onEvents) {
	var index = indexOf(this.onEvents[name], callback);

	if (index != -1) {
	    return;
	}
    }

    else {
	this.onEvents[name] = [];
    }

    if (name in this.onceEvents) {
	var index = indexOf(this.onceEvents[name], callback);

	if (index != -1) {
	    this.onceEvents.splice(index, 1);
	}
    }

    this.onEvents[name].push(callback);
};

/* Attach a one-time-use handler to listen for an event */
EventBus.prototype.once = function (name, callback) {
    if ( !callback ) {
	return;
    }

    if (name in this.onceEvents) {
	var index = indexOf(this.onceEvents[name], callback);

	if (index != -1) {
	    return;
	}
    }

    else {
	this.onceEvents[name] = [];
    }

    if (name in this.onEvents) {
	var index = indexOf(this.onEvents[name], callback);

	if (index != -1) {
	    this.onEvents.splice(index, 1);
	}
    }

    this.onceEvents[name].push(callback);
};

/* Detach a handler from listening for an event */
EventBus.prototype.off = function (name, callback) {
    if ( !callback ) {
	return;
    }

    if (name in this.onEvents) {
	var index = indexOf(this.onEvents[name], callback);

	if (index != -1) {
	    this.onEvents.splice(index, 1);
	    return;
	}
    }

    if (name in this.onceEvents) {
	var index = indexOf(this.onceEvents[name], callback);

	if (index != -1) {
	    this.onceEvents.splice(index, 1);
	    return;
	}
    }
};

/* Fire an event, triggering all handlers */
EventBus.prototype.trigger = function (name) {
    var args = Array.prototype.slice.call(arguments, 1),
    callbacks = (this.onEvents[name] || []).concat(this.onceEvents[name] || []),
    callback;

    while (callback = callbacks.shift()) {
	callback.apply(this, args);
    }
};



/* Object to manage a single-finger interactions */
function Finger (id, e) {
    this._super('constructor');
    this.id        = id;
    this.lastPoint = null;
    this.event = e;
}
inheritsFrom(Finger, EventBus);



/* Object to manage multiple-finger interactions */
function Hand (ids) {
    this._super('constructor');

    this.fingers = !ids ? [] : map(ids, function (id) {
	return new Finger(id);
    });
}
inheritsFrom(Hand, EventBus);

/* Get finger by id */
Hand.prototype.get = function (id) {
    var foundFinger;

    forEach(this.fingers, function (finger) {
	if (finger.id == id) {
	    foundFinger = finger;
	}
    });

    return foundFinger;
};



/* Convert DOM touch event object to simple dictionary style object */
function domTouchToObj (touches, time, e) {
    return map(touches, function (touch) {
	return {
	    e: e,
	    id: touch.identifier,
	    x: touch.pageX,
	    y: touch.pageY,
	    time: time
	};
    });
}

function domMouseToObj (mouseEvent, mouseID) {
    return [{
	e: mouseEvent,
	id: mouseID,
	x: mouseEvent.pageX,
	y: mouseEvent.pageY,
	time: mouseEvent.timeStamp
    }];
}



/* Controller object to handle Touchy interactions on an element */
function TouchController (elem, handleMouse, settings) {
    if (typeof settings == 'undefined') {
	settings = handleMouse;
	handleMouse = false;
    }

    if (typeof settings == 'function') {
	settings = { any: settings };
    }

    for (var name in plugins) {
	if (name in settings) {
	    var updates = plugins[name](elem, settings[name]);

	    if (typeof updates == 'function') {
		updates = { any: updates };
	    }

	    for (var handlerType in updates) {
		if (handlerType in settings) {
		    settings[handlerType] = (function (handler1, handler2) {
			return function () {
			    handler1.call(this, arguments);
			    handler2.call(this, arguments);
			};
		    })(settings[handlerType], updates[handlerType]);
		}

		else {
		    settings[handlerType] = updates[handlerType];
		}
	    }
	}
    }

    this.running = false;
    this.elem = elem;
    this.settings = settings || {};
    this.mainHand = new Hand();
    this.multiHand = null;
    this.mouseID = null;

    this.start();
};

/* Start watching element for touch events */
TouchController.prototype.start = function () {
    if (this.running) {
    	return;
    }
    this.running = true;
		if(Modernizr.touch){
		  bind(this.elem, 'touchstart', this.touchstart() );
	    bind(this.elem, 'touchmove' , this.touchmove()  );
	    bind(this.elem, 'touchend'  , this.touchend()   );	
		}
		else{
		  bind(this.elem, 'mousedown' , this.mousedown() );
	    bind(this.elem, 'mouseup'   , this.mouseup()   );
	    bind(this.elem, 'mousemove' , this.mousemove() );	
		}
};

TouchController.prototype.handleMouse = function(x){

  if(x){
    bind(this.elem, 'mousedown' , this.mousedown() );
    bind(this.elem, 'mouseup'   , this.mouseup()   );
    bind(this.elem, 'mousemove' , this.mousemove() );
  }

  else{
    unbind(this.elem, 'mousedown' , this.mousedown() );
    unbind(this.elem, 'mouseup'   , this.mouseup()   );
    unbind(this.elem, 'mousemove' , this.mousemove() );
  } 
}

/* Stop watching element for touch events */
TouchController.prototype.stop = function () {
    if ( !this.running ) {
	return;
    }
    this.running = false;

    unbind(this.elem, 'touchstart', this.touchstart() );
    unbind(this.elem, 'touchmove' , this.touchmove()  );
    unbind(this.elem, 'touchend'  , this.touchend()   );

    unbind(this.elem, 'mousedown' , this.mousedown() );
    unbind(this.elem, 'mouseup'   , this.mouseup()   );
    unbind(this.elem, 'mousemove' , this.mousemove() );
};

/* Return a handler for DOM touchstart event */
TouchController.prototype.touchstart = function () {
    if ( !this._touchstart ) {
	var self = this;
	this._touchstart = function (e) {
	    var touches = domTouchToObj(e.touches, e.timeStamp),
	    changedTouches = domTouchToObj(e.changedTouches, e.timeStamp, e);

	    self.mainHandStart(changedTouches);
	    self.multiHandStart(changedTouches, touches);
	};
    }

    return this._touchstart;
};

/* Return a handler for DOM touchmove event */
TouchController.prototype.touchmove = function () {
    if ( !this._touchmove ) {
	var self = this;
	this._touchmove = function (e) {
	    var touches = domTouchToObj(e.touches, e.timeStamp),
	    changedTouches = domTouchToObj(e.changedTouches, e.timeStamp);

	    self.mainHandMove(changedTouches);
	    self.multiHandMove(changedTouches, touches);
	};
    }

    return this._touchmove;
};

/* Return a handler for DOM touchend event */
TouchController.prototype.touchend = function () {
    if ( !this._touchend ) {
	var self = this;
	this._touchend = function (e) {
	    var touches = domTouchToObj(e.touches, e.timeStamp),
	    changedTouches = domTouchToObj(e.changedTouches, e.timeStamp);

	    self.mainHandEnd(changedTouches);
	    self.multiHandEnd(changedTouches, touches);
	};
    }

    return this._touchend;
};

/* Return a handler for DOM mousedown event */
TouchController.prototype.mousedown = function () {
    if ( !this._mousedown ) {
	var self = this;
	this._mousedown = function (e) {
	    var touches;

	    if ( self.mouseID ) {
		touches = domMouseToObj(e, self.mouseID);
		self.mainHandEnd(touches);
		self.multiHandEnd(touches, touches);
		self.mouseID = null;
	    }

	    self.mouseID = Math.random() + '';

	    touches = domMouseToObj(e, self.mouseID);
	    self.mainHandStart(touches);
	    self.multiHandStart(touches, touches);
	};
    }

    return this._mousedown;
};

/* Return a handler for DOM mouseup event */
TouchController.prototype.mouseup = function () {
    if ( !this._mouseup ) {
	var self = this;
	this._mouseup = function (e) {
	    var touches;

	    if ( self.mouseID ) {
		touches = domMouseToObj(e, self.mouseID);
		self.mainHandEnd(touches);
		self.multiHandEnd(touches, touches);
		self.mouseID = null;
	    }
	};
    }

    return this._mouseup;
};

/* Return a handler for DOM mousemove event */
TouchController.prototype.mousemove = function () {
    if ( !this._mousemove ) {
	var self = this;
	this._mousemove = function (e) {
	    var touches;

	    if ( self.mouseID ) {
		touches = domMouseToObj(e, self.mouseID);
		self.mainHandMove(touches);
		self.multiHandMove(touches, touches);
	    }
	};
    }

    return this._mousemove;
};

/* Handle the start of an individual finger interaction */
TouchController.prototype.mainHandStart = function (changedTouches) {
    var self = this,
    newFingers = [];

    forEach(changedTouches, function (touch) {
	var finger = new Finger(touch.id, touch.e);
	finger.lastPoint = touch;
	newFingers.push([ finger, touch ]);
	self.mainHand.fingers.push(finger);
    });

    forEach(newFingers, function (data) {
	self.settings.any && self.settings.any.call(self, self.mainHand, data[0]);
	data[0].trigger('start', data[1]);
    });

    self.mainHand.trigger('start', changedTouches);
};

/* Handle the movement of an individual finger interaction */
TouchController.prototype.mainHandMove = function (changedTouches) {
    var self = this,
    movedFingers = [];

    forEach(changedTouches, function (touch) {
	var finger = self.mainHand.get(touch.id);

	if ( !finger ) {
	    return;
	}

	finger.lastPoint = touch;
	movedFingers.push([ finger, touch ]);
    });

    forEach(movedFingers, function (data) {
	data[0].trigger('move', data[1]);
    });

    self.mainHand.trigger('move', changedTouches);
};

/* Handle the end of an individual finger interaction */
TouchController.prototype.mainHandEnd = function (changedTouches) {
    var self = this,
    endFingers = [];

    forEach(changedTouches, function (touch) {
	var finger = self.mainHand.get(touch.id),
	index;

	if ( !finger ) {
	    return;
	}

	finger.lastPoint = touch;
	endFingers.push([ finger, touch ]);

	index = indexOf(self.mainHand.fingers, finger);
	self.mainHand.fingers.splice(index, 1);
    });

    forEach(endFingers, function (data) {
	data[0].trigger('end', data[1]);
    });

    self.mainHand.trigger('end', changedTouches);
};

/* Handle the start of a multi-touch interaction */
TouchController.prototype.multiHandStart = function (changedTouches, touches) {
    this.multiHandDestroy();
    this.multiHandRestart(touches);
};

/* Handle the movement of a multi-touch interaction */
TouchController.prototype.multiHandMove = function (changedTouches, touches) {
    var self = this,
    movedFingers = [];

    forEach(changedTouches, function (touch) {
	var finger = self.multiHand.get(touch.id);

	if( !finger ) {
	    return;
	}

	finger.lastPoint = touch;
	movedFingers.push([ finger, touch ]);
    });

    forEach(movedFingers, function (data) {
	data[0].trigger('move', data[1]);
    });

    self.multiHand.trigger('move', changedTouches);
};

/* Handle the end of a multi-touch interaction */
TouchController.prototype.multiHandEnd = function (changedTouches, touches) {
    this.multiHandDestroy();

    var remainingTouches = filter(touches, function (touch) {
	var unChanged = true;

	forEach(changedTouches, function (changedTouch) {
	    if (changedTouch.id == touch.id) {
		unChanged = false;
	    }
	});

	return unChanged;
    });

    this.multiHandRestart(remainingTouches);
};

/* Create a new hand based on the current touches on the screen */
TouchController.prototype.multiHandRestart = function (touches) {
    var self = this;

    if (touches.length == 0) {
	return;
    }

    self.multiHand = new Hand();
    var newFingers = [];

    forEach(touches, function (touch) {
	var finger = new Finger(touch.id);

	finger.lastPoint = touch;
	newFingers.push([ finger, touch ]);
	self.multiHand.fingers.push(finger);
    });

    var func = self.settings[ {
	1: 'one',
	2: 'two',
	3: 'three',
	4: 'four',
	5: 'five'
    }[ self.multiHand.fingers.length ] ];

    func && func.apply(self, [ self.multiHand ].concat( self.multiHand.fingers ));

    forEach(newFingers, function (data) {
	data[0].trigger('start', data[1]);
    });

    self.multiHand.trigger('start', touches);
};

/* Destroy the current hand regardless of fingers on the screen */
TouchController.prototype.multiHandDestroy = function () {
    if ( !this.multiHand ) {
	return;
    }

    var points = [];

    forEach(this.multiHand.fingers, function (finger) {
	var point = finger.lastPoint;
	points.push(point);
	finger.trigger('end', point);
    });

    this.multiHand.trigger('end', points);

    this.multiHand = null;
};

/* Socket-style finger management for multi-touch events */
function Touchy (elem, handleMouse, settings) {
    return new TouchController(elem, handleMouse, settings);
}

/* Plugin support for custom touch handling */
var plugins = {};
Touchy.plugin = function (name, callback) {
    if (name in plugins) {
	throw 'Touchy: ' + name + ' plugin already defined';
    }

    plugins[name] = callback;
};



/* Prevent window movement (iOS fix) */
var preventDefault = function (e) { e.preventDefault() };

Touchy.stopWindowBounce = function () {
    bind(window, 'touchmove', preventDefault);
};

Touchy.startWindowBounce = function () {
    unbind(window, 'touchmove', preventDefault);
};

module.exports = Touchy;

},{}],28:[function(require,module,exports){
module.exports = function(str){
	
	var blob = new Blob([str], {type: "text\/javascript"});
	
	var worker = new Worker(window.URL.createObjectURL(blob))
	
	return worker;
	
}
},{}],29:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"buffer":38,"util":36}],30:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":49}],31:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],32:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    return http.request.call(this, params, cb);
}
},{"http":44}],33:[function(require,module,exports){

/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = {};
  var t = {};
  for (var i in parent[key]) t[i] = parent[key][i];
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = {};
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };
  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });
  return ret.base;
}

/**
 * Parse the given str.
 */

function parseString(str){
  return reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: {} }).base;
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],34:[function(require,module,exports){
var events = require('events');
var util = require('util');

function Stream() {
  events.EventEmitter.call(this);
}
util.inherits(Stream, events.EventEmitter);
module.exports = Stream;
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once, and
  // only when all sources have ended.
  if (!dest._isStdio && (!options || options.end !== false)) {
    dest._pipeCount = dest._pipeCount || 0;
    dest._pipeCount++;

    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (this.listeners('error').length === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('end', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('end', cleanup);
  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":30,"util":36}],35:[function(require,module,exports){
var punycode = { encode : function (s) { return s } };

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

function arrayIndexOf(array, subject) {
    for (var i = 0, j = array.length; i < j; i++) {
        if(array[i] == subject) return i;
    }
    return -1;
}

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]+$/,
    // RFC 2396: characters reserved for delimiting URLs.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''],
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // cut off any delimiters.
  // This is to support parse stuff like "<http://foo.com>"
  for (var i = 0, l = rest.length; i < l; i++) {
    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
  }
  if (i !== 0) rest = rest.substr(i);


  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = arrayIndexOf(rest, '@');
    if (atSign !== -1) {
      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        var index = arrayIndexOf(rest, nonAuthChars[i]);
        if (index !== -1 && index < atSign) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }
      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = rest.substr(0, atSign);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = arrayIndexOf(rest, nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = objectKeys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = out.hostname.split('.');
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
      var s = domainArray[i];
      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
          'xn--' + punycode.encode(s) : s);
    }
    out.hostname = newOut.join('.');

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }

    // Now make sure that delims never appear in a url.
    var chop = rest.length;
    for (var i = 0, l = delims.length; i < l; i++) {
      var c = arrayIndexOf(rest, delims[i]);
      if (c !== -1) {
        chop = Math.min(c, chop);
      }
    }
    rest = rest.substr(0, chop);
  }


  // chop off from the tail first.
  var hash = arrayIndexOf(rest, '#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = arrayIndexOf(rest, '?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = auth.split('@').join('%40');
    for (var i = 0, l = nonAuthChars.length; i < l; i++) {
      var nAC = nonAuthChars[i];
      auth = auth.split(nAC).join(encodeURIComponent(nAC));
    }
    auth += '@';
  }

  var protocol = obj.protocol || '',
      host = (obj.host !== undefined) ? auth + obj.host :
          obj.hostname !== undefined ? (
              auth + obj.hostname +
              (obj.port ? ':' + obj.port : '')
          ) :
          false,
      pathname = obj.pathname || '',
      query = obj.query &&
              ((typeof obj.query === 'object' &&
                objectKeys(obj.query).length) ?
                 querystring.stringify(obj.query) :
                 '') || '',
      search = obj.search || (query && ('?' + query)) || '',
      hash = obj.hash || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    out.port = port.substr(1);
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

},{"querystring":33}],36:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":30}],37:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],38:[function(require,module,exports){
(function(){var assert = require('assert');
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

})()
},{"./buffer_ieee754":37,"assert":29,"base64-js":39}],39:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],40:[function(require,module,exports){
(function(){var Buffer = require('buffer').Buffer
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)));
    } catch (err) { callback(err); }
  } else {
    return new Buffer(rng(size));
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

})()
},{"./md5":41,"./rng":42,"./sha":43,"buffer":38}],41:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],42:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],43:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],44:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');

http.request = function (params, cb) {
    if (!params) params = {};
    if (!params.host) params.host = window.location.host.split(':')[0];
    if (!params.port) params.port = window.location.port;
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

},{"./lib/request":45,"events":30}],45:[function(require,module,exports){
(function(){var Stream = require('stream');
var Response = require('./response');
var concatStream = require('concat-stream')
var Buffer = require('buffer')

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = concatStream()
    
    var uri = params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    xhr.open(
        params.method || 'GET',
        (params.scheme || 'http') + '://' + uri,
        true
    );
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            if (isArray(value)) {
                for (var j = 0; j < value.length; j++) {
                    xhr.setRequestHeader(key, value[j]);
                }
            }
            else xhr.setRequestHeader(key, value)
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + new Buffer(params.auth).toString('base64'));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        res.handle(xhr);
    };
};

Request.prototype = new Stream;

Request.prototype.setHeader = function (key, value) {
    if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            this.xhr.setRequestHeader(key, value[i]);
        }
    }
    else {
        this.xhr.setRequestHeader(key, value);
    }
};

Request.prototype.write = function (s) {
    this.body.write(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.write(s);
    this.body.end()
    this.xhr.send(this.body.getBody());
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

})()
},{"./response":46,"buffer":38,"concat-stream":47,"stream":34}],46:[function(require,module,exports){
var Stream = require('stream');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

Response.prototype = new Stream;

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":34}],47:[function(require,module,exports){
(function(Buffer){var stream = require('stream')
var util = require('util')

function ConcatStream(cb) {
  stream.Stream.call(this)
  this.writable = true
  if (cb) this.cb = cb
  this.body = []
  if (this.cb) this.on('error', cb)
}

util.inherits(ConcatStream, stream.Stream)

ConcatStream.prototype.write = function(chunk) {
  this.body.push(chunk)
}

ConcatStream.prototype.arrayConcat = function(arrs) {
  if (arrs.length === 0) return []
  if (arrs.length === 1) return arrs[0]
  return arrs.reduce(function (a, b) { return a.concat(b) })
}

ConcatStream.prototype.isArray = function(arr) {
  var isArray = Array.isArray(arr)
  var isTypedArray = arr.toString().match(/Array/)
  return isArray || isTypedArray
}

ConcatStream.prototype.getBody = function () {
  if (this.body.length === 0) return
  if (typeof(this.body[0]) === "string") return this.body.join('')
  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)
  if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {
    return Buffer.concat(this.body)
  }
  return this.body
}

ConcatStream.prototype.end = function() {
  if (this.cb) this.cb(false, this.getBody())
}

module.exports = function(cb) {
  return new ConcatStream(cb)
}

module.exports.ConcatStream = ConcatStream

})(require("__browserify_Buffer").Buffer)
},{"__browserify_Buffer":48,"stream":34,"util":36}],48:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

},{"util":2,"buffer":3}],2:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":4}],5:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],6:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":6}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

},{"assert":1,"./buffer_ieee754":5,"base64-js":7}],7:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],8:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],3:[function(require,module,exports){
function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

},{"assert":1,"./buffer_ieee754":8,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],49:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvaG9tZS91c2VyL2RldmVsb3BtZW50L2Jhcm4vZGVsYXlvL2FwcC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvYmFybi9kZWxheW8vYXBwZW5kQ1NTLmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9iYXJuL2RlbGF5by9sb2FkU3JjLmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9iYXJuL2RlbGF5by9vdmVybGF5LmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9iYXJuL2RlbGF5by9zb3VyY2VDYXAuanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L2Jhcm4vZGVsYXlvL3NvdXJjZUV2ZW50LmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9iYXJuL2RlbGF5by9zeW50aC1zZXJ2ZXItbm9kZS9mbG9hdENvbmNhdC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvYmFybi9kZWxheW8vc3ludGgtc2VydmVyLW5vZGUvaW5kZXguanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L2Jhcm4vdXhlci9hcHBlbmRDU1MuanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L2Jhcm4vdXhlci9jZW50ZXIuanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L2Jhcm4vdXhlci9nZXRDU1MuanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L25vZGVfbW9kdWxlcy9idWZmZXJzL2luZGV4LmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9ub2RlX21vZHVsZXMvaHlwZXJxdWVzdC9pbmRleC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL2h5cGVycXVlc3Qvbm9kZV9tb2R1bGVzL2R1cGxleGVyL2luZGV4LmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9ub2RlX21vZHVsZXMvaHlwZXJxdWVzdC9ub2RlX21vZHVsZXMvdGhyb3VnaC9pbmRleC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL2h5cGVyc2NyaXB0L2luZGV4LmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9ub2RlX21vZHVsZXMvaHlwZXJzY3JpcHQvbm9kZV9tb2R1bGVzL2Jyb3dzZXItc3BsaXQvaW5kZXguanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L25vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC9ub2RlX21vZHVsZXMvY2xhc3MtbGlzdC9pbmRleC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL2h5cGVyc2NyaXB0L25vZGVfbW9kdWxlcy9kYXRhLXNldC9pbmRleC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL2h5cGVyc2NyaXB0L25vZGVfbW9kdWxlcy9kYXRhLXNldC9ub2RlX21vZHVsZXMvaW5kaXZpZHVhbC9pbmRleC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL2h5cGVyc2NyaXB0L25vZGVfbW9kdWxlcy9kYXRhLXNldC9ub2RlX21vZHVsZXMvaW5kaXZpZHVhbC9ub2RlX21vZHVsZXMvZ2xvYmFsL2luZGV4LmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9ub2RlX21vZHVsZXMvaHlwZXJzY3JpcHQvbm9kZV9tb2R1bGVzL2RhdGEtc2V0L25vZGVfbW9kdWxlcy93ZWFrbWFwL3dlYWttYXAuanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0cy5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL21vdXNlLWFyb3VuZC9pbmRleC5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL25vZGUtdXVpZC91dWlkLmpzIiwiL2hvbWUvdXNlci9kZXZlbG9wbWVudC9ub2RlX21vZHVsZXMvdG91Y2hkb3duL3RvdWNoZG93bi5qcyIsIi9ob21lL3VzZXIvZGV2ZWxvcG1lbnQvbm9kZV9tb2R1bGVzL3RvdWNoZG93bi90b3VjaHkuanMiLCIvaG9tZS91c2VyL2RldmVsb3BtZW50L25vZGVfbW9kdWxlcy93b3JrLXNsYXZlL2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vYXNzZXJ0LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vZXZlbnRzLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vZnMuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9odHRwcy5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL3F1ZXJ5c3RyaW5nLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vc3RyZWFtLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vdXJsLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vdXRpbC5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvYnVmZmVyLWJyb3dzZXJpZnkvYnVmZmVyX2llZWU3NTQuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2J1ZmZlci1icm93c2VyaWZ5L2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9idWZmZXItYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3JuZy5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvc2hhLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9saWIvcmVxdWVzdC5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2xpYi9yZXNwb25zZS5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jb25jYXQtc3RyZWFtL2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvYnVmZmVyLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBlbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIGFwcGVuZENTUyA9IHJlcXVpcmUoJy4uL3V4ZXIvYXBwZW5kQ1NTJyk7XG5cbnZhciBjc3MgPSBcImh0bWwsIGJvZHksIGRpdiwgcCwgcHJlLCBpbWcsIGF1ZGlvLCB2aWRlbywgaDEsIGgyLCBoMywgaDQsIGZvcm0sIGZpZWxkc2V0LCBsYWJlbCwgbGVnZW5kLCBzcGFuXFxue1xcbi13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbm1hcmdpbjowO1xcbnBhZGRpbmc6MDtcXG4td2Via2l0LW1hcmdpbi1zdGFydDogMnB4O1xcbi13ZWJraXQtbWFyZ2luLWVuZDogMnB4O1xcbi13ZWJraXQtcGFkZGluZy1iZWZvcmU6IDAuMzVlbTtcXG4td2Via2l0LXBhZGRpbmctc3RhcnQ6IDAuNzVlbTtcXG4td2Via2l0LXBhZGRpbmctZW5kOiAwLjc1ZW07XFxuLXdlYmtpdC1wYWRkaW5nLWFmdGVyOiAwLjYyNWVtO1xcbmZvbnQtZmFtaWx5Om1vbm9zcGFjZTtcXG59XFxuLnNvdXJjZUNhcHR1cmV7XFxuICB3aWR0aDogODUlO1xcbiAgaGVpZ2h0OiA4NSU7XFxuICBib3JkZXItd2lkdGg6IDE2cHg7XFxufVxcblxcbi5zb3VyY2VDYXBPcHRze1xcbiAgZmxvYXQ6bGVmdDtcXG4gIHdpZHRoOiAzMyU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBib3JkZXItcmlnaHQ6MTZweCBzb2xpZCBPcmFuZ2VSZWQ7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuXFxufVxcblxcbi5zb3VyY2VDYXBPcHRzTGFiZWwge1xcbiAgaGVpZ2h0OiAyNSU7XFxufVxcblxcbi5zb3VyY2VDYXBNb2Rle1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgd2lkdGg6NjYlO1xcbiAgaGVpZ2h0OjEwMCU7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBvdmVyZmxvdzpoaWRkZW5cXG59XCI7XG52YXIgcG5nID0gXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBWUFBQUJ6ZW5yMEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeVJwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNeTFqTURFeElEWTJMakUwTlRZMk1Td2dNakF4TWk4d01pOHdOaTB4TkRvMU5qb3lOeUFnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5UTmlBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dRMEpHTURjNU9UZENNREl4TVVVeU9VTXdNMFl6TnpKQk56aEdNVGxGTVNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd1EwSkdNRGM1UVRkQ01ESXhNVVV5T1VNd00wWXpOekpCTnpoR01UbEZNU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pCRFFrWXdOemszTjBJd01qRXhSVEk1UXpBelJqTTNNa0UzT0VZeE9VVXhJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakJEUWtZd056azROMEl3TWpFeFJUSTVRekF6UmpNM01rRTNPRVl4T1VVeElpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtlYXRzbndBQUFtUkpSRUZVZU5xOGxrMUlWRkVVeDU4ejVwUUtPanBnNENJWDZkQTBDekZhaVRtR0VvV1VHeTJrMnVRaU4wSzRrWWdLUDBBS0pCSlhRWnNXbzVLNGtXYkF3by9hSmdOQkVKbm9vaWdwUDlBQ0VhMy9qZk5pR3M1OTc3dzNNeDc0TVhBLzN2dk52ZmVkZTNMQ1oxb01pd2lDVmhBQklSQUFlK0FiZUFlbXdTaFlOVnhHamtiZ09IZ0lMcWt4TnMvWUFVL0JYZkRkcVlDSGFldWdmOWNpZUxrS0graWtPV2ZURmJnSG5vRERMbGJ6S0lpQmkyNEZib0Q3Um5xUkI2S2dXam9obDM2UGdXR0xjWnZnSlZnQlhsQkZ5KzFqeHVhRFNYQVMvSklLOUlNalRMODY4UU4wSUxlWkpWZnRWNWw1RmFBYjlFbTJRSjM0ZHMzTEw5TzUyR2I2djRKckZ0dldSVnRpSzNCRjh6V29WWmtRYkdNdkhiN1VVRG1qU1NJUVlkcTNhSGtsOFJ2YzF2UTFTQVJDVEx2S2NEOGRuUDRFV0diYVQwZ0VTcG4ySlJlZjRDTFRWaUlSMkdmYXZTNEV1RG03RWdFdWY0ZGNaRlJ1emlmSnhBVFRyZzVtbVFNQjNmaFppY0FyelFYendFSDZIZFRra1poRUlFcFhhbXBjQjdjRW1WUmRYcWVadnJpa1R2QlFjVEdpNlI4Q1kxU1kvRmRIZ0Zvd1I2SmNQSE55R1EzUWd3TE1tRGJpQS9nSURvRXdLQmRzalZoZ2pmTDZsTVVuR0dSV3dpb2VnL2ZncmJRZWlOUE50bXRrSm9vcG81NXlVaEdwQXZNYytKSWhDYitkQkhjTHpvQktjQWRzMkx4Z253b1Z0WDAzTmRlMktWSGpwQ28yUXhVcHphQ2VNbDBSVlRrcXc3Mmg3L3h6MHZnNjhBSVVNczlhQjQxZ3dZbUFtNmdqc1FLSmhNZklmTHdHNXpYWHVaKzJyQ2FiQWhLSmYyY2lXd0oyRWlXbVJEWUZKQkxQc3kxZ1NselFTSXdmaElDS2VVYmlFZWc1S0lGa2lSOVVjZis5NnY4SU1BQVIzSGp3QkUvL3VRQUFBQUJKUlU1RXJrSmdnZz09XCI7XG5cbnZhciBsb2FkU3JjID0gcmVxdWlyZSgnLi9sb2FkU3JjJylcblxuYXBwZW5kQ1NTKGNzcywgJ3N5bnRoRk0nKVxuIFxudmFyIGFwcCA9IG5ldyBlbWl0dGVyKCk7XG4vL2luaGVyaXRzKGFwcCwgZW1pdHRlcik7XG5cbmFwcC5tYXN0ZXIgPSB3aW5kb3cubWFzdGVyID0gbmV3IHdlYmtpdEF1ZGlvQ29udGV4dCgpO1xuYXBwLnNvdXJjZXMgPSBbXVxuYXBwLnN5bnRocyA9IFtdXG5hcHAudXNlciA9IHt9XG5hcHAubWljTGluZSA9IG51bGxcbmFwcC5sb2FkU3JjID0gbG9hZFNyYyhhcHApXG5cbmFwcC5sb2FkU3JjKGZ1bmN0aW9uKGVyciwgc3JjKXtcbiAgICBjb25zb2xlLmxvZyhlcnIsIHNyYylcbn0pXG4gXG5hcHAub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBjb25zb2xlLmxvZyhlcnIpXG59KVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjc3MsIGlkKXtcbiAgICB2YXIgZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICBpZihlcyl7XG5cdHJldHVybiBmYWxzZVxuLy9cdGVzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG1ha2VTdHlsZShjc3MpLCBlcy5uZXh0U2libGluZylcbiAgICB9XG4gICAgZWxzZXtcblx0dmFyIHN0eWxlU2hlZXQgPSBtYWtlU3R5bGUoY3NzLCBpZClcblx0ZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVTaGVldCwgZG9jdW1lbnQuaGVhZC5jaGlsZE5vZGVzWzBdKTtcblx0cmV0dXJuIHN0eWxlU2hlZXRcbiAgICB9XG5cbn1cblxuXG5mdW5jdGlvbiBtYWtlU3R5bGUoc3RyLCBpZCl7XG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pZCA9IGlkIHx8ICcnO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3RyO1xuICAgIHJldHVybiBzdHlsZVxufVxuIiwidmFyIHNvdXJjZVNlbGVjdCA9IHJlcXVpcmUoJy4vc291cmNlQ2FwJyk7XG52YXIgc291cmNlRXZlbnRzID0gcmVxdWlyZSgnLi9zb3VyY2VFdmVudCcpO1xudmFyIG92ZXJsYXkgPSByZXF1aXJlKCcuL292ZXJsYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApe1xuXG5cdC8vIHRoaXMgc2hvdWxkIGluaXRpYWxpemUgdGhlIHNvdXJjZSBjYXB0dXJlIHZpZXdcblx0Ly8gYWxsb3dpbmcgdXNlciB0byBzZWxlY3QgZnJvbSBzb3VyY2Ugb3B0aW9uc1xuXHQvLyBzcmMgaXMgYW4gb2JqZWN0XG5cdC8vIHdoZW4gdGhlIHNyYyBsb2Fkcywgb3Igc3RhcnRzIGxvYWRpbmcsXG5cdC8vIHRoZSBjYiB3aWxsIGJlIGNhbGxlZCB3aXRoIChlcnIsIHNyYylcblx0Ly8gYW5kIHRoZSBzcmMgd2lsbCBhcHBlbmRlZCB0byBhcHAuc291cmNlc1xuXHQvLyBhbmQgdGhlIHByZXZpb3VzIHZpZXcgd2lsbCBiZSByZXN0b3JlZCBcblxuICAgIHZhciBzb3VyY2VTZWxlY3RFbGVtZW50ID0gc291cmNlU2VsZWN0KHNvdXJjZUV2ZW50cyhhcHApKTtcbi8vICAgIHZhciBvdmVybGF5ID0gb3ZlcmxheVxuLy8gICAgdmFyIGFwcCA9IGFwcFxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNiKXtcblx0XG5cdHZhciBvbGV5ID0gb3ZlcmxheShzb3VyY2VTZWxlY3RFbGVtZW50KVxuXG5cdG9sZXkuZW1pdCgnc2hvdycpO1xuXG5cdGFwcC5vbmNlKCdzb3VyY2VDYXAnLCBmdW5jdGlvbihlcnIsIHNyYyl7XG5cdCAgICBvbGV5LmVtaXQoJ3JlbW92ZScpO1xuXHQgICAgaWYoc3JjKSBhcHAuc291cmNlcy5wdXNoKHNyYylcblx0ICAgIGlmKGVycikgYXBwLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHQgICAgYXBwLnJlbW92ZUFsbExpc3RlbmVycygnY2FuY2VsJylcblx0ICAgIGNiKGVyciwgc3JjKVxuXHR9KVxuXG5cdGFwcC5vbmNlKCdjYW5jZWwnLCBmdW5jdGlvbigpe1xuXHQgICAgYXBwLnJlbW92ZUFsbExpc3RlbmVycygnc291cmNlQ2FwJylcblx0ICAgIG9sZXkuZW1pdCgncmVtb3ZlJyk7XG5cdH0pXG4gICAgfVxufVxuIiwidmFyIGVlID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgaHRtbCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0JylcbnZhciBjZW50ZXIgPSByZXF1aXJlKCcuLi91eGVyL2NlbnRlcicpXG52YXIgY3NzID0gXCIub3ZlcmxheSB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWQxZDFkO1xcbiAgei1pbmRleDogMTExMTExMTExMTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7ICBcXG59XFxuXCI7XG52YXIgYXBwZW5kQ1NTID0gcmVxdWlyZSgnLi9hcHBlbmRDU1MnKVxuXG5hcHBlbmRDU1MoY3NzKVxuXG52YXIgb3ZlcmxheSA9IGh0bWwoJ2Rpdi5vdmVybGF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwpe1xuXG4gICAgdmFyIGVtID0gbmV3IGVlKCk7XG5cbiAgICBlbS5vbignc2hvdycsIGZ1bmN0aW9uKCl7XG5cblx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5KVxuXG5cdG92ZXJsYXkuYXBwZW5kQ2hpbGQoZWwpO1xuXG5cdGNlbnRlcihlbClcblx0XG4gICAgfSlcblxuICAgIGVtLm9uKCdyZW1vdmUnLCBmdW5jdGlvbigpe1xuXHRcblx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5KVxuXG5cdG92ZXJsYXkucmVtb3ZlQ2hpbGQoZWwpXG5cbiAgICB9KVxuXG4gICAgcmV0dXJuIGVtXG5cbn1cbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgY3NzID0gXCIudXhlci1mbGF0LWZpZWxkc2V0IHtcXG4gICAgICAgIGNvbG9yOk9yYW5nZVJlZDtcXG5cXHRib3JkZXItcmFkaXVzOjVweDtcXG5cXHRwYWRkaW5nOjA7XFxuXFx0bWFyZ2luOjA7XFxuXFx0d2lkdGg6MTAwJTtcXG5cXHRoZWlnaHQ6MTAwJTtcXG5cXHRib3JkZXI6IDFweCBzb2xpZCBPcmFuZ2VSZWQ7XFxuXFx0Ym9yZGVyLXJhZGl1czogOXB4O1xcbn1cXG5cXG4udXhlci1mbGF0ZmllbGQtbGVnZW5kIHtcXG4gICAgICAgIGZvbnQtd2VpZ2h0OiA5MDA7XFxuXFx0cGFkZGluZzowIDEwcHg7XFxuXFx0Zm9udC1zaXplOjE2cHg7XFxuXFx0bGluZS1oZWlnaHQ6MTZweDtcXG5cXHRmb250LXN0eWxlOiBpdGFsaWM7XFxuXFx0dGV4dC1hbGlnbjpjZW50ZXI7XFxufVxcblxcbi51eGVyLWZsYXRmaWVsZC1sYWJlbCB7XFxuXFx0ZGlzcGxheTpibG9jaztcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgyMDAsIDY2LCAwLCAuMik7XFxufVxcblxcbi51eGVyLWZsYXRmaWVsZC1sYWJlbDpob3ZlciwgcC51eGVyLWZsYXRmaWVsZC1yYWRpby1uYW1lOmhvdmVyIHtcXG5cXHRjdXJzb3I6cG9pbnRlcjtcXG59XFxuXFxuLnV4ZXItZmxhdGZpZWxkLWlucHV0W3R5cGU9Y2hlY2tib3hdLCAudXhlci1mbGF0ZmllbGQtaW5wdXRbdHlwZT1yYWRpb10sLnV4ZXItZmxhdGZpZWxkLWlucHV0W3R5cGU9ZmlsZV0sIC51eGVyLWZsYXRmaWVsZC1pbnB1dFt0eXBlPWJ1dHRvbl0gICB7XFxuXFx0ZGlzcGxheTpub25lO1xcbn1cXG5cXG4udXhlci1mbGF0ZmllbGQtaW5wdXRbdHlwZT10ZXh0XSwgLnV4ZXItZmxhdGZpZWxkLWlucHV0W3R5cGU9bnVtYmVyXSwgLnV4ZXItZmxhdGZpZWxkLWlucHV0W3R5cGU9dXJsXXtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGNvbG9yOiBPcmFuZ2VSZWQ7XFxuICAgIGZvbnQtc2l6ZToxNnB4O1xcbiAgICBmb250LXdlaWdodDo1MDA7XFxuICAgIHBhZGRpbmc6M3B4IDA7XFxuICAgIHRleHQtZGVjb3JhdGlvbjp1cHBlcmNhc2U7XFxuICAgIGxpbmUtaGVpZ2h0OjIycHg7XFxuICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gICAgbWFyZ2luOiA1cHggMDtcXG4gICAgYm9yZGVyOjFweCBzb2xpZCByZ2JhKDIxMCwgNjYsIDAsIDAuMik7XFxuICAgIHRleHQtaW5kZW50OiAzcHg7XFxufVxcblxcbi51eGVyLWZsYXRmaWVsZC1pbnB1dFt0eXBlPXRleHRdOmZvY3VzLCAudXhlci1mbGF0ZmllbGQtaW5wdXRbdHlwZT1udW1iZXJdOmZvY3VzLCAudXhlci1mbGF0ZmllbGQtaW5wdXRbdHlwZT11cmxdOmZvY3Vze1xcbiAgIG91dGxpbmU6MXB4IHNvbGlkIHJnYmEoMjEwLCA2NiwgMCwgMC4yKVxcbn1cXG5cXG46Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7XFxuICAgIGNvbG9yOiBPcmFuZ2VSZWQ7XFxuICAgIG9wYWNpdHk6IC4zODtcXG4gICAgZm9udC13ZWlnaHQ6OTAwO1xcbn1cXG5cXG5pbnB1dDpmb2N1czo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntcXG4gICAgY29sb3I6IHJnYmEoMCwwLDAsMCk7XFxufVxcblxcbi51eGVyLWZsYXQtYnV0dG9ue1xcbiAgbWluLXdpZHRoOjQwJTtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgb3V0bGluZTpub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgT3JhbmdlUmVkO1xcbiAgYmFja2dyb3VuZDogaW5oZXJpdDtcXG5cXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuLnV4ZXItZmxhdC1idXR0b246YWN0aXZle1xcbiAgYmFja2dyb3VuZDogT3JhbmdlUmVkO1xcbiAgY29sb3I6ICNlZWU7XFxufVxcbi51eGVyLWZsYXRmaWVsZC1yYWRpby12YWx1ZSwgLnV4ZXItZmxhdGZpZWxkLWZpbGUtdmFsdWUge1xcblxcdGZvbnQtc2l6ZToxNnB4O1xcblxcdGZvbnQtd2VpZ2h0OjkwMDtcXG5cXHRsaW5lLWhlaWdodDoyMnB4O1xcbn1cXG5cXG4udXhlci1mbGF0ZmllbGQtaW5wdXRbdHlwZT1yYWRpb106Y2hlY2tlZCAgKyAudXhlci1mbGF0ZmllbGQtcmFkaW8sIC51eGVyLWZsYXRmaWVsZC1pbnB1dFt0eXBlPXJhZGlvXTpjaGVja2VkIH4gbGFiZWx7XFxuXFx0YmFja2dyb3VuZDpMaW1lR3JlZW47XFxufVxcblxcbi51eGVyLWZsYXRmaWVsZC1yYWRpbyB7XFxuXFx0d2lkdGg6MTZweDtcXG5cXHRoZWlnaHQ6MTZweDtcXG5cXHRiYWNrZ3JvdW5kOmluaGVyaXQ7XFxuXFx0ZmxvYXQ6bGVmdDtcXG5cXHRib3JkZXItcmFkaXVzOjUwJTtcXG5cXHRib3JkZXI6MnB4IHNvbGlkIE9yYW5nZVJlZDtcXG59XFxuXFxuXFxuXFxuXFxuXCI7XG52YXIgaHRtbCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0Jyk7XG52YXIgdG91Y2hkb3duID0gcmVxdWlyZSgndG91Y2hkb3duJyk7XG52YXIgYXBwZW5kQ1NTID0gcmVxdWlyZSgnLi4vdXhlci9hcHBlbmRDU1MnKTtcbnZhciBob3ZlciA9IHJlcXVpcmUoJ21vdXNlLWFyb3VuZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc291cmNlRXZlbnRzKXtcblxuICAgIHZhciBjaGFuZ2UgPSBzb3VyY2VFdmVudHMuY2hhbmdlO1xuICAgIHZhciBjbGljayA9IHNvdXJjZUV2ZW50cy5jbGljaztcbiAgICBcbiAgICBhcHBlbmRDU1MoY3NzLCAndXhlci1mbGF0ZmllbGQnKVxuXG4gICAgdmFyIF9maWVsZHNldCA9IGh0bWwoJ2ZpZWxkc2V0LnV4ZXItZmxhdC1maWVsZHNldC5zb3VyY2VDYXB0dXJlJyk7XG4gICAgdmFyIF9sZWdlbmQgPSAgaHRtbCgnbGVnZW5kLnV4ZXItZmxhdGZpZWxkLWxlZ2VuZCcsICcrIEFERCBBVURJTyBTT1VSQ0UgKycpXG5cbiAgICBfZmllbGRzZXQuYXBwZW5kQ2hpbGQoX2xlZ2VuZCk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGh0bWwoJ2Rpdi5zb3VyY2VDYXBPcHRzJylcbiAgICBfZmllbGRzZXQuYXBwZW5kQ2hpbGQob3B0aW9ucyk7XG4gIFxuICAgIHZhciBtb2RlID0gaHRtbCgnZGl2LnNvdXJjZUNhcE1vZGUnKVxuICAgIF9maWVsZHNldC5hcHBlbmRDaGlsZChtb2RlKTtcbiBcbiAgICB2YXIgc2FtcGxlc0xhYmVsID0gaHRtbCgnbGFiZWwudXhlci1mbGF0ZmllbGQtbGFiZWwuc291cmNlQ2FwT3B0c0xhYmVsJyk7XG4gICAgdmFyIHNhbXBsZXMgPSBodG1sKCdidXR0b24udXhlci1mbGF0LWJ1dHRvbicsIFxuXHRcdCAgICAgICB7dGV4dENvbnRlbnQ6ICdMT0FEIFNBTVBMRVMnLFxuXHRcdFx0bmFtZTogJ3NhbXBsZWJhbmsnLFxuXHRcdFx0b250b3VjaGRvd246IGZ1bmN0aW9uKGUpe2NsaWNrLmNhbGwoc2FtcGxlcywgZSl9XG5cdFx0ICAgICAgIH0pO1xuXG4gICAgaG92ZXIoX2ZpZWxkc2V0LCBmdW5jdGlvbihldnQsIG5vZGUsIHBvcywgc3RhcnQsIHN0b3ApeyB9KVxuICAgIHRvdWNoZG93bi5zdGFydChzYW1wbGVzKTtcbiAgICBzYW1wbGVzTGFiZWwuYXBwZW5kQ2hpbGQoc2FtcGxlcyk7XG4gICAgb3B0aW9ucy5hcHBlbmRDaGlsZChzYW1wbGVzTGFiZWwpO1xuXG5cbiAgICB2YXIgeXRleHRMYWJlbCA9IGh0bWwoJ2Rpdi51eGVyLWZsYXRmaWVsZC1sYWJlbC5zb3VyY2VDYXBPcHRzTGFiZWwnKTtcbiAgICB2YXIgeXRleHQgPSBodG1sKCdpbnB1dC51eGVyLWZsYXRmaWVsZC1pbnB1dCcsIFxuXHRcdCAgICAge3ZhbHVlOiAnaHR0cDovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTFPaXhxUFRoRE5FJywgXG5cdFx0ICAgICAgcGxhY2Vob2xkZXI6ICdQQVNURSBZT1VUVUJFIExJTksnLFxuXHRcdCAgICAgIHR5cGU6ICd1cmwnLFxuXHRcdCAgICAgIG5hbWU6ICdzb3VyY2VVUkwnXG5cdFx0ICAgICB9KTtcbiAgICB2YXIgeXRleHRNb2RlQnV0dG9uID0gaHRtbCgnYnV0dG9uLnV4ZXItZmxhdC1idXR0b24nLFxuXHRcdFx0ICAge3RleHRDb250ZW50OiAnVVNFIElOVEVSTkVUIEFVRElPJywgXG5cdFx0XHQgICAgb250b3VjaGRvd246IGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTtjbGljay5jYWxsKHl0ZXh0LCBlKX1cblx0XHRcdCAgICB9KTtcblxuICAgIHZhciB5dGV4dE1vZGVJbmZvID0gaHRtbCgncC5pbmZvSGVscCcsIFxuICAgICAgWyAnWW91IGNhbiBsb2FkIGF1ZGlvIGZyb20gYWxtb3N0IGFueXdoZXJlIG9uIHRoZSBpbnRlcm5ldDogeW91dHViZSwgdmltZW8sIHNvdW5kY2xvdWQsIGJhbmRjYW1wLCBzeW50aC5mbSwgb3IgYSBkaXJlY3QgbGluayB0byBhbiBhdWRpbyBvciB2aWRlbyBmaWxlLiBTb29uIHlvdVxcJ2xsIGJlIGFibGUgdG8gc2VhcmNoIHRob3NlIHNhbWUgc291cmNlcyBmb3IgbXVsdGlwbGUgcmVzdWx0cywgYW5kIGV2ZW4gY2FwdHVyZSBsaXZlIG9nZy9tcDMgc3RyZWFtcy4nIFxuICAgICAgLCBodG1sKCdicicpXG4gICAgICAsIGh0bWwoJ2JyJylcbiAgICAgICwgaHRtbCgnaDMnLCAnRXhhbXBsZXM6JylcbiAgICAgICwgaHRtbCgndWwnLCBbXG5cdCAgaHRtbCgnbGknLCAnaHR0cDovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTFPaXhxUFRoRE5FJyksXG5cdCAgaHRtbCgnbGknLCAnaHR0cDovL3N5bnRoLmZtL1VkUDRSdUwzeicpXG4gICAgICBdKVxuICAgICAgLCBodG1sKCdoMycsICdTdXBwb3J0ZWQgYXVkaW8gRmlsZSBUeXBlczonKVxuICAgICAgLCBodG1sKCd1bCcsIFsnbXAzJywgJ3dhdicsICdvZ2cnLCAnYWFjJ10ubWFwKGZ1bmN0aW9uKGspe1xuXHQgICAgcmV0dXJuIGh0bWwoJ2xpJywgaylcblx0fSkpXG4gICAgICBdKSBcblxuICAgIHZhciBmaWxlTW9kZUluZm8gPSBodG1sKCdwLmluZm9IZWxwJywgW1xuXHRodG1sKCdoMycsICdMb2FkIG9uZSBvciBtb3JlIGZpbGVzIGZyb20geW91ciBjb21wdXRlcicpLFxuXHRodG1sKCdoMycsICdTdXBwb3J0ZWQgRmlsZSBUeXBlczonKSxcblx0aHRtbCgndWwnLCBbJ21wMycsICd3YXYnLCAnb2dnJywgJ2FhYyddLm1hcChmdW5jdGlvbihrKXtcblx0ICAgIHJldHVybiBodG1sKCdsaScsIGspXG5cdH0pKVxuICAgIF0pIFxuXG4gICAgdmFyIHl0ZXh0TW9kZSA9IGh0bWwoJ2RpdiNzb3VyY2VVUkwnKTtcbiAgICB2YXIgZmlsZU1vZGUgPSBodG1sKCdkaXYjc291cmVjZUZpbGUnKTtcbiAgICB2YXIgbWljTGluZU1vZGUgPSBodG1sKCdkaXYjc291cmNlTWljTGluZScpO1xuICAgIHZhciBzYW1wbGVNb2RlID0gaHRtbCgnZGl2I3NvdXJjZVNhbXBsZScpO1xuXG4gICAgbW9kZS5hcHBlbmRDaGlsZCh5dGV4dE1vZGUpO1xuICAgIG1vZGUuYXBwZW5kQ2hpbGQoZmlsZU1vZGUpO1xuICAgIG1vZGUuYXBwZW5kQ2hpbGQobWljTGluZU1vZGUpO1xuICAgIG1vZGUuYXBwZW5kQ2hpbGQoc2FtcGxlTW9kZSk7XG5cbiAgICBmaWxlTW9kZS5hcHBlbmRDaGlsZChmaWxlTW9kZUluZm8pO1xuXG4gICAgeXRleHRMYWJlbC5hcHBlbmRDaGlsZCh5dGV4dCk7XG4gICAgeXRleHRNb2RlLmFwcGVuZENoaWxkKHl0ZXh0TGFiZWwpXG4gICAgeXRleHRNb2RlLmFwcGVuZENoaWxkKHl0ZXh0TW9kZUluZm8pXG5cbiAgICB2YXIgeXRleHRPcHRpb25MYWJlbCA9IGh0bWwoJ2Rpdi51eGVyLWZsYXRmaWVsZC1sYWJlbC5zb3VyY2VDYXBPcHRzTGFiZWwnKTtcbiAgICB2YXIgeXRleHRPcHRpb25CdXR0b24gPSBodG1sKCdidXR0b24udXhlci1mbGF0LWJ1dHRvbicsXG5cdFx0XHQgICB7dGV4dENvbnRlbnQ6ICdVU0UgSU5URVJORVQgQVVESU8nLCBcblx0XHRcdCAgICBvbnRvdWNoZG93bjogZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpO2NsaWNrLmNhbGwoeXRleHQsIGUpfVxuXHRcdFx0ICAgIH0pO1xuXG4vLyAgICB0b3VjaGRvd24uc3RhcnQoeXRleHRCdXR0b24pO1xuLy8gICAgeXRleHRMYWJlbC5hcHBlbmRDaGlsZCh5dGV4dCk7XG4gICAgeXRleHRPcHRpb25MYWJlbC5hcHBlbmRDaGlsZCh5dGV4dE9wdGlvbkJ1dHRvbik7XG4gICAgb3B0aW9ucy5hcHBlbmRDaGlsZCh5dGV4dE9wdGlvbkxhYmVsKTtcblxuICAgIHZhciBmaWxlQ2FwTGFiZWwgPSBodG1sKCdsYWJlbC51eGVyLWZsYXRmaWVsZC1sYWJlbC5zb3VyY2VDYXBPcHRzTGFiZWwnKTtcbiAgICB2YXIgZmlsZUNhcCA9IGh0bWwoJ2lucHV0LnV4ZXItZmxhdGZpZWxkLWlucHV0Jywge3R5cGU6ICdmaWxlJywgbmFtZTogJ2ZpbGUnLCBvbmNoYW5nZTogY2hhbmdlfSk7XG4gICAgdmFyIGZpbGVDYXBCdXR0b24gPSBodG1sKCdidXR0b24udXhlci1mbGF0LWJ1dHRvbicsXG5cdFx0XHQgICB7dGV4dENvbnRlbnQ6ICdPUEVOIEEgTE9DQUwgQVVESU8gRklMRScsIFxuXHRcdFx0ICAgIG5hbWU6ICdmaWxlJ1xuXHRcdFx0ICAgIH0pO1xuXG5cbiAgICB0b3VjaGRvd24uc3RhcnQoZmlsZUNhcEJ1dHRvbik7XG4gICAgZmlsZUNhcExhYmVsLmFwcGVuZENoaWxkKGZpbGVDYXApO1xuICAgIGZpbGVDYXBMYWJlbC5hcHBlbmRDaGlsZChmaWxlQ2FwQnV0dG9uKTtcbiAgICBvcHRpb25zLmFwcGVuZENoaWxkKGZpbGVDYXBMYWJlbCk7XG5cblxuICAgIHZhciBtaWNsaW5lTGFiZWwgPSBodG1sKCdsYWJlbC51eGVyLWZsYXRmaWVsZC1sYWJlbC5zb3VyY2VDYXBPcHRzTGFiZWwnKTtcbiAgICB2YXIgbWljbGluZSA9IGh0bWwoJ2J1dHRvbi51eGVyLWZsYXQtYnV0dG9uJywgXG5cdFx0ICAgICAgIHt0ZXh0Q29udGVudDogJ0NBUFRVUkUgTUlDIC8gTElORS1JTicsXG5cdFx0XHRuYW1lOiAnbGluZScsIFxuXHRcdFx0b250b3VjaGRvd246IGZ1bmN0aW9uKGUpe2NsaWNrLmNhbGwobWljbGluZSwgZSl9XG5cdFx0ICAgICAgIH0pO1xuXG5cbiAgICB0b3VjaGRvd24uc3RhcnQobWljbGluZSk7XG4gICAgbWljbGluZUxhYmVsLmFwcGVuZENoaWxkKG1pY2xpbmUpO1xuICAgIG9wdGlvbnMuYXBwZW5kQ2hpbGQobWljbGluZUxhYmVsKTtcblxuICAgIHZhciBwbGF5YnV0dG9uTGFiZWwgPSBodG1sKCdsYWJlbC51eGVyLWZsYXRmaWVsZC1sYWJlbCcpO1xuICAgIHZhciBwbGF5YnV0dG9uID0gaHRtbCgnYnV0dG9uLnV4ZXItZmxhdC1idXR0b24nLCBcblx0XHQgICAgICAge3RleHRDb250ZW50OiAnUExBWScsXG5cdFx0XHRuYW1lOiAncGxheScsXG5cdFx0XHRvbnRvdWNoZG93bjogZnVuY3Rpb24oZSl7Y2xpY2suY2FsbChwbGF5YnV0dG9uLCBlKX1cblx0XHQgICAgICAgfSk7XG5cbiAvLyAgIHRvdWNoZG93bi5zdGFydChwbGF5YnV0dG9uKTtcbiAvLyAgIHBsYXlidXR0b25MYWJlbC5hcHBlbmRDaGlsZChwbGF5YnV0dG9uKTtcbiAvLyAgIF9maWVsZHNldC5hcHBlbmRDaGlsZChwbGF5YnV0dG9uTGFiZWwpO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX2ZpZWxkc2V0KVxuXG4gICAgdmFyIGZzZXQgPSBfZmllbGRzZXQ7XG5cbiAgICByZXR1cm4gX2ZpZWxkc2V0O1xuXG59XG5cbmZ1bmN0aW9uIG1ha2VTdHlsZShzdHIpe1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS5pZCA9ICd1eGVyLWZsYXRmaWVsZC1zdHlsZSc7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gc3RyO1xuICByZXR1cm4gc3R5bGVcbn1cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSl7ZS5wcmV2ZW50RGVmYXVsdCgpfTtcbiIsInZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBzc24gPSByZXF1aXJlKCcuL3N5bnRoLXNlcnZlci1ub2RlJyk7XG52YXIgaHlwZXJxdWVzdCA9IHJlcXVpcmUoJ2h5cGVycXVlc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApe1xuXG4gICAgdmFyIGNvbnRleHQgPSBhcHAubWFzdGVyO1xuXG4gICAgcmV0dXJuIHtjaGFuZ2U6IGNoYW5nZSwgY2xpY2s6IGNsaWNrfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlKGUpe1xuXHRpZih0aGlzLm5hbWUgPT0gJ3VybCcpIHJldHVyblxuXHRpZih0aGlzLm5hbWUgPT0gJ2ZpbGUnKXtcblxuXHQgICAgaWYodGhpcy5maWxlc1swXS5zaXplID4gMTkyMDAwMCl7XG5cdFx0dmFyIGF1ZGlvID0gbmV3IEF1ZGlvKCk7XG5cdFx0YXVkaW8uc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5maWxlc1swXSk7XG5cdFx0YXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIGZ1bmN0aW9uKCl7XG5cdFx0ICAgIHZhciBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShhdWRpbyk7XG5cdFx0ICAgIGFwcC5lbWl0KCdzb3VyY2VDYXAnLCBudWxsLCBzb3VyY2UpXG5cdFx0fSwgdHJ1ZSlcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpe1xuXHRcdCAgICB2YXIgYnVmZmVyID0gZS50YXJnZXQucmVzdWx0O1xuXHRcdCAgICB2YXIgc291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0XHQgICAgdHJ5e1xuXHRcdFx0dmFyIGJ1ZiA9IGNvbnRleHQuY3JlYXRlQnVmZmVyKGJ1ZmZlciwgdHJ1ZSk7XG5cdFx0XHRzb3VyY2UuYnVmZmVyID0gYnVmO1xuXHRcdFx0YXBwLmVtaXQoJ3NvdXJjZUNhcCcsIG51bGwsIHNvdXJjZSlcblx0XHQgICAgfSBcblx0XHQgICAgY2F0Y2goZSl7XG5cdFx0XHR2YXIgZXJyID0gbmV3IEVycm9yKCdFcnJvcjogUHJvYmFibHkgYW4gdW5zdXBwb3J0ZWQgZmlsZSB0eXBlLicpXG5cdFx0XHRhcHAuZW1pdCgnc291cmNlQ2FwJywgZXJyLCBudWxsKVxuXHRcdFx0Ly8gYW5kIHRoaXMgaXMgd2hlcmUgeW91IHdvdWxkIGRlY29kZSBpdCB3aXRoIEF1cm9yYSAuLi5cblx0XHQgICAgfVxuXHRcdH07XG5cdFx0dHJ5e1xuXHRcdCAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIodGhpcy5maWxlc1swXSk7XG5cdFx0fSBcblx0XHRjYXRjaChlKXtcblx0XHQgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRXJyb3I6IFByb2JhYmx5IGFuIHVuc3VwcG9ydGVkIGZpbGUgdHlwZS4nKVxuXHRcdCAgICBhcHAuZW1pdCgnc291cmNlQ2FwJywgZXJyLCBudWxsKVxuXHRcdH1cblx0ICAgIH1cblx0fVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsaWNrKGUpe1xuXG5cdGlmKHRoaXMubmFtZSA9PSAndXJsJyl7XG5cdCAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICB2YXIgdXJpID0gdGhpcy52YWx1ZTtcblx0ICAgIGlmKHVyaS5sZW5ndGgpe1xuXHRcdHZhciBwYXJzZWQgPSB1cmwucGFyc2UodXJpLCB0cnVlKTtcblx0XHRcblx0XHRpZigoKHBhcnNlZC5zbGFzaGVzIHx8IHBhcnNlZC5wcm90b2NvbCkgJiYgKHBhcnNlZC5ob3N0bmFtZS5tYXRjaCgneW91dHViZS5jb20nKSkpIHx8IFxuXHRcdCAgIChwYXJzZWQucGF0aG5hbWUgJiYgcGFyc2VkLnBhdGhuYW1lLm1hdGNoKCd5b3V0dWJlLmNvbScpKSkge1xuXG5cdFx0ICAgIGlmKE1vZGVybml6ci50b3VjaCl7XG5cblx0XHRcdHZhciBzb3VyY2UgPSBzc24obWFzdGVyLCB1cmksIGZ1bmN0aW9uKGVyciwgc291cmNlKXtcblx0XHRcdCAgICBhcHAuZW1pdCgnc291cmNlQ2FwJywgZXJyLCBzb3VyY2UpXG5cdFx0XHR9KTtcblxuXHRcdCAgICB9XG5cblx0XHQgICAgZWxzZXtcblxuXHRcdFx0Ly8gdGhpcyBpcyBub3QgZ29ubmEgaGFwcGVuLi4uXG5cdFx0XHR2YXIgaWQgPSBwYXJzZWQuaG9zdG5hbWUgPT09ICd5b3V0dS5iZScgXG5cdFx0XHQgICAgPyBwYXJzZWQucGF0aG5hbWUuc2xpY2UoMSkgOiBwYXJzZWQucXVlcnkudjtcblxuXHRcdFx0aHlwZXJxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDoxMTAwMi9nZXRfaW5mbz8nK3VyaSwgZnVuY3Rpb24oZXJyLCByZXMpe1xuXHRcdFx0ICAgIHJlcy5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuXG5cdFx0XHRcdHZhciBVUkkgPSBkYXRhO1xuXHRcdFx0XHR2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuXHRcdFx0XHR2aWRlby5zcmMgPSBVUkk7XG5cdFx0XHRcdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdCAgICB2YXIgc291cmNlID0gY29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UodmlkZW8pO1xuXHRcdFx0XHQgICAgYXBwLmVtaXQoJ3NvdXJjZUNhcCcsIG51bGwsIHNvdXJjZSlcblx0XHRcdFx0fSk7XG5cblx0XHRcdCAgICB9KVxuXHRcdFx0fSlcblxuXHRcdCAgICB9XG5cdFx0fVxuXHRcdGVsc2UgY29uc29sZS5sb2coJ251cCcpO1xuXHQgICAgfVxuXHR9XG5cdGlmKHRoaXMubmFtZSA9PSAnZmlsZScpe1xuXHR9XG5cdGlmKHRoaXMubmFtZSA9PSAnbGluZScpeyAvLyBnZXRVc2VyTWVkaWFcblx0ICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoe2F1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2V9LCBmdW5jdGlvbihzdHJlYW0pe1xuXHRcdHZhciBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG5cdFx0YXBwLmVtaXQoJ3NvdXJjZUNhcCcsIG51bGwsIHNvdXJjZSk7XG5cdCAgICB9KVxuXHR9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtYWtlU3R5bGUoc3RyKXtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0c3R5bGUuaWQgPSAndXhlci1mbGF0ZmllbGQtc3R5bGUnO1xuXHRzdHlsZS50ZXh0Q29udGVudCA9IHN0cjtcblx0cmV0dXJuIHN0eWxlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSl7ZS5wcmV2ZW50RGVmYXVsdCgpfTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxvYXRDb25jYXRcblxuZnVuY3Rpb24gZmxvYXRDb25jYXQoZmlyc3QsIHNlY29uZClcbntcblxuICAgIGlmKCFmaXJzdCkgcmV0dXJuIHNlY29uZDtcblxuICAgIHZhciBmaXJzdExlbmd0aCA9IGZpcnN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShmaXJzdExlbmd0aCArIHNlY29uZC5sZW5ndGgpO1xuXG4gICAgcmVzdWx0LnNldChmaXJzdCk7XG4gICAgcmVzdWx0LnNldChzZWNvbmQsIGZpcnN0TGVuZ3RoKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCIoZnVuY3Rpb24oKXt3ZWJraXRBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFByb2Nlc3NvciA9IHdlYmtpdEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlSmF2YVNjcmlwdE5vZGVcbmlmKCF3aW5kb3cuVVJMKSB3aW5kb3cuVVJMID0ge2NyZWF0ZU9iamVjdFVSTDogd2luZG93LndlYmtpdFVSTC5jcmVhdGVPYmplY3RVUkx9XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgZW5zbGF2ZSA9IHJlcXVpcmUoJ3dvcmstc2xhdmUnKTtcbnZhciBidWZmZXJzID0gcmVxdWlyZSgnYnVmZmVycycpO1xuXG52YXIgZmxvYXRDb25jYXQgPSByZXF1aXJlKCcuL2Zsb2F0Q29uY2F0LmpzJyk7XG5cbnZhciB3b3JrZXIgPSBcInRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24oZXZ0KXtcXG5cXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgZXZ0ID0gZXZ0O1xcbiAgICB2YXIgc2FtcGxlUmF0ZSA9IGV2dC5kYXRhLnNhbXBsZVJhdGU7XFxuICAgIHZhciByZXNhbXBsZXJzID0gW107XFxuICAgIHZhciBpZCA9IGV2dC5kYXRhLmlkO1xcbiAgICB2YXIgY2hhbnMgPSAxO1xcblxcbiAgICB2YXIgcGxheWVyID0gQVYuQXNzZXQuZnJvbVVSTCgnaHR0cDovLzEwLjAuMC4zOjExMDAyL3lvdXR1YmU/JyArIGV2dC5kYXRhLnVyaSk7XFxuXFxuICAgIHBsYXllci5vbignZm9ybWF0JywgZnVuY3Rpb24oZCl7XFxuXFxuXFxuXFx0ZC5zb3VyY2VMZW5ndGggPSBwbGF5ZXIuc291cmNlLmxlbmd0aDtcXG5cXHRjaGFucyA9IGQuY2hhbm5lbHNQZXJGcmFtZTtcXG5cXG5cXHR2YXIgYnVmZmVyU2l6ZSA9IE1hdGguY2VpbCg0MDk2IC8gKHNhbXBsZVJhdGUgLyBkLnNhbXBsZVJhdGUpKTtcXG5cXG5cXHRmb3IodmFyIHggPSAwOyB4IDwgY2hhbnM7IHgrKyl7XFxuXFx0ICAgIHJlc2FtcGxlcnNbeF0gPSBuZXcgUmVzYW1wbGVyKGQuc2FtcGxlUmF0ZSwgc2FtcGxlUmF0ZSwgMSwgYnVmZmVyU2l6ZSk7XFxuXFx0fVxcblxcdFxcblxcdHNlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6ICdtZXRhJywgZGF0YTogZH0pO1xcblxcbiAgICB9KTtcXG5cXG4gICAgcGxheWVyLm9uKCdtZXRhJywgZnVuY3Rpb24oZCl7XFxuXFx0c2VsZi5wb3N0TWVzc2FnZSh7aWQ6IGlkLCB0eXBlOiAnbWV0YScsIGRhdGE6IGR9KVxcbiAgICB9KTtcXG5cXG4gICAgcGxheWVyLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKGV2dCl7XFxuXFx0c2VsZi5wb3N0TWVzc2FnYWUoe2lkOiBpZCwgdHlwZTogJ3Byb2dyZXNzJywgZGF0YTogZXZ0fSlcXG4gICAgfSk7XFxuXFxuICAgIHBsYXllci5vbignZGF0YScsIGZ1bmN0aW9uKGJ1ZkFycmF5KXtcXG4gICAgICAgIGZvcih4IGluIHJlc2FtcGxlcnMpe1xcblxcdCAgICBidWZBcnJheVt4XSA9IHJlc2FtcGxlcnNbeF0ucmVzYW1wbGVyKGJ1ZkFycmF5W3hdKVxcblxcdH1cXG5cXHRzZWxmLnBvc3RNZXNzYWdlKHtpZDogaWQsIGJ1ZmZlcjogYnVmQXJyYXl9KVxcbiAgICB9KTtcXG5cXG4gICAgcGxheWVyLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xcblxcdHNlbGYucG9zdE1lc3NhZ2Uoe2lkOiBpZCwgdHlwZTogJ2VuZCd9KVxcbiAgICB9KTtcXG5cXG4gICAgcGxheWVyLnN0YXJ0KCk7XFxufVxcblxcblwiO1xudmFyIGF1cm9yYSA9IFwiLypcXG4gKiBUaGlzIHJlc2FtcGxlciBpcyBmcm9tIFhBdWRpb0pTOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhbnRnYWxpdHovWEF1ZGlvSlNcXG4gKiBQbGFubmVkIHRvIGJlIHJlcGxhY2VkIHdpdGggc3JjLmpzLCBldmVudHVhbGx5OiBodHRwczovL2dpdGh1Yi5jb20vanVzc2kta2FsbGlva29za2kvc3JjLmpzXFxuICovXFxuXFxuLy9KYXZhU2NyaXB0IEF1ZGlvIFJlc2FtcGxlciAoYykgMjAxMSAtIEdyYW50IEdhbGl0elxcbmZ1bmN0aW9uIFJlc2FtcGxlcihmcm9tU2FtcGxlUmF0ZSwgdG9TYW1wbGVSYXRlLCBjaGFubmVscywgb3V0cHV0QnVmZmVyU2l6ZSwgbm9SZXR1cm4pIHtcXG5cXHR0aGlzLmZyb21TYW1wbGVSYXRlID0gZnJvbVNhbXBsZVJhdGU7XFxuXFx0dGhpcy50b1NhbXBsZVJhdGUgPSB0b1NhbXBsZVJhdGU7XFxuXFx0dGhpcy5jaGFubmVscyA9IGNoYW5uZWxzIHwgMDtcXG5cXHR0aGlzLm91dHB1dEJ1ZmZlclNpemUgPSBvdXRwdXRCdWZmZXJTaXplO1xcblxcdHRoaXMubm9SZXR1cm4gPSAhIW5vUmV0dXJuO1xcblxcdHRoaXMuaW5pdGlhbGl6ZSgpO1xcbn1cXG5cXG5SZXNhbXBsZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0Ly9QZXJmb3JtIHNvbWUgY2hlY2tzOlxcblxcdGlmICh0aGlzLmZyb21TYW1wbGVSYXRlID4gMCAmJiB0aGlzLnRvU2FtcGxlUmF0ZSA+IDAgJiYgdGhpcy5jaGFubmVscyA+IDApIHtcXG5cXHRcXHRpZiAodGhpcy5mcm9tU2FtcGxlUmF0ZSA9PSB0aGlzLnRvU2FtcGxlUmF0ZSkge1xcblxcdFxcdFxcdC8vU2V0dXAgYSByZXNhbXBsZXIgYnlwYXNzOlxcblxcdFxcdFxcdHRoaXMucmVzYW1wbGVyID0gdGhpcy5ieXBhc3NSZXNhbXBsZXI7XFx0XFx0Ly9SZXNhbXBsZXIganVzdCByZXR1cm5zIHdoYXQgd2FzIHBhc3NlZCB0aHJvdWdoLlxcblxcdFxcdFxcdHRoaXMucmF0aW9XZWlnaHQgPSAxO1xcblxcdFxcdH1cXG5cXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5mcm9tU2FtcGxlUmF0ZSA8IHRoaXMudG9TYW1wbGVSYXRlKSB7XFxuXFx0XFx0XFx0XFx0LypcXG5cXHRcXHRcXHRcXHRcXHRVc2UgZ2VuZXJpYyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpZiB1cHNhbXBsaW5nLFxcblxcdFxcdFxcdFxcdFxcdGFzIGxpbmVhciBpbnRlcnBvbGF0aW9uIHByb2R1Y2VzIGEgZ3JhZGllbnQgdGhhdCB3ZSB3YW50XFxuXFx0XFx0XFx0XFx0XFx0YW5kIHdvcmtzIGZpbmUgd2l0aCB0d28gaW5wdXQgc2FtcGxlIHBvaW50cyBwZXIgb3V0cHV0IGluIHRoaXMgY2FzZS5cXG5cXHRcXHRcXHRcXHQqL1xcblxcdFxcdFxcdFxcdHRoaXMuY29tcGlsZUxpbmVhckludGVycG9sYXRpb25GdW5jdGlvbigpO1xcblxcdFxcdFxcdFxcdHRoaXMubGFzdFdlaWdodCA9IDE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGVsc2Uge1xcblxcdFxcdFxcdFxcdC8qXFxuXFx0XFx0XFx0XFx0XFx0Q3VzdG9tIHJlc2FtcGxlciBJIHdyb3RlIHRoYXQgZG9lc24ndCBza2lwIHNhbXBsZXNcXG5cXHRcXHRcXHRcXHRcXHRsaWtlIHN0YW5kYXJkIGxpbmVhciBpbnRlcnBvbGF0aW9uIGluIGhpZ2ggZG93bnNhbXBsaW5nLlxcblxcdFxcdFxcdFxcdFxcdFRoaXMgaXMgbW9yZSBhY2N1cmF0ZSB0aGFuIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIGRvd25zYW1wbGluZy5cXG5cXHRcXHRcXHRcXHQqL1xcblxcdFxcdFxcdFxcdHRoaXMuY29tcGlsZU11bHRpVGFwRnVuY3Rpb24oKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRhaWxFeGlzdHMgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGlzLmxhc3RXZWlnaHQgPSAwO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLnJhdGlvV2VpZ2h0ID0gdGhpcy5mcm9tU2FtcGxlUmF0ZSAvIHRoaXMudG9TYW1wbGVSYXRlO1xcblxcdFxcdFxcdHRoaXMuaW5pdGlhbGl6ZUJ1ZmZlcnMoKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdGVsc2Uge1xcblxcdFxcdHRocm93KG5ldyBFcnJvcihcXFwiSW52YWxpZCBzZXR0aW5ncyBzcGVjaWZpZWQgZm9yIHRoZSByZXNhbXBsZXIuXFxcIikpO1xcblxcdH1cXG59O1xcblxcblJlc2FtcGxlci5wcm90b3R5cGUuY29tcGlsZUxpbmVhckludGVycG9sYXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG5cXHR2YXIgdG9Db21waWxlID0gXFxcInZhciBidWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xcXFxcXG5cXHR2YXIgb3V0TGVuZ3RoID0gdGhpcy5vdXRwdXRCdWZmZXJTaXplO1xcXFxcXG5cXHRpZiAoKGJ1ZmZlckxlbmd0aCAlIFxcXCIgKyB0aGlzLmNoYW5uZWxzICsgXFxcIikgPT0gMCkge1xcXFxcXG5cXHRcXHRpZiAoYnVmZmVyTGVuZ3RoID4gMCkge1xcXFxcXG5cXHRcXHRcXHR2YXIgcmF0aW9XZWlnaHQgPSB0aGlzLnJhdGlvV2VpZ2h0O1xcXFxcXG5cXHRcXHRcXHR2YXIgd2VpZ2h0ID0gdGhpcy5sYXN0V2VpZ2h0O1xcXFxcXG5cXHRcXHRcXHR2YXIgZmlyc3RXZWlnaHQgPSAwO1xcXFxcXG5cXHRcXHRcXHR2YXIgc2Vjb25kV2VpZ2h0ID0gMDtcXFxcXFxuXFx0XFx0XFx0dmFyIHNvdXJjZU9mZnNldCA9IDA7XFxcXFxcblxcdFxcdFxcdHZhciBvdXRwdXRPZmZzZXQgPSAwO1xcXFxcXG5cXHRcXHRcXHR2YXIgb3V0cHV0QnVmZmVyID0gdGhpcy5vdXRwdXRCdWZmZXI7XFxcXFxcblxcdFxcdFxcdGZvciAoOyB3ZWlnaHQgPCAxOyB3ZWlnaHQgKz0gcmF0aW9XZWlnaHQpIHtcXFxcXFxuXFx0XFx0XFx0XFx0c2Vjb25kV2VpZ2h0ID0gd2VpZ2h0ICUgMTtcXFxcXFxuXFx0XFx0XFx0XFx0Zmlyc3RXZWlnaHQgPSAxIC0gc2Vjb25kV2VpZ2h0O1xcXCI7XFxuXFx0Zm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLmNoYW5uZWxzOyArK2NoYW5uZWwpIHtcXG5cXHRcXHR0b0NvbXBpbGUgKz0gXFxcIm91dHB1dEJ1ZmZlcltvdXRwdXRPZmZzZXQrK10gPSAodGhpcy5sYXN0T3V0cHV0W1xcXCIgKyBjaGFubmVsICsgXFxcIl0gKiBmaXJzdFdlaWdodCkgKyAoYnVmZmVyW1xcXCIgKyBjaGFubmVsICsgXFxcIl0gKiBzZWNvbmRXZWlnaHQpO1xcXCI7XFxuXFx0fVxcblxcdHRvQ29tcGlsZSArPSBcXFwifVxcXFxcXG5cXHRcXHRcXHR3ZWlnaHQgLT0gMTtcXFxcXFxuXFx0XFx0XFx0Zm9yIChidWZmZXJMZW5ndGggLT0gXFxcIiArIHRoaXMuY2hhbm5lbHMgKyBcXFwiLCBzb3VyY2VPZmZzZXQgPSBNYXRoLmZsb29yKHdlaWdodCkgKiBcXFwiICsgdGhpcy5jaGFubmVscyArIFxcXCI7IG91dHB1dE9mZnNldCA8IG91dExlbmd0aCAmJiBzb3VyY2VPZmZzZXQgPCBidWZmZXJMZW5ndGg7KSB7XFxcXFxcblxcdFxcdFxcdFxcdHNlY29uZFdlaWdodCA9IHdlaWdodCAlIDE7XFxcXFxcblxcdFxcdFxcdFxcdGZpcnN0V2VpZ2h0ID0gMSAtIHNlY29uZFdlaWdodDtcXFwiO1xcblxcdGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5jaGFubmVsczsgKytjaGFubmVsKSB7XFxuXFx0XFx0dG9Db21waWxlICs9IFxcXCJvdXRwdXRCdWZmZXJbb3V0cHV0T2Zmc2V0KytdID0gKGJ1ZmZlcltzb3VyY2VPZmZzZXRcXFwiICsgKChjaGFubmVsID4gMCkgPyAoXFxcIiArIFxcXCIgKyBjaGFubmVsKSA6IFxcXCJcXFwiKSArIFxcXCJdICogZmlyc3RXZWlnaHQpICsgKGJ1ZmZlcltzb3VyY2VPZmZzZXQgKyBcXFwiICsgKHRoaXMuY2hhbm5lbHMgKyBjaGFubmVsKSArIFxcXCJdICogc2Vjb25kV2VpZ2h0KTtcXFwiO1xcblxcdH1cXG5cXHR0b0NvbXBpbGUgKz0gXFxcIndlaWdodCArPSByYXRpb1dlaWdodDtcXFxcXFxuXFx0XFx0XFx0XFx0c291cmNlT2Zmc2V0ID0gTWF0aC5mbG9vcih3ZWlnaHQpICogXFxcIiArIHRoaXMuY2hhbm5lbHMgKyBcXFwiO1xcXFxcXG5cXHRcXHRcXHR9XFxcIjtcXG5cXHRmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuY2hhbm5lbHM7ICsrY2hhbm5lbCkge1xcblxcdFxcdHRvQ29tcGlsZSArPSBcXFwidGhpcy5sYXN0T3V0cHV0W1xcXCIgKyBjaGFubmVsICsgXFxcIl0gPSBidWZmZXJbc291cmNlT2Zmc2V0KytdO1xcXCI7XFxuXFx0fVxcblxcdHRvQ29tcGlsZSArPSBcXFwidGhpcy5sYXN0V2VpZ2h0ID0gd2VpZ2h0ICUgMTtcXFxcXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYnVmZmVyU2xpY2Uob3V0cHV0T2Zmc2V0KTtcXFxcXFxuXFx0XFx0fVxcXFxcXG5cXHRcXHRlbHNlIHtcXFxcXFxuXFx0XFx0XFx0cmV0dXJuICh0aGlzLm5vUmV0dXJuKSA/IDAgOiBbXTtcXFxcXFxuXFx0XFx0fVxcXFxcXG5cXHR9XFxcXFxcblxcdGVsc2Uge1xcXFxcXG5cXHRcXHR0aHJvdyhuZXcgRXJyb3IoXFxcXFxcXCJCdWZmZXIgd2FzIG9mIGluY29ycmVjdCBzYW1wbGUgbGVuZ3RoLlxcXFxcXFwiKSk7XFxcXFxcblxcdH1cXFwiO1xcblxcdHRoaXMucmVzYW1wbGVyID0gRnVuY3Rpb24oXFxcImJ1ZmZlclxcXCIsIHRvQ29tcGlsZSk7XFxufTtcXG5cXG5SZXNhbXBsZXIucHJvdG90eXBlLmNvbXBpbGVNdWx0aVRhcEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xcblxcdHZhciB0b0NvbXBpbGUgPSBcXFwidmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XFxcXFxcblxcdHZhciBvdXRMZW5ndGggPSB0aGlzLm91dHB1dEJ1ZmZlclNpemU7XFxcXFxcblxcdGlmICgoYnVmZmVyTGVuZ3RoICUgXFxcIiArIHRoaXMuY2hhbm5lbHMgKyBcXFwiKSA9PSAwKSB7XFxcXFxcblxcdFxcdGlmIChidWZmZXJMZW5ndGggPiAwKSB7XFxcXFxcblxcdFxcdFxcdHZhciByYXRpb1dlaWdodCA9IHRoaXMucmF0aW9XZWlnaHQ7XFxcXFxcblxcdFxcdFxcdHZhciB3ZWlnaHQgPSAwO1xcXCI7XFxuXFx0Zm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLmNoYW5uZWxzOyArK2NoYW5uZWwpIHtcXG5cXHRcXHR0b0NvbXBpbGUgKz0gXFxcInZhciBvdXRwdXRcXFwiICsgY2hhbm5lbCArIFxcXCIgPSAwO1xcXCJcXG5cXHR9XFxuXFx0dG9Db21waWxlICs9IFxcXCJ2YXIgYWN0dWFsUG9zaXRpb24gPSAwO1xcXFxcXG5cXHRcXHRcXHR2YXIgYW1vdW50VG9OZXh0ID0gMDtcXFxcXFxuXFx0XFx0XFx0dmFyIGFscmVhZHlQcm9jZXNzZWRUYWlsID0gIXRoaXMudGFpbEV4aXN0cztcXFxcXFxuXFx0XFx0XFx0dGhpcy50YWlsRXhpc3RzID0gZmFsc2U7XFxcXFxcblxcdFxcdFxcdHZhciBvdXRwdXRCdWZmZXIgPSB0aGlzLm91dHB1dEJ1ZmZlcjtcXFxcXFxuXFx0XFx0XFx0dmFyIG91dHB1dE9mZnNldCA9IDA7XFxcXFxcblxcdFxcdFxcdHZhciBjdXJyZW50UG9zaXRpb24gPSAwO1xcXFxcXG5cXHRcXHRcXHRkbyB7XFxcXFxcblxcdFxcdFxcdFxcdGlmIChhbHJlYWR5UHJvY2Vzc2VkVGFpbCkge1xcXFxcXG5cXHRcXHRcXHRcXHRcXHR3ZWlnaHQgPSByYXRpb1dlaWdodDtcXFwiO1xcblxcdGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLmNoYW5uZWxzOyArK2NoYW5uZWwpIHtcXG5cXHRcXHR0b0NvbXBpbGUgKz0gXFxcIm91dHB1dFxcXCIgKyBjaGFubmVsICsgXFxcIiA9IDA7XFxcIlxcblxcdH1cXG5cXHR0b0NvbXBpbGUgKz0gXFxcIn1cXFxcXFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxcXFxcblxcdFxcdFxcdFxcdFxcdHdlaWdodCA9IHRoaXMubGFzdFdlaWdodDtcXFwiO1xcblxcdGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLmNoYW5uZWxzOyArK2NoYW5uZWwpIHtcXG5cXHRcXHR0b0NvbXBpbGUgKz0gXFxcIm91dHB1dFxcXCIgKyBjaGFubmVsICsgXFxcIiA9IHRoaXMubGFzdE91dHB1dFtcXFwiICsgY2hhbm5lbCArIFxcXCJdO1xcXCJcXG5cXHR9XFxuXFx0dG9Db21waWxlICs9IFxcXCJhbHJlYWR5UHJvY2Vzc2VkVGFpbCA9IHRydWU7XFxcXFxcblxcdFxcdFxcdFxcdH1cXFxcXFxuXFx0XFx0XFx0XFx0d2hpbGUgKHdlaWdodCA+IDAgJiYgYWN0dWFsUG9zaXRpb24gPCBidWZmZXJMZW5ndGgpIHtcXFxcXFxuXFx0XFx0XFx0XFx0XFx0YW1vdW50VG9OZXh0ID0gMSArIGFjdHVhbFBvc2l0aW9uIC0gY3VycmVudFBvc2l0aW9uO1xcXFxcXG5cXHRcXHRcXHRcXHRcXHRpZiAod2VpZ2h0ID49IGFtb3VudFRvTmV4dCkge1xcXCI7XFxuXFx0Zm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuY2hhbm5lbHM7ICsrY2hhbm5lbCkge1xcblxcdFxcdHRvQ29tcGlsZSArPSBcXFwib3V0cHV0XFxcIiArIGNoYW5uZWwgKyBcXFwiICs9IGJ1ZmZlclthY3R1YWxQb3NpdGlvbisrXSAqIGFtb3VudFRvTmV4dDtcXFwiXFxuXFx0fVxcblxcdHRvQ29tcGlsZSArPSBcXFwiY3VycmVudFBvc2l0aW9uID0gYWN0dWFsUG9zaXRpb247XFxcXFxcblxcdFxcdFxcdFxcdFxcdFxcdHdlaWdodCAtPSBhbW91bnRUb05leHQ7XFxcXFxcblxcdFxcdFxcdFxcdFxcdH1cXFxcXFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxcIjtcXG5cXHRmb3IgKGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5jaGFubmVsczsgKytjaGFubmVsKSB7XFxuXFx0XFx0dG9Db21waWxlICs9IFxcXCJvdXRwdXRcXFwiICsgY2hhbm5lbCArIFxcXCIgKz0gYnVmZmVyW2FjdHVhbFBvc2l0aW9uXFxcIiArICgoY2hhbm5lbCA+IDApID8gKFxcXCIgKyBcXFwiICsgY2hhbm5lbCkgOiBcXFwiXFxcIikgKyBcXFwiXSAqIHdlaWdodDtcXFwiXFxuXFx0fVxcblxcdHRvQ29tcGlsZSArPSBcXFwiY3VycmVudFBvc2l0aW9uICs9IHdlaWdodDtcXFxcXFxuXFx0XFx0XFx0XFx0XFx0XFx0d2VpZ2h0ID0gMDtcXFxcXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxcXFxcblxcdFxcdFxcdFxcdFxcdH1cXFxcXFxuXFx0XFx0XFx0XFx0fVxcXFxcXG5cXHRcXHRcXHRcXHRpZiAod2VpZ2h0ID09IDApIHtcXFwiO1xcblxcdGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLmNoYW5uZWxzOyArK2NoYW5uZWwpIHtcXG5cXHRcXHR0b0NvbXBpbGUgKz0gXFxcIm91dHB1dEJ1ZmZlcltvdXRwdXRPZmZzZXQrK10gPSBvdXRwdXRcXFwiICsgY2hhbm5lbCArIFxcXCIgLyByYXRpb1dlaWdodDtcXFwiXFxuXFx0fVxcblxcdHRvQ29tcGlsZSArPSBcXFwifVxcXFxcXG5cXHRcXHRcXHRcXHRlbHNlIHtcXFxcXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5sYXN0V2VpZ2h0ID0gd2VpZ2h0O1xcXCI7XFxuXFx0Zm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuY2hhbm5lbHM7ICsrY2hhbm5lbCkge1xcblxcdFxcdHRvQ29tcGlsZSArPSBcXFwidGhpcy5sYXN0T3V0cHV0W1xcXCIgKyBjaGFubmVsICsgXFxcIl0gPSBvdXRwdXRcXFwiICsgY2hhbm5lbCArIFxcXCI7XFxcIlxcblxcdH1cXG5cXHR0b0NvbXBpbGUgKz0gXFxcInRoaXMudGFpbEV4aXN0cyA9IHRydWU7XFxcXFxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcXFxcXG5cXHRcXHRcXHRcXHR9XFxcXFxcblxcdFxcdFxcdH0gd2hpbGUgKGFjdHVhbFBvc2l0aW9uIDwgYnVmZmVyTGVuZ3RoICYmIG91dHB1dE9mZnNldCA8IG91dExlbmd0aCk7XFxcXFxcblxcdFxcdFxcdHJldHVybiB0aGlzLmJ1ZmZlclNsaWNlKG91dHB1dE9mZnNldCk7XFxcXFxcblxcdFxcdH1cXFxcXFxuXFx0XFx0ZWxzZSB7XFxcXFxcblxcdFxcdFxcdHJldHVybiAodGhpcy5ub1JldHVybikgPyAwIDogW107XFxcXFxcblxcdFxcdH1cXFxcXFxuXFx0fVxcXFxcXG5cXHRlbHNlIHtcXFxcXFxuXFx0XFx0dGhyb3cobmV3IEVycm9yKFxcXFxcXFwiQnVmZmVyIHdhcyBvZiBpbmNvcnJlY3Qgc2FtcGxlIGxlbmd0aC5cXFxcXFxcIikpO1xcXFxcXG5cXHR9XFxcIjtcXG5cXHR0aGlzLnJlc2FtcGxlciA9IEZ1bmN0aW9uKFxcXCJidWZmZXJcXFwiLCB0b0NvbXBpbGUpO1xcbn07XFxuXFxuUmVzYW1wbGVyLnByb3RvdHlwZS5ieXBhc3NSZXNhbXBsZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XFxuXFx0aWYgKHRoaXMubm9SZXR1cm4pIHtcXG5cXHRcXHQvL1NldCB0aGUgYnVmZmVyIHBhc3NlZCBhcyBvdXIgb3duLCBhcyB3ZSBkb24ndCBuZWVkIHRvIHJlc2FtcGxlIGl0OlxcblxcdFxcdHRoaXMub3V0cHV0QnVmZmVyID0gYnVmZmVyO1xcblxcdFxcdHJldHVybiBidWZmZXIubGVuZ3RoO1xcblxcdH1cXG5cXHRlbHNlIHtcXG5cXHRcXHQvL0p1c3QgcmV0dXJuIHRoZSBidWZmZXIgcGFzc3NlZDpcXG5cXHRcXHRyZXR1cm4gYnVmZmVyO1xcblxcdH1cXG59O1xcblxcblJlc2FtcGxlci5wcm90b3R5cGUuYnVmZmVyU2xpY2UgPSBmdW5jdGlvbiAoc2xpY2VBbW91bnQpIHtcXG5cXHRpZiAodGhpcy5ub1JldHVybikge1xcblxcdFxcdC8vSWYgd2UncmUgZ29pbmcgdG8gYWNjZXNzIHRoZSBwcm9wZXJ0aWVzIGRpcmVjdGx5IGZyb20gdGhpcyBvYmplY3Q6XFxuXFx0XFx0cmV0dXJuIHNsaWNlQW1vdW50O1xcblxcdH1cXG5cXHRlbHNlIHtcXG5cXHRcXHQvL1R5cGVkIGFycmF5IGFuZCBub3JtYWwgYXJyYXkgYnVmZmVyIHNlY3Rpb24gcmVmZXJlbmNpbmc6XFxuXFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5vdXRwdXRCdWZmZXIuc3ViYXJyYXkoMCwgc2xpY2VBbW91bnQpO1xcblxcdFxcdH1cXG5cXHRcXHRjYXRjaCAoZXJyb3IpIHtcXG5cXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdC8vUmVndWxhciBhcnJheSBwYXNzOlxcblxcdFxcdFxcdFxcdHRoaXMub3V0cHV0QnVmZmVyLmxlbmd0aCA9IHNsaWNlQW1vdW50O1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm91dHB1dEJ1ZmZlcjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y2F0Y2ggKGVycm9yKSB7XFxuXFx0XFx0XFx0XFx0Ly9OaWdodGx5IEZpcmVmb3ggNCB1c2VkIHRvIGhhdmUgdGhlIHN1YmFycmF5IGZ1bmN0aW9uIG5hbWVkIGFzIHNsaWNlOlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm91dHB1dEJ1ZmZlci5zbGljZSgwLCBzbGljZUFtb3VudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5SZXNhbXBsZXIucHJvdG90eXBlLmluaXRpYWxpemVCdWZmZXJzID0gZnVuY3Rpb24gKCkge1xcblxcdC8vSW5pdGlhbGl6ZSB0aGUgaW50ZXJuYWwgYnVmZmVyOlxcblxcdHRyeSB7XFxuXFx0XFx0dGhpcy5vdXRwdXRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0QnVmZmVyU2l6ZSk7XFxuXFx0XFx0dGhpcy5sYXN0T3V0cHV0ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNoYW5uZWxzKTtcXG5cXHR9XFxuXFx0Y2F0Y2ggKGVycm9yKSB7XFxuXFx0XFx0dGhpcy5vdXRwdXRCdWZmZXIgPSBbXTtcXG5cXHRcXHR0aGlzLmxhc3RPdXRwdXQgPSBbXTtcXG5cXHR9XFxufTtcXG5cXG4oZnVuY3Rpb24oKSB7XFxuICB2YXIgZ2xvYmFsO1xcblxcbiAgZ2xvYmFsID0gdGhpcztcXG4gIHZhciBBVjtcXG5cXG5BViA9IHt9O1xcblxcbnZhciBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcXG4gIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxcbiAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XFxuXFxuQVYuQmFzZSA9IChmdW5jdGlvbigpIHtcXG4gIHZhciBmblRlc3Q7XFxuXFxuICBmdW5jdGlvbiBCYXNlKCkge31cXG5cXG4gIGZuVGVzdCA9IC9cXFxcYl9zdXBlclxcXFxiLztcXG5cXG4gIEJhc2UuZXh0ZW5kID0gZnVuY3Rpb24ocHJvcCkge1xcbiAgICB2YXIgQ2xhc3MsIGZuLCBrZXksIGtleXMsIF9yZWYsIF9yZWYxLCBfc3VwZXI7XFxuXFxuICAgIENsYXNzID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgICAgIF9fZXh0ZW5kcyhDbGFzcywgX3N1cGVyKTtcXG5cXG4gICAgICBmdW5jdGlvbiBDbGFzcygpIHtcXG4gICAgICAgIF9yZWYgPSBDbGFzcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgIHJldHVybiBfcmVmO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ2xhc3M7XFxuXFxuICAgIH0pKHRoaXMpO1xcbiAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMoQ2xhc3MucHJvdG90eXBlKTtcXG4gICAgICBwcm9wLmNhbGwoQ2xhc3MsIENsYXNzKTtcXG4gICAgICBwcm9wID0ge307XFxuICAgICAgX3JlZjEgPSBDbGFzcy5wcm90b3R5cGU7XFxuICAgICAgZm9yIChrZXkgaW4gX3JlZjEpIHtcXG4gICAgICAgIGZuID0gX3JlZjFba2V5XTtcXG4gICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChrZXlzLCBrZXkpIDwgMCkge1xcbiAgICAgICAgICBwcm9wW2tleV0gPSBmbjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgX3N1cGVyID0gQ2xhc3MuX19zdXBlcl9fO1xcbiAgICBmb3IgKGtleSBpbiBwcm9wKSB7XFxuICAgICAgZm4gPSBwcm9wW2tleV07XFxuICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBmblRlc3QudGVzdChmbikpIHtcXG4gICAgICAgIChmdW5jdGlvbihrZXksIGZuKSB7XFxuICAgICAgICAgIHJldHVybiBDbGFzcy5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHZhciByZXQsIHRtcDtcXG5cXG4gICAgICAgICAgICB0bXAgPSB0aGlzLl9zdXBlcjtcXG4gICAgICAgICAgICB0aGlzLl9zdXBlciA9IF9zdXBlcltrZXldO1xcbiAgICAgICAgICAgIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICAgICAgdGhpcy5fc3VwZXIgPSB0bXA7XFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pKGtleSwgZm4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBDbGFzcy5wcm90b3R5cGVba2V5XSA9IGZuO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gQ2xhc3M7XFxuICB9O1xcblxcbiAgcmV0dXJuIEJhc2U7XFxuXFxufSkoKTtcXG4vL2ltcG9ydCBcXFwiY29yZS9iYXNlLmNvZmZlZVxcXCI7XFxuXFxuQVYuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xcbiAgdmFyIEJsb2JCdWlsZGVyLCBVUkw7XFxuXFxuICBmdW5jdGlvbiBCdWZmZXIoZGF0YSkge1xcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGg7XFxuICAgIHRoaXMubmV4dCA9IG51bGw7XFxuICAgIHRoaXMucHJldiA9IG51bGw7XFxuICB9XFxuXFxuICBCdWZmZXIuYWxsb2NhdGUgPSBmdW5jdGlvbihzaXplKSB7XFxuICAgIHJldHVybiBuZXcgQVYuQnVmZmVyKG5ldyBVaW50OEFycmF5KHNpemUpKTtcXG4gIH07XFxuXFxuICBCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIG5ldyBBVi5CdWZmZXIobmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhKSk7XFxuICB9O1xcblxcbiAgQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBsZW5ndGgpIHtcXG4gICAgaWYgKHBvc2l0aW9uID09PSAwICYmIGxlbmd0aCA+PSB0aGlzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybiBuZXcgQVYuQnVmZmVyKHRoaXMuZGF0YSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIG5ldyBBVi5CdWZmZXIodGhpcy5kYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCkpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXIgfHwgZ2xvYmFsLk1vekJsb2JCdWlsZGVyIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlcjtcXG5cXG4gIFVSTCA9IGdsb2JhbC5VUkwgfHwgZ2xvYmFsLndlYmtpdFVSTCB8fCBnbG9iYWwubW96VVJMO1xcblxcbiAgQnVmZmVyLm1ha2VCbG9iID0gZnVuY3Rpb24oZGF0YSwgdHlwZSkge1xcbiAgICB2YXIgYmI7XFxuXFxuICAgIGlmICh0eXBlID09IG51bGwpIHtcXG4gICAgICB0eXBlID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gbmV3IEJsb2IoW2RhdGFdLCB7XFxuICAgICAgICB0eXBlOiB0eXBlXFxuICAgICAgfSk7XFxuICAgIH0gY2F0Y2ggKF9lcnJvcikge31cXG4gICAgaWYgKEJsb2JCdWlsZGVyICE9IG51bGwpIHtcXG4gICAgICBiYiA9IG5ldyBCbG9iQnVpbGRlcjtcXG4gICAgICBiYi5hcHBlbmQoZGF0YSk7XFxuICAgICAgcmV0dXJuIGJiLmdldEJsb2IodHlwZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcblxcbiAgQnVmZmVyLm1ha2VCbG9iVVJMID0gZnVuY3Rpb24oZGF0YSwgdHlwZSkge1xcbiAgICByZXR1cm4gVVJMICE9IG51bGwgPyBVUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMubWFrZUJsb2IoZGF0YSwgdHlwZSkpIDogdm9pZCAwO1xcbiAgfTtcXG5cXG4gIEJ1ZmZlci5yZXZva2VCbG9iVVJMID0gZnVuY3Rpb24odXJsKSB7XFxuICAgIHJldHVybiBVUkwgIT0gbnVsbCA/IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKSA6IHZvaWQgMDtcXG4gIH07XFxuXFxuICBCdWZmZXIucHJvdG90eXBlLnRvQmxvYiA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gQnVmZmVyLm1ha2VCbG9iKHRoaXMuZGF0YS5idWZmZXIpO1xcbiAgfTtcXG5cXG4gIEJ1ZmZlci5wcm90b3R5cGUudG9CbG9iVVJMID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBCdWZmZXIubWFrZUJsb2JVUkwodGhpcy5kYXRhLmJ1ZmZlcik7XFxuICB9O1xcblxcbiAgcmV0dXJuIEJ1ZmZlcjtcXG5cXG59KSgpO1xcbi8vaW1wb3J0IFxcXCJjb3JlL2J1ZmZlci5jb2ZmZWVcXFwiO1xcblxcbkFWLkJ1ZmZlckxpc3QgPSAoZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xcbiAgICB0aGlzLmZpcnN0ID0gbnVsbDtcXG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcXG4gICAgdGhpcy5hdmFpbGFibGVCeXRlcyA9IDA7XFxuICAgIHRoaXMuYXZhaWxhYmxlQnVmZmVycyA9IDA7XFxuICB9XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciByZXN1bHQ7XFxuXFxuICAgIHJlc3VsdCA9IG5ldyBBVi5CdWZmZXJMaXN0O1xcbiAgICByZXN1bHQuZmlyc3QgPSB0aGlzLmZpcnN0O1xcbiAgICByZXN1bHQubGFzdCA9IHRoaXMubGFzdDtcXG4gICAgcmVzdWx0LmF2YWlsYWJsZUJ5dGVzID0gdGhpcy5hdmFpbGFibGVCeXRlcztcXG4gICAgcmVzdWx0LmF2YWlsYWJsZUJ1ZmZlcnMgPSB0aGlzLmF2YWlsYWJsZUJ1ZmZlcnM7XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICAgIHZhciBfcmVmLCBfcmVmMTtcXG5cXG4gICAgYnVmZmVyLnByZXYgPSB0aGlzLmxhc3Q7XFxuICAgIGlmICgoX3JlZiA9IHRoaXMubGFzdCkgIT0gbnVsbCkge1xcbiAgICAgIF9yZWYubmV4dCA9IGJ1ZmZlcjtcXG4gICAgfVxcbiAgICB0aGlzLmxhc3QgPSBidWZmZXI7XFxuICAgIGlmICgoX3JlZjEgPSB0aGlzLmZpcnN0KSA9PSBudWxsKSB7XFxuICAgICAgdGhpcy5maXJzdCA9IGJ1ZmZlcjtcXG4gICAgfVxcbiAgICB0aGlzLmF2YWlsYWJsZUJ5dGVzICs9IGJ1ZmZlci5sZW5ndGg7XFxuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZUJ1ZmZlcnMrKztcXG4gIH07XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmZpcnN0KSB7XFxuICAgICAgdGhpcy5hdmFpbGFibGVCeXRlcyAtPSB0aGlzLmZpcnN0Lmxlbmd0aDtcXG4gICAgICB0aGlzLmF2YWlsYWJsZUJ1ZmZlcnMtLTtcXG4gICAgICByZXR1cm4gdGhpcy5maXJzdCA9IHRoaXMuZmlyc3QubmV4dDtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgX3JlZjtcXG5cXG4gICAgaWYgKHRoaXMuZmlyc3QgJiYgIXRoaXMuZmlyc3QucHJldikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB0aGlzLmZpcnN0ID0gKChfcmVmID0gdGhpcy5maXJzdCkgIT0gbnVsbCA/IF9yZWYucHJldiA6IHZvaWQgMCkgfHwgdGhpcy5sYXN0O1xcbiAgICBpZiAodGhpcy5maXJzdCkge1xcbiAgICAgIHRoaXMuYXZhaWxhYmxlQnl0ZXMgKz0gdGhpcy5maXJzdC5sZW5ndGg7XFxuICAgICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlQnVmZmVycysrO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XFxuXFxufSkoKTtcXG4vL2ltcG9ydCBcXFwiY29yZS9idWZmZXJsaXN0LmNvZmZlZVxcXCI7XFxuXFxudmFyIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XFxuXFxuQVYuU3RyZWFtID0gKGZ1bmN0aW9uKCkge1xcbiAgdmFyIGJ1ZiwgZGVjb2RlU3RyaW5nLCBmbG9hdDMyLCBmbG9hdDY0LCBmbG9hdDY0RmFsbGJhY2ssIGZsb2F0ODAsIGludDE2LCBpbnQzMiwgaW50OCwgbmF0aXZlRW5kaWFuLCB1aW50MTYsIHVpbnQzMiwgdWludDg7XFxuXFxuICBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMTYpO1xcblxcbiAgdWludDggPSBuZXcgVWludDhBcnJheShidWYpO1xcblxcbiAgaW50OCA9IG5ldyBJbnQ4QXJyYXkoYnVmKTtcXG5cXG4gIHVpbnQxNiA9IG5ldyBVaW50MTZBcnJheShidWYpO1xcblxcbiAgaW50MTYgPSBuZXcgSW50MTZBcnJheShidWYpO1xcblxcbiAgdWludDMyID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XFxuXFxuICBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KGJ1Zik7XFxuXFxuICBmbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheShidWYpO1xcblxcbiAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIEZsb2F0NjRBcnJheSAhPT0gbnVsbCkge1xcbiAgICBmbG9hdDY0ID0gbmV3IEZsb2F0NjRBcnJheShidWYpO1xcbiAgfVxcblxcbiAgbmF0aXZlRW5kaWFuID0gbmV3IFVpbnQxNkFycmF5KG5ldyBVaW50OEFycmF5KFsweDEyLCAweDM0XSkuYnVmZmVyKVswXSA9PT0gMHgzNDEyO1xcblxcbiAgQVYuVW5kZXJmbG93RXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XFxuICAgIF9fZXh0ZW5kcyhVbmRlcmZsb3dFcnJvciwgX3N1cGVyKTtcXG5cXG4gICAgZnVuY3Rpb24gVW5kZXJmbG93RXJyb3IoKSB7XFxuICAgICAgdGhpcy5uYW1lID0gJ0FWLlVuZGVyZmxvd0Vycm9yJztcXG4gICAgfVxcblxcbiAgICByZXR1cm4gVW5kZXJmbG93RXJyb3I7XFxuXFxuICB9KShFcnJvcik7XFxuXFxuICBmdW5jdGlvbiBTdHJlYW0obGlzdCkge1xcbiAgICB0aGlzLmxpc3QgPSBsaXN0O1xcbiAgICB0aGlzLmxvY2FsT2Zmc2V0ID0gMDtcXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xcbiAgfVxcblxcbiAgU3RyZWFtLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcXG4gICAgdmFyIGxpc3Q7XFxuXFxuICAgIGxpc3QgPSBuZXcgQVYuQnVmZmVyTGlzdDtcXG4gICAgbGlzdC5hcHBlbmQoYnVmZmVyKTtcXG4gICAgcmV0dXJuIG5ldyBBVi5TdHJlYW0obGlzdCk7XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciByZXN1bHQ7XFxuXFxuICAgIHJlc3VsdCA9IG5ldyBBVi5TdHJlYW0odGhpcy5saXN0LmNvcHkoKSk7XFxuICAgIHJlc3VsdC5sb2NhbE9mZnNldCA9IHRoaXMubG9jYWxPZmZzZXQ7XFxuICAgIHJlc3VsdC5vZmZzZXQgPSB0aGlzLm9mZnNldDtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLmF2YWlsYWJsZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XFxuICAgIHJldHVybiBieXRlcyA8PSB0aGlzLmxpc3QuYXZhaWxhYmxlQnl0ZXMgLSB0aGlzLmxvY2FsT2Zmc2V0O1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucmVtYWluaW5nQnl0ZXMgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMubGlzdC5hdmFpbGFibGVCeXRlcyAtIHRoaXMubG9jYWxPZmZzZXQ7XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24oYnl0ZXMpIHtcXG4gICAgaWYgKCF0aGlzLmF2YWlsYWJsZShieXRlcykpIHtcXG4gICAgICB0aHJvdyBuZXcgQVYuVW5kZXJmbG93RXJyb3IoKTtcXG4gICAgfVxcbiAgICB0aGlzLmxvY2FsT2Zmc2V0ICs9IGJ5dGVzO1xcbiAgICB0aGlzLm9mZnNldCArPSBieXRlcztcXG4gICAgd2hpbGUgKHRoaXMubGlzdC5maXJzdCAmJiB0aGlzLmxvY2FsT2Zmc2V0ID49IHRoaXMubGlzdC5maXJzdC5sZW5ndGgpIHtcXG4gICAgICB0aGlzLmxvY2FsT2Zmc2V0IC09IHRoaXMubGlzdC5maXJzdC5sZW5ndGg7XFxuICAgICAgdGhpcy5saXN0LmFkdmFuY2UoKTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XFxuICAgIGlmIChieXRlcyA+IHRoaXMub2Zmc2V0KSB7XFxuICAgICAgdGhyb3cgbmV3IEFWLlVuZGVyZmxvd0Vycm9yKCk7XFxuICAgIH1cXG4gICAgaWYgKCF0aGlzLmxpc3QuZmlyc3QpIHtcXG4gICAgICB0aGlzLmxpc3QucmV3aW5kKCk7XFxuICAgICAgdGhpcy5sb2NhbE9mZnNldCA9IHRoaXMubGlzdC5maXJzdC5sZW5ndGg7XFxuICAgIH1cXG4gICAgdGhpcy5sb2NhbE9mZnNldCAtPSBieXRlcztcXG4gICAgdGhpcy5vZmZzZXQgLT0gYnl0ZXM7XFxuICAgIHdoaWxlICh0aGlzLmxpc3QuZmlyc3QucHJldiAmJiB0aGlzLmxvY2FsT2Zmc2V0IDwgMCkge1xcbiAgICAgIHRoaXMubGlzdC5yZXdpbmQoKTtcXG4gICAgICB0aGlzLmxvY2FsT2Zmc2V0ICs9IHRoaXMubGlzdC5maXJzdC5sZW5ndGg7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG4gICAgaWYgKHBvc2l0aW9uID4gdGhpcy5vZmZzZXQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hZHZhbmNlKHBvc2l0aW9uIC0gdGhpcy5vZmZzZXQpO1xcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgdGhpcy5vZmZzZXQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5yZXdpbmQodGhpcy5vZmZzZXQgLSBwb3NpdGlvbik7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgYTtcXG5cXG4gICAgaWYgKCF0aGlzLmF2YWlsYWJsZSgxKSkge1xcbiAgICAgIHRocm93IG5ldyBBVi5VbmRlcmZsb3dFcnJvcigpO1xcbiAgICB9XFxuICAgIGEgPSB0aGlzLmxpc3QuZmlyc3QuZGF0YVt0aGlzLmxvY2FsT2Zmc2V0XTtcXG4gICAgdGhpcy5sb2NhbE9mZnNldCArPSAxO1xcbiAgICB0aGlzLm9mZnNldCArPSAxO1xcbiAgICBpZiAodGhpcy5sb2NhbE9mZnNldCA9PT0gdGhpcy5saXN0LmZpcnN0Lmxlbmd0aCkge1xcbiAgICAgIHRoaXMubG9jYWxPZmZzZXQgPSAwO1xcbiAgICAgIHRoaXMubGlzdC5hZHZhbmNlKCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGE7XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5wZWVrVUludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcXG4gICAgdmFyIGJ1ZmZlcjtcXG5cXG4gICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XFxuICAgICAgb2Zmc2V0ID0gMDtcXG4gICAgfVxcbiAgICBpZiAoIXRoaXMuYXZhaWxhYmxlKG9mZnNldCArIDEpKSB7XFxuICAgICAgdGhyb3cgbmV3IEFWLlVuZGVyZmxvd0Vycm9yKCk7XFxuICAgIH1cXG4gICAgb2Zmc2V0ID0gdGhpcy5sb2NhbE9mZnNldCArIG9mZnNldDtcXG4gICAgYnVmZmVyID0gdGhpcy5saXN0LmZpcnN0O1xcbiAgICB3aGlsZSAoYnVmZmVyKSB7XFxuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiBvZmZzZXQpIHtcXG4gICAgICAgIHJldHVybiBidWZmZXIuZGF0YVtvZmZzZXRdO1xcbiAgICAgIH1cXG4gICAgICBvZmZzZXQgLT0gYnVmZmVyLmxlbmd0aDtcXG4gICAgICBidWZmZXIgPSBidWZmZXIubmV4dDtcXG4gICAgfVxcbiAgICByZXR1cm4gMDtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihieXRlcywgbGl0dGxlRW5kaWFuKSB7XFxuICAgIHZhciBpLCBfaSwgX2osIF9yZWY7XFxuXFxuICAgIGlmIChsaXR0bGVFbmRpYW4gPT0gbnVsbCkge1xcbiAgICAgIGxpdHRsZUVuZGlhbiA9IGZhbHNlO1xcbiAgICB9XFxuICAgIGlmIChsaXR0bGVFbmRpYW4gPT09IG5hdGl2ZUVuZGlhbikge1xcbiAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCBieXRlczsgaSA9IF9pICs9IDEpIHtcXG4gICAgICAgIHVpbnQ4W2ldID0gdGhpcy5yZWFkVUludDgoKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChpID0gX2ogPSBfcmVmID0gYnl0ZXMgLSAxOyBfaiA+PSAwOyBpID0gX2ogKz0gLTEpIHtcXG4gICAgICAgIHVpbnQ4W2ldID0gdGhpcy5yZWFkVUludDgoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihieXRlcywgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gICAgdmFyIGksIF9pLCBfajtcXG5cXG4gICAgaWYgKGxpdHRsZUVuZGlhbiA9PSBudWxsKSB7XFxuICAgICAgbGl0dGxlRW5kaWFuID0gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKGxpdHRsZUVuZGlhbiA9PT0gbmF0aXZlRW5kaWFuKSB7XFxuICAgICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IGJ5dGVzOyBpID0gX2kgKz0gMSkge1xcbiAgICAgICAgdWludDhbaV0gPSB0aGlzLnBlZWtVSW50OChvZmZzZXQgKyBpKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChpID0gX2ogPSAwOyBfaiA8IGJ5dGVzOyBpID0gX2ogKz0gMSkge1xcbiAgICAgICAgdWludDhbYnl0ZXMgLSBpIC0gMV0gPSB0aGlzLnBlZWtVSW50OChvZmZzZXQgKyBpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMucmVhZCgxKTtcXG4gICAgcmV0dXJuIGludDhbMF07XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5wZWVrSW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xcbiAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcXG4gICAgICBvZmZzZXQgPSAwO1xcbiAgICB9XFxuICAgIHRoaXMucGVlaygxLCBvZmZzZXQpO1xcbiAgICByZXR1cm4gaW50OFswXTtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWRVSW50MTYgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcXG4gICAgdGhpcy5yZWFkKDIsIGxpdHRsZUVuZGlhbik7XFxuICAgIHJldHVybiB1aW50MTZbMF07XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5wZWVrVUludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XFxuICAgICAgb2Zmc2V0ID0gMDtcXG4gICAgfVxcbiAgICB0aGlzLnBlZWsoMiwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xcbiAgICByZXR1cm4gdWludDE2WzBdO1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XFxuICAgIHRoaXMucmVhZCgyLCBsaXR0bGVFbmRpYW4pO1xcbiAgICByZXR1cm4gaW50MTZbMF07XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5wZWVrSW50MTYgPSBmdW5jdGlvbihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xcbiAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcXG4gICAgICBvZmZzZXQgPSAwO1xcbiAgICB9XFxuICAgIHRoaXMucGVlaygyLCBvZmZzZXQsIGxpdHRsZUVuZGlhbik7XFxuICAgIHJldHVybiBpbnQxNlswXTtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWRVSW50MjQgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcXG4gICAgaWYgKGxpdHRsZUVuZGlhbikge1xcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50MTYodHJ1ZSkgKyAodGhpcy5yZWFkVUludDgoKSA8PCAxNik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuICh0aGlzLnJlYWRVSW50MTYoKSA8PCA4KSArIHRoaXMucmVhZFVJbnQ4KCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnBlZWtVSW50MjQgPSBmdW5jdGlvbihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xcbiAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcXG4gICAgICBvZmZzZXQgPSAwO1xcbiAgICB9XFxuICAgIGlmIChsaXR0bGVFbmRpYW4pIHtcXG4gICAgICByZXR1cm4gdGhpcy5wZWVrVUludDE2KG9mZnNldCwgdHJ1ZSkgKyAodGhpcy5wZWVrVUludDgob2Zmc2V0ICsgMikgPDwgMTYpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiAodGhpcy5wZWVrVUludDE2KG9mZnNldCkgPDwgOCkgKyB0aGlzLnBlZWtVSW50OChvZmZzZXQgKyAyKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucmVhZEludDI0ID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XFxuICAgIGlmIChsaXR0bGVFbmRpYW4pIHtcXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVUludDE2KHRydWUpICsgKHRoaXMucmVhZEludDgoKSA8PCAxNik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuICh0aGlzLnJlYWRJbnQxNigpIDw8IDgpICsgdGhpcy5yZWFkVUludDgoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucGVla0ludDI0ID0gZnVuY3Rpb24ob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XFxuICAgICAgb2Zmc2V0ID0gMDtcXG4gICAgfVxcbiAgICBpZiAobGl0dGxlRW5kaWFuKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucGVla1VJbnQxNihvZmZzZXQsIHRydWUpICsgKHRoaXMucGVla0ludDgob2Zmc2V0ICsgMikgPDwgMTYpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiAodGhpcy5wZWVrSW50MTYob2Zmc2V0KSA8PCA4KSArIHRoaXMucGVla1VJbnQ4KG9mZnNldCArIDIpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5yZWFkVUludDMyID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XFxuICAgIHRoaXMucmVhZCg0LCBsaXR0bGVFbmRpYW4pO1xcbiAgICByZXR1cm4gdWludDMyWzBdO1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucGVla1VJbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XFxuICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xcbiAgICAgIG9mZnNldCA9IDA7XFxuICAgIH1cXG4gICAgdGhpcy5wZWVrKDQsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgcmV0dXJuIHVpbnQzMlswXTtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWRJbnQzMiA9IGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xcbiAgICB0aGlzLnJlYWQoNCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgcmV0dXJuIGludDMyWzBdO1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucGVla0ludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XFxuICAgICAgb2Zmc2V0ID0gMDtcXG4gICAgfVxcbiAgICB0aGlzLnBlZWsoNCwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xcbiAgICByZXR1cm4gaW50MzJbMF07XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xcbiAgICB0aGlzLnJlYWQoNCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgcmV0dXJuIGZsb2F0MzJbMF07XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5wZWVrRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XFxuICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xcbiAgICAgIG9mZnNldCA9IDA7XFxuICAgIH1cXG4gICAgdGhpcy5wZWVrKDQsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgcmV0dXJuIGZsb2F0MzJbMF07XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xcbiAgICB0aGlzLnJlYWQoOCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgaWYgKGZsb2F0NjQpIHtcXG4gICAgICByZXR1cm4gZmxvYXQ2NFswXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gZmxvYXQ2NEZhbGxiYWNrKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmbG9hdDY0RmFsbGJhY2sgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGV4cCwgZnJhYywgaGlnaCwgbG93LCBvdXQsIHNpZ247XFxuXFxuICAgIGxvdyA9IHVpbnQzMlswXSwgaGlnaCA9IHVpbnQzMlsxXTtcXG4gICAgaWYgKCFoaWdoIHx8IGhpZ2ggPT09IDB4ODAwMDAwMDApIHtcXG4gICAgICByZXR1cm4gMC4wO1xcbiAgICB9XFxuICAgIHNpZ24gPSAxIC0gKGhpZ2ggPj4+IDMxKSAqIDI7XFxuICAgIGV4cCA9IChoaWdoID4+PiAyMCkgJiAweDdmZjtcXG4gICAgZnJhYyA9IGhpZ2ggJiAweGZmZmZmO1xcbiAgICBpZiAoZXhwID09PSAweDdmZikge1xcbiAgICAgIGlmIChmcmFjKSB7XFxuICAgICAgICByZXR1cm4gTmFOO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xcbiAgICB9XFxuICAgIGV4cCAtPSAxMDIzO1xcbiAgICBvdXQgPSAoZnJhYyB8IDB4MTAwMDAwKSAqIE1hdGgucG93KDIsIGV4cCAtIDIwKTtcXG4gICAgb3V0ICs9IGxvdyAqIE1hdGgucG93KDIsIGV4cCAtIDUyKTtcXG4gICAgcmV0dXJuIHNpZ24gKiBvdXQ7XFxuICB9O1xcblxcbiAgU3RyZWFtLnByb3RvdHlwZS5wZWVrRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XFxuICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xcbiAgICAgIG9mZnNldCA9IDA7XFxuICAgIH1cXG4gICAgdGhpcy5wZWVrKDgsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgaWYgKGZsb2F0NjQpIHtcXG4gICAgICByZXR1cm4gZmxvYXQ2NFswXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gZmxvYXQ2NEZhbGxiYWNrKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWRGbG9hdDgwID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XFxuICAgIHRoaXMucmVhZCgxMCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgcmV0dXJuIGZsb2F0ODAoKTtcXG4gIH07XFxuXFxuICBmbG9hdDgwID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBhMCwgYTEsIGV4cCwgaGlnaCwgbG93LCBvdXQsIHNpZ247XFxuXFxuICAgIGhpZ2ggPSB1aW50MzJbMF0sIGxvdyA9IHVpbnQzMlsxXTtcXG4gICAgYTAgPSB1aW50OFs5XTtcXG4gICAgYTEgPSB1aW50OFs4XTtcXG4gICAgc2lnbiA9IDEgLSAoYTAgPj4+IDcpICogMjtcXG4gICAgZXhwID0gKChhMCAmIDB4N0YpIDw8IDgpIHwgYTE7XFxuICAgIGlmIChleHAgPT09IDAgJiYgbG93ID09PSAwICYmIGhpZ2ggPT09IDApIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgICBpZiAoZXhwID09PSAweDdmZmYpIHtcXG4gICAgICBpZiAobG93ID09PSAwICYmIGhpZ2ggPT09IDApIHtcXG4gICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBOYU47XFxuICAgIH1cXG4gICAgZXhwIC09IDE2MzgzO1xcbiAgICBvdXQgPSBsb3cgKiBNYXRoLnBvdygyLCBleHAgLSAzMSk7XFxuICAgIG91dCArPSBoaWdoICogTWF0aC5wb3coMiwgZXhwIC0gNjMpO1xcbiAgICByZXR1cm4gc2lnbiAqIG91dDtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnBlZWtGbG9hdDgwID0gZnVuY3Rpb24ob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XFxuICAgICAgb2Zmc2V0ID0gMDtcXG4gICAgfVxcbiAgICB0aGlzLnBlZWsoMTAsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgcmV0dXJuIGZsb2F0ODAoKTtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnJlYWRCdWZmZXIgPSBmdW5jdGlvbihsZW5ndGgpIHtcXG4gICAgdmFyIGksIHJlc3VsdCwgdG8sIF9pO1xcblxcbiAgICByZXN1bHQgPSBBVi5CdWZmZXIuYWxsb2NhdGUobGVuZ3RoKTtcXG4gICAgdG8gPSByZXN1bHQuZGF0YTtcXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IGxlbmd0aDsgaSA9IF9pICs9IDEpIHtcXG4gICAgICB0b1tpXSA9IHRoaXMucmVhZFVJbnQ4KCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH07XFxuXFxuICBTdHJlYW0ucHJvdG90eXBlLnBlZWtCdWZmZXIgPSBmdW5jdGlvbihvZmZzZXQsIGxlbmd0aCkge1xcbiAgICB2YXIgaSwgcmVzdWx0LCB0bywgX2k7XFxuXFxuICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xcbiAgICAgIG9mZnNldCA9IDA7XFxuICAgIH1cXG4gICAgcmVzdWx0ID0gQVYuQnVmZmVyLmFsbG9jYXRlKGxlbmd0aCk7XFxuICAgIHRvID0gcmVzdWx0LmRhdGE7XFxuICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCBsZW5ndGg7IGkgPSBfaSArPSAxKSB7XFxuICAgICAgdG9baV0gPSB0aGlzLnBlZWtVSW50OChvZmZzZXQgKyBpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucmVhZFNpbmdsZUJ1ZmZlciA9IGZ1bmN0aW9uKGxlbmd0aCkge1xcbiAgICB2YXIgcmVzdWx0O1xcblxcbiAgICByZXN1bHQgPSB0aGlzLmxpc3QuZmlyc3Quc2xpY2UodGhpcy5sb2NhbE9mZnNldCwgbGVuZ3RoKTtcXG4gICAgdGhpcy5hZHZhbmNlKHJlc3VsdC5sZW5ndGgpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucGVla1NpbmdsZUJ1ZmZlciA9IGZ1bmN0aW9uKG9mZnNldCwgbGVuZ3RoKSB7XFxuICAgIHZhciByZXN1bHQ7XFxuXFxuICAgIHJlc3VsdCA9IHRoaXMubGlzdC5maXJzdC5zbGljZSh0aGlzLmxvY2FsT2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCwgZW5jb2RpbmcpIHtcXG4gICAgaWYgKGVuY29kaW5nID09IG51bGwpIHtcXG4gICAgICBlbmNvZGluZyA9ICdhc2NpaSc7XFxuICAgIH1cXG4gICAgcmV0dXJuIGRlY29kZVN0cmluZy5jYWxsKHRoaXMsIDAsIGxlbmd0aCwgZW5jb2RpbmcsIHRydWUpO1xcbiAgfTtcXG5cXG4gIFN0cmVhbS5wcm90b3R5cGUucGVla1N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xcbiAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcXG4gICAgICBvZmZzZXQgPSAwO1xcbiAgICB9XFxuICAgIGlmIChlbmNvZGluZyA9PSBudWxsKSB7XFxuICAgICAgZW5jb2RpbmcgPSAnYXNjaWknO1xcbiAgICB9XFxuICAgIHJldHVybiBkZWNvZGVTdHJpbmcuY2FsbCh0aGlzLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcsIGZhbHNlKTtcXG4gIH07XFxuXFxuICBkZWNvZGVTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcsIGFkdmFuY2UpIHtcXG4gICAgdmFyIGIxLCBiMiwgYjMsIGI0LCBib20sIGMsIGVuZCwgbGl0dGxlRW5kaWFuLCBudWxsRW5kLCBwdCwgcmVzdWx0LCB3MSwgdzI7XFxuXFxuICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcXG4gICAgbnVsbEVuZCA9IGxlbmd0aCA9PT0gbnVsbCA/IDAgOiAtMTtcXG4gICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XFxuICAgICAgbGVuZ3RoID0gSW5maW5pdHk7XFxuICAgIH1cXG4gICAgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoO1xcbiAgICByZXN1bHQgPSAnJztcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGVuZCAmJiAoYyA9IHRoaXMucGVla1VJbnQ4KG9mZnNldCsrKSkgIT09IG51bGxFbmQpIHtcXG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZW5kICYmIChiMSA9IHRoaXMucGVla1VJbnQ4KG9mZnNldCsrKSkgIT09IG51bGxFbmQpIHtcXG4gICAgICAgICAgaWYgKChiMSAmIDB4ODApID09PSAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjEpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKChiMSAmIDB4ZTApID09PSAweGMwKSB7XFxuICAgICAgICAgICAgYjIgPSB0aGlzLnBlZWtVSW50OChvZmZzZXQrKykgJiAweDNmO1xcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYjEgJiAweDFmKSA8PCA2KSB8IGIyKTtcXG4gICAgICAgICAgfSBlbHNlIGlmICgoYjEgJiAweGYwKSA9PT0gMHhlMCkge1xcbiAgICAgICAgICAgIGIyID0gdGhpcy5wZWVrVUludDgob2Zmc2V0KyspICYgMHgzZjtcXG4gICAgICAgICAgICBiMyA9IHRoaXMucGVla1VJbnQ4KG9mZnNldCsrKSAmIDB4M2Y7XFxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChiMSAmIDB4MGYpIDw8IDEyKSB8IChiMiA8PCA2KSB8IGIzKTtcXG4gICAgICAgICAgfSBlbHNlIGlmICgoYjEgJiAweGY4KSA9PT0gMHhmMCkge1xcbiAgICAgICAgICAgIGIyID0gdGhpcy5wZWVrVUludDgob2Zmc2V0KyspICYgMHgzZjtcXG4gICAgICAgICAgICBiMyA9IHRoaXMucGVla1VJbnQ4KG9mZnNldCsrKSAmIDB4M2Y7XFxuICAgICAgICAgICAgYjQgPSB0aGlzLnBlZWtVSW50OChvZmZzZXQrKykgJiAweDNmO1xcbiAgICAgICAgICAgIHB0ID0gKCgoYjEgJiAweDBmKSA8PCAxOCkgfCAoYjIgPDwgMTIpIHwgKGIzIDw8IDYpIHwgYjQpIC0gMHgxMDAwMDtcXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAocHQgPj4gMTApLCAweGRjMDAgKyAocHQgJiAweDNmZikpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICd1dGYxNi1iZSc6XFxuICAgICAgY2FzZSAndXRmMTZiZSc6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmMTYtbGUnOlxcbiAgICAgIGNhc2UgJ3V0ZjE2Ym9tJzpcXG4gICAgICBjYXNlICd1dGYxNi1ib20nOlxcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgICAgICBjYXNlICd1dGYxNmJlJzpcXG4gICAgICAgICAgY2FzZSAndXRmMTYtYmUnOlxcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IGZhbHNlO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICAgICAgY2FzZSAndXRmMTYtbGUnOlxcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ3V0ZjE2Ym9tJzpcXG4gICAgICAgICAgY2FzZSAndXRmMTYtYm9tJzpcXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgMiB8fCAoYm9tID0gdGhpcy5wZWVrVUludDE2KG9mZnNldCkpID09PSBudWxsRW5kKSB7XFxuICAgICAgICAgICAgICBpZiAoYWR2YW5jZSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2Uob2Zmc2V0ICs9IDIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gYm9tID09PSAweGZmZmU7XFxuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XFxuICAgICAgICB9XFxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZW5kICYmICh3MSA9IHRoaXMucGVla1VJbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikpICE9PSBudWxsRW5kKSB7XFxuICAgICAgICAgIG9mZnNldCArPSAyO1xcbiAgICAgICAgICBpZiAodzEgPCAweGQ4MDAgfHwgdzEgPiAweGRmZmYpIHtcXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh3MSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaWYgKHcxID4gMHhkYmZmKSB7XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgdXRmMTYgc2VxdWVuY2UuXFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHcyID0gdGhpcy5wZWVrVUludDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcXG4gICAgICAgICAgICBpZiAodzIgPCAweGRjMDAgfHwgdzIgPiAweGRmZmYpIHtcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiSW52YWxpZCB1dGYxNiBzZXF1ZW5jZS5cXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodzEsIHcyKTtcXG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHcxID09PSBudWxsRW5kKSB7XFxuICAgICAgICAgIG9mZnNldCArPSAyO1xcbiAgICAgICAgfVxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVW5rbm93biBlbmNvZGluZzogXFxcIiArIGVuY29kaW5nKTtcXG4gICAgfVxcbiAgICBpZiAoYWR2YW5jZSkge1xcbiAgICAgIHRoaXMuYWR2YW5jZShvZmZzZXQpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9O1xcblxcbiAgcmV0dXJuIFN0cmVhbTtcXG5cXG59KSgpO1xcbi8vaW1wb3J0IFxcXCJjb3JlL3N0cmVhbS5jb2ZmZWVcXFwiO1xcblxcbkFWLkJpdHN0cmVhbSA9IChmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIEJpdHN0cmVhbShzdHJlYW0pIHtcXG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XFxuICAgIHRoaXMuYml0UG9zaXRpb24gPSAwO1xcbiAgfVxcblxcbiAgQml0c3RyZWFtLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciByZXN1bHQ7XFxuXFxuICAgIHJlc3VsdCA9IG5ldyBBVi5CaXRzdHJlYW0odGhpcy5zdHJlYW0uY29weSgpKTtcXG4gICAgcmVzdWx0LmJpdFBvc2l0aW9uID0gdGhpcy5iaXRQb3NpdGlvbjtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH07XFxuXFxuICBCaXRzdHJlYW0ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gOCAqIHRoaXMuc3RyZWFtLm9mZnNldCArIHRoaXMuYml0UG9zaXRpb247XFxuICB9O1xcblxcbiAgQml0c3RyZWFtLnByb3RvdHlwZS5hdmFpbGFibGUgPSBmdW5jdGlvbihiaXRzKSB7XFxuICAgIHJldHVybiB0aGlzLnN0cmVhbS5hdmFpbGFibGUoKGJpdHMgKyA4IC0gdGhpcy5iaXRQb3NpdGlvbikgLyA4KTtcXG4gIH07XFxuXFxuICBCaXRzdHJlYW0ucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbihiaXRzKSB7XFxuICAgIHZhciBwb3M7XFxuXFxuICAgIHBvcyA9IHRoaXMuYml0UG9zaXRpb24gKyBiaXRzO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKHBvcyA+PiAzKTtcXG4gICAgcmV0dXJuIHRoaXMuYml0UG9zaXRpb24gPSBwb3MgJiA3O1xcbiAgfTtcXG5cXG4gIEJpdHN0cmVhbS5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24oYml0cykge1xcbiAgICB2YXIgcG9zO1xcblxcbiAgICBwb3MgPSB0aGlzLmJpdFBvc2l0aW9uIC0gYml0cztcXG4gICAgdGhpcy5zdHJlYW0ucmV3aW5kKE1hdGguYWJzKHBvcyA+PiAzKSk7XFxuICAgIHJldHVybiB0aGlzLmJpdFBvc2l0aW9uID0gcG9zICYgNztcXG4gIH07XFxuXFxuICBCaXRzdHJlYW0ucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbihvZmZzZXQpIHtcXG4gICAgdmFyIGN1ck9mZnNldDtcXG5cXG4gICAgY3VyT2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcXG4gICAgaWYgKG9mZnNldCA+IGN1ck9mZnNldCkge1xcbiAgICAgIHJldHVybiB0aGlzLmFkdmFuY2Uob2Zmc2V0IC0gY3VyT2Zmc2V0KTtcXG4gICAgfSBlbHNlIGlmIChvZmZzZXQgPCBjdXJPZmZzZXQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5yZXdpbmQoY3VyT2Zmc2V0IC0gb2Zmc2V0KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEJpdHN0cmVhbS5wcm90b3R5cGUuYWxpZ24gPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKHRoaXMuYml0UG9zaXRpb24gIT09IDApIHtcXG4gICAgICB0aGlzLmJpdFBvc2l0aW9uID0gMDtcXG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0uYWR2YW5jZSgxKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEJpdHN0cmVhbS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGJpdHMsIHNpZ25lZCkge1xcbiAgICB2YXIgYSwgYTAsIGExLCBhMiwgYTMsIGE0LCBtQml0cztcXG5cXG4gICAgaWYgKGJpdHMgPT09IDApIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgICBtQml0cyA9IGJpdHMgKyB0aGlzLmJpdFBvc2l0aW9uO1xcbiAgICBpZiAobUJpdHMgPD0gOCkge1xcbiAgICAgIGEgPSAoKHRoaXMuc3RyZWFtLnBlZWtVSW50OCgpIDw8IHRoaXMuYml0UG9zaXRpb24pICYgMHhmZikgPj4+ICg4IC0gYml0cyk7XFxuICAgIH0gZWxzZSBpZiAobUJpdHMgPD0gMTYpIHtcXG4gICAgICBhID0gKCh0aGlzLnN0cmVhbS5wZWVrVUludDE2KCkgPDwgdGhpcy5iaXRQb3NpdGlvbikgJiAweGZmZmYpID4+PiAoMTYgLSBiaXRzKTtcXG4gICAgfSBlbHNlIGlmIChtQml0cyA8PSAyNCkge1xcbiAgICAgIGEgPSAoKHRoaXMuc3RyZWFtLnBlZWtVSW50MjQoKSA8PCB0aGlzLmJpdFBvc2l0aW9uKSAmIDB4ZmZmZmZmKSA+Pj4gKDI0IC0gYml0cyk7XFxuICAgIH0gZWxzZSBpZiAobUJpdHMgPD0gMzIpIHtcXG4gICAgICBhID0gKHRoaXMuc3RyZWFtLnBlZWtVSW50MzIoKSA8PCB0aGlzLmJpdFBvc2l0aW9uKSA+Pj4gKDMyIC0gYml0cyk7XFxuICAgIH0gZWxzZSBpZiAobUJpdHMgPD0gNDApIHtcXG4gICAgICBhMCA9IHRoaXMuc3RyZWFtLnBlZWtVSW50OCgwKSAqIDB4MDEwMDAwMDAwMDtcXG4gICAgICBhMSA9IHRoaXMuc3RyZWFtLnBlZWtVSW50OCgxKSA8PCAyNCA+Pj4gMDtcXG4gICAgICBhMiA9IHRoaXMuc3RyZWFtLnBlZWtVSW50OCgyKSA8PCAxNjtcXG4gICAgICBhMyA9IHRoaXMuc3RyZWFtLnBlZWtVSW50OCgzKSA8PCA4O1xcbiAgICAgIGE0ID0gdGhpcy5zdHJlYW0ucGVla1VJbnQ4KDQpO1xcbiAgICAgIGEgPSBhMCArIGExICsgYTIgKyBhMyArIGE0O1xcbiAgICAgIGEgJT0gTWF0aC5wb3coMiwgNDAgLSB0aGlzLmJpdFBvc2l0aW9uKTtcXG4gICAgICBhID0gTWF0aC5mbG9vcihhIC8gTWF0aC5wb3coMiwgNDAgLSB0aGlzLmJpdFBvc2l0aW9uIC0gYml0cykpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVG9vIG1hbnkgYml0cyFcXFwiKTtcXG4gICAgfVxcbiAgICBpZiAoc2lnbmVkKSB7XFxuICAgICAgaWYgKG1CaXRzIDwgMzIpIHtcXG4gICAgICAgIGlmIChhID4+PiAoYml0cyAtIDEpKSB7XFxuICAgICAgICAgIGEgPSAoKDEgPDwgYml0cyA+Pj4gMCkgLSBhKSAqIC0xO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoYSAvIE1hdGgucG93KDIsIGJpdHMgLSAxKSB8IDApIHtcXG4gICAgICAgICAgYSA9IChNYXRoLnBvdygyLCBiaXRzKSAtIGEpICogLTE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRoaXMuYWR2YW5jZShiaXRzKTtcXG4gICAgcmV0dXJuIGE7XFxuICB9O1xcblxcbiAgQml0c3RyZWFtLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oYml0cywgc2lnbmVkKSB7XFxuICAgIHZhciBhLCBhMCwgYTEsIGEyLCBhMywgYTQsIG1CaXRzO1xcblxcbiAgICBpZiAoYml0cyA9PT0gMCkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuICAgIG1CaXRzID0gYml0cyArIHRoaXMuYml0UG9zaXRpb247XFxuICAgIGlmIChtQml0cyA8PSA4KSB7XFxuICAgICAgYSA9ICgodGhpcy5zdHJlYW0ucGVla1VJbnQ4KCkgPDwgdGhpcy5iaXRQb3NpdGlvbikgJiAweGZmKSA+Pj4gKDggLSBiaXRzKTtcXG4gICAgfSBlbHNlIGlmIChtQml0cyA8PSAxNikge1xcbiAgICAgIGEgPSAoKHRoaXMuc3RyZWFtLnBlZWtVSW50MTYoKSA8PCB0aGlzLmJpdFBvc2l0aW9uKSAmIDB4ZmZmZikgPj4+ICgxNiAtIGJpdHMpO1xcbiAgICB9IGVsc2UgaWYgKG1CaXRzIDw9IDI0KSB7XFxuICAgICAgYSA9ICgodGhpcy5zdHJlYW0ucGVla1VJbnQyNCgpIDw8IHRoaXMuYml0UG9zaXRpb24pICYgMHhmZmZmZmYpID4+PiAoMjQgLSBiaXRzKTtcXG4gICAgfSBlbHNlIGlmIChtQml0cyA8PSAzMikge1xcbiAgICAgIGEgPSAodGhpcy5zdHJlYW0ucGVla1VJbnQzMigpIDw8IHRoaXMuYml0UG9zaXRpb24pID4+PiAoMzIgLSBiaXRzKTtcXG4gICAgfSBlbHNlIGlmIChtQml0cyA8PSA0MCkge1xcbiAgICAgIGEwID0gdGhpcy5zdHJlYW0ucGVla1VJbnQ4KDApICogMHgwMTAwMDAwMDAwO1xcbiAgICAgIGExID0gdGhpcy5zdHJlYW0ucGVla1VJbnQ4KDEpIDw8IDI0ID4+PiAwO1xcbiAgICAgIGEyID0gdGhpcy5zdHJlYW0ucGVla1VJbnQ4KDIpIDw8IDE2O1xcbiAgICAgIGEzID0gdGhpcy5zdHJlYW0ucGVla1VJbnQ4KDMpIDw8IDg7XFxuICAgICAgYTQgPSB0aGlzLnN0cmVhbS5wZWVrVUludDgoNCk7XFxuICAgICAgYSA9IGEwICsgYTEgKyBhMiArIGEzICsgYTQ7XFxuICAgICAgYSAlPSBNYXRoLnBvdygyLCA0MCAtIHRoaXMuYml0UG9zaXRpb24pO1xcbiAgICAgIGEgPSBNYXRoLmZsb29yKGEgLyBNYXRoLnBvdygyLCA0MCAtIHRoaXMuYml0UG9zaXRpb24gLSBiaXRzKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJUb28gbWFueSBiaXRzIVxcXCIpO1xcbiAgICB9XFxuICAgIGlmIChzaWduZWQpIHtcXG4gICAgICBpZiAobUJpdHMgPCAzMikge1xcbiAgICAgICAgaWYgKGEgPj4+IChiaXRzIC0gMSkpIHtcXG4gICAgICAgICAgYSA9ICgoMSA8PCBiaXRzID4+PiAwKSAtIGEpICogLTE7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChhIC8gTWF0aC5wb3coMiwgYml0cyAtIDEpIHwgMCkge1xcbiAgICAgICAgICBhID0gKE1hdGgucG93KDIsIGJpdHMpIC0gYSkgKiAtMTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGE7XFxuICB9O1xcblxcbiAgQml0c3RyZWFtLnByb3RvdHlwZS5yZWFkTFNCID0gZnVuY3Rpb24oYml0cywgc2lnbmVkKSB7XFxuICAgIHZhciBhLCBtQml0cztcXG5cXG4gICAgaWYgKGJpdHMgPT09IDApIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgICBpZiAoYml0cyA+IDQwKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJUb28gbWFueSBiaXRzIVxcXCIpO1xcbiAgICB9XFxuICAgIG1CaXRzID0gYml0cyArIHRoaXMuYml0UG9zaXRpb247XFxuICAgIGEgPSAodGhpcy5zdHJlYW0ucGVla1VJbnQ4KDApKSA+Pj4gdGhpcy5iaXRQb3NpdGlvbjtcXG4gICAgaWYgKG1CaXRzID4gOCkge1xcbiAgICAgIGEgfD0gKHRoaXMuc3RyZWFtLnBlZWtVSW50OCgxKSkgPDwgKDggLSB0aGlzLmJpdFBvc2l0aW9uKTtcXG4gICAgfVxcbiAgICBpZiAobUJpdHMgPiAxNikge1xcbiAgICAgIGEgfD0gKHRoaXMuc3RyZWFtLnBlZWtVSW50OCgyKSkgPDwgKDE2IC0gdGhpcy5iaXRQb3NpdGlvbik7XFxuICAgIH1cXG4gICAgaWYgKG1CaXRzID4gMjQpIHtcXG4gICAgICBhICs9ICh0aGlzLnN0cmVhbS5wZWVrVUludDgoMykpIDw8ICgyNCAtIHRoaXMuYml0UG9zaXRpb24pID4+PiAwO1xcbiAgICB9XFxuICAgIGlmIChtQml0cyA+IDMyKSB7XFxuICAgICAgYSArPSAodGhpcy5zdHJlYW0ucGVla1VJbnQ4KDQpKSAqIE1hdGgucG93KDIsIDMyIC0gdGhpcy5iaXRQb3NpdGlvbik7XFxuICAgIH1cXG4gICAgaWYgKG1CaXRzID49IDMyKSB7XFxuICAgICAgYSAlPSBNYXRoLnBvdygyLCBiaXRzKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBhICY9ICgxIDw8IGJpdHMpIC0gMTtcXG4gICAgfVxcbiAgICBpZiAoc2lnbmVkKSB7XFxuICAgICAgaWYgKG1CaXRzIDwgMzIpIHtcXG4gICAgICAgIGlmIChhID4+PiAoYml0cyAtIDEpKSB7XFxuICAgICAgICAgIGEgPSAoKDEgPDwgYml0cyA+Pj4gMCkgLSBhKSAqIC0xO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoYSAvIE1hdGgucG93KDIsIGJpdHMgLSAxKSB8IDApIHtcXG4gICAgICAgICAgYSA9IChNYXRoLnBvdygyLCBiaXRzKSAtIGEpICogLTE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRoaXMuYWR2YW5jZShiaXRzKTtcXG4gICAgcmV0dXJuIGE7XFxuICB9O1xcblxcbiAgQml0c3RyZWFtLnByb3RvdHlwZS5wZWVrTFNCID0gZnVuY3Rpb24oYml0cywgc2lnbmVkKSB7XFxuICAgIHZhciBhLCBtQml0cztcXG5cXG4gICAgaWYgKGJpdHMgPT09IDApIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgICBpZiAoYml0cyA+IDQwKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJUb28gbWFueSBiaXRzIVxcXCIpO1xcbiAgICB9XFxuICAgIG1CaXRzID0gYml0cyArIHRoaXMuYml0UG9zaXRpb247XFxuICAgIGEgPSAodGhpcy5zdHJlYW0ucGVla1VJbnQ4KDApKSA+Pj4gdGhpcy5iaXRQb3NpdGlvbjtcXG4gICAgaWYgKG1CaXRzID4gOCkge1xcbiAgICAgIGEgfD0gKHRoaXMuc3RyZWFtLnBlZWtVSW50OCgxKSkgPDwgKDggLSB0aGlzLmJpdFBvc2l0aW9uKTtcXG4gICAgfVxcbiAgICBpZiAobUJpdHMgPiAxNikge1xcbiAgICAgIGEgfD0gKHRoaXMuc3RyZWFtLnBlZWtVSW50OCgyKSkgPDwgKDE2IC0gdGhpcy5iaXRQb3NpdGlvbik7XFxuICAgIH1cXG4gICAgaWYgKG1CaXRzID4gMjQpIHtcXG4gICAgICBhICs9ICh0aGlzLnN0cmVhbS5wZWVrVUludDgoMykpIDw8ICgyNCAtIHRoaXMuYml0UG9zaXRpb24pID4+PiAwO1xcbiAgICB9XFxuICAgIGlmIChtQml0cyA+IDMyKSB7XFxuICAgICAgYSArPSAodGhpcy5zdHJlYW0ucGVla1VJbnQ4KDQpKSAqIE1hdGgucG93KDIsIDMyIC0gdGhpcy5iaXRQb3NpdGlvbik7XFxuICAgIH1cXG4gICAgaWYgKG1CaXRzID49IDMyKSB7XFxuICAgICAgYSAlPSBNYXRoLnBvdygyLCBiaXRzKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBhICY9ICgxIDw8IGJpdHMpIC0gMTtcXG4gICAgfVxcbiAgICBpZiAoc2lnbmVkKSB7XFxuICAgICAgaWYgKG1CaXRzIDwgMzIpIHtcXG4gICAgICAgIGlmIChhID4+PiAoYml0cyAtIDEpKSB7XFxuICAgICAgICAgIGEgPSAoKDEgPDwgYml0cyA+Pj4gMCkgLSBhKSAqIC0xO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoYSAvIE1hdGgucG93KDIsIGJpdHMgLSAxKSB8IDApIHtcXG4gICAgICAgICAgYSA9IChNYXRoLnBvdygyLCBiaXRzKSAtIGEpICogLTE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBhO1xcbiAgfTtcXG5cXG4gIHJldHVybiBCaXRzdHJlYW07XFxuXFxufSkoKTtcXG4vL2ltcG9ydCBcXFwiY29yZS9iaXRzdHJlYW0uY29mZmVlXFxcIjtcXG5cXG52YXIgX3JlZixcXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXFxuICBfX3NsaWNlID0gW10uc2xpY2U7XFxuXFxuQVYuRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgX19leHRlbmRzKEV2ZW50RW1pdHRlciwgX3N1cGVyKTtcXG5cXG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcXG4gICAgX3JlZiA9IEV2ZW50RW1pdHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgcmV0dXJuIF9yZWY7XFxuICB9XFxuXFxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XFxuICAgIHZhciBfYmFzZSwgX3JlZjEsIF9yZWYyO1xcblxcbiAgICBpZiAoKF9yZWYxID0gdGhpcy5ldmVudHMpID09IG51bGwpIHtcXG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xcbiAgICB9XFxuICAgIGlmICgoX3JlZjIgPSAoX2Jhc2UgPSB0aGlzLmV2ZW50cylbZXZlbnRdKSA9PSBudWxsKSB7XFxuICAgICAgX2Jhc2VbZXZlbnRdID0gW107XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzW2V2ZW50XS5wdXNoKGZuKTtcXG4gIH07XFxuXFxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xcbiAgICB2YXIgaW5kZXgsIF9yZWYxO1xcblxcbiAgICBpZiAoISgoX3JlZjEgPSB0aGlzLmV2ZW50cykgIT0gbnVsbCA/IF9yZWYxW2V2ZW50XSA6IHZvaWQgMCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaW5kZXggPSB0aGlzLmV2ZW50c1tldmVudF0uaW5kZXhPZihmbik7XFxuICAgIGlmICh+aW5kZXgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5ldmVudHNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pIHtcXG4gICAgdmFyIGNiO1xcblxcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgY2IgPSBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLm9mZihldmVudCwgY2IpO1xcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGFyZ3MsIGV2ZW50LCBmbiwgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMjtcXG5cXG4gICAgZXZlbnQgPSBhcmd1bWVudHNbMF0sIGFyZ3MgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xcbiAgICBpZiAoISgoX3JlZjEgPSB0aGlzLmV2ZW50cykgIT0gbnVsbCA/IF9yZWYxW2V2ZW50XSA6IHZvaWQgMCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgX3JlZjIgPSB0aGlzLmV2ZW50c1tldmVudF0uc2xpY2UoKTtcXG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xcbiAgICAgIGZuID0gX3JlZjJbX2ldO1xcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcXG5cXG59KShBVi5CYXNlKTtcXG4vL2ltcG9ydCBcXFwiY29yZS9ldmVudHMuY29mZmVlXFxcIjtcXG5cXG52YXIgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5BVi5EZW11eGVyID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgdmFyIGZvcm1hdHM7XFxuXFxuICBfX2V4dGVuZHMoRGVtdXhlciwgX3N1cGVyKTtcXG5cXG4gIERlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbihidWZmZXIpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIERlbXV4ZXIoc291cmNlLCBjaHVuaykge1xcbiAgICB2YXIgbGlzdCwgcmVjZWl2ZWQsXFxuICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBsaXN0ID0gbmV3IEFWLkJ1ZmZlckxpc3Q7XFxuICAgIGxpc3QuYXBwZW5kKGNodW5rKTtcXG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgQVYuU3RyZWFtKGxpc3QpO1xcbiAgICByZWNlaXZlZCA9IGZhbHNlO1xcbiAgICBzb3VyY2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xcbiAgICAgIHJlY2VpdmVkID0gdHJ1ZTtcXG4gICAgICBsaXN0LmFwcGVuZChjaHVuayk7XFxuICAgICAgcmV0dXJuIF90aGlzLnJlYWRDaHVuayhjaHVuayk7XFxuICAgIH0pO1xcbiAgICBzb3VyY2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcXG4gICAgfSk7XFxuICAgIHNvdXJjZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKCFyZWNlaXZlZCkge1xcbiAgICAgICAgX3RoaXMucmVhZENodW5rKGNodW5rKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2VuZCcpO1xcbiAgICB9KTtcXG4gICAgdGhpcy5zZWVrUG9pbnRzID0gW107XFxuICAgIHRoaXMuaW5pdCgpO1xcbiAgfVxcblxcbiAgRGVtdXhlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge307XFxuXFxuICBEZW11eGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbihjaHVuaykge307XFxuXFxuICBEZW11eGVyLnByb3RvdHlwZS5hZGRTZWVrUG9pbnQgPSBmdW5jdGlvbihvZmZzZXQsIHRpbWVzdGFtcCkge1xcbiAgICB2YXIgaW5kZXg7XFxuXFxuICAgIGluZGV4ID0gdGhpcy5zZWFyY2hUaW1lc3RhbXAodGltZXN0YW1wKTtcXG4gICAgcmV0dXJuIHRoaXMuc2Vla1BvaW50cy5zcGxpY2UoaW5kZXgsIDAsIHtcXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcXG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFxcbiAgICB9KTtcXG4gIH07XFxuXFxuICBEZW11eGVyLnByb3RvdHlwZS5zZWFyY2hUaW1lc3RhbXAgPSBmdW5jdGlvbih0aW1lc3RhbXAsIGJhY2t3YXJkKSB7XFxuICAgIHZhciBoaWdoLCBsb3csIG1pZCwgdGltZTtcXG5cXG4gICAgbG93ID0gMDtcXG4gICAgaGlnaCA9IHRoaXMuc2Vla1BvaW50cy5sZW5ndGg7XFxuICAgIGlmIChoaWdoID4gMCAmJiB0aGlzLnNlZWtQb2ludHNbaGlnaCAtIDFdLnRpbWVzdGFtcCA8IHRpbWVzdGFtcCkge1xcbiAgICAgIHJldHVybiBoaWdoO1xcbiAgICB9XFxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XFxuICAgICAgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XFxuICAgICAgdGltZSA9IHRoaXMuc2Vla1BvaW50c1ttaWRdLnRpbWVzdGFtcDtcXG4gICAgICBpZiAodGltZSA8IHRpbWVzdGFtcCkge1xcbiAgICAgICAgbG93ID0gbWlkICsgMTtcXG4gICAgICB9IGVsc2UgaWYgKHRpbWUgPj0gdGltZXN0YW1wKSB7XFxuICAgICAgICBoaWdoID0gbWlkO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoaGlnaCA+IHRoaXMuc2Vla1BvaW50cy5sZW5ndGgpIHtcXG4gICAgICBoaWdoID0gdGhpcy5zZWVrUG9pbnRzLmxlbmd0aDtcXG4gICAgfVxcbiAgICByZXR1cm4gaGlnaDtcXG4gIH07XFxuXFxuICBEZW11eGVyLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XFxuICAgIHZhciBpbmRleCwgc2Vla1BvaW50O1xcblxcbiAgICBpZiAodGhpcy5mb3JtYXQgJiYgdGhpcy5mb3JtYXQuZnJhbWVzUGVyUGFja2V0ID4gMCAmJiB0aGlzLmZvcm1hdC5ieXRlc1BlclBhY2tldCA+IDApIHtcXG4gICAgICBzZWVrUG9pbnQgPSB7XFxuICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcXG4gICAgICAgIG9mZnNldDogdGhpcy5mb3JtYXQuYnl0ZXNQZXJQYWNrZXQgKiB0aW1lc3RhbXAgLyB0aGlzLmZvcm1hdC5mcmFtZXNQZXJQYWNrZXRcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiBzZWVrUG9pbnQ7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaW5kZXggPSB0aGlzLnNlYXJjaFRpbWVzdGFtcCh0aW1lc3RhbXApO1xcbiAgICAgIHJldHVybiB0aGlzLnNlZWtQb2ludHNbaW5kZXhdO1xcbiAgICB9XFxuICB9O1xcblxcbiAgZm9ybWF0cyA9IFtdO1xcblxcbiAgRGVtdXhlci5yZWdpc3RlciA9IGZ1bmN0aW9uKGRlbXV4ZXIpIHtcXG4gICAgcmV0dXJuIGZvcm1hdHMucHVzaChkZW11eGVyKTtcXG4gIH07XFxuXFxuICBEZW11eGVyLmZpbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcXG4gICAgdmFyIGZvcm1hdCwgc3RyZWFtLCBfaSwgX2xlbjtcXG5cXG4gICAgc3RyZWFtID0gQVYuU3RyZWFtLmZyb21CdWZmZXIoYnVmZmVyKTtcXG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBmb3JtYXRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XFxuICAgICAgZm9ybWF0ID0gZm9ybWF0c1tfaV07XFxuICAgICAgaWYgKGZvcm1hdC5wcm9iZShzdHJlYW0pKSB7XFxuICAgICAgICByZXR1cm4gZm9ybWF0O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH07XFxuXFxuICByZXR1cm4gRGVtdXhlcjtcXG5cXG59KShBVi5FdmVudEVtaXR0ZXIpO1xcbi8vaW1wb3J0IFxcXCJkZW11eGVyLmNvZmZlZVxcXCI7XFxuXFxudmFyIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XFxuXFxuQVYuRGVjb2RlciA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIHZhciBjb2RlY3M7XFxuXFxuICBfX2V4dGVuZHMoRGVjb2RlciwgX3N1cGVyKTtcXG5cXG4gIGZ1bmN0aW9uIERlY29kZXIoZGVtdXhlciwgZm9ybWF0KSB7XFxuICAgIHZhciBsaXN0LFxcbiAgICAgIF90aGlzID0gdGhpcztcXG5cXG4gICAgdGhpcy5kZW11eGVyID0gZGVtdXhlcjtcXG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XFxuICAgIGxpc3QgPSBuZXcgQVYuQnVmZmVyTGlzdDtcXG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgQVYuU3RyZWFtKGxpc3QpO1xcbiAgICB0aGlzLmJpdHN0cmVhbSA9IG5ldyBBVi5CaXRzdHJlYW0odGhpcy5zdHJlYW0pO1xcbiAgICB0aGlzLnJlY2VpdmVkRmluYWxCdWZmZXIgPSBmYWxzZTtcXG4gICAgdGhpcy53YWl0aW5nID0gZmFsc2U7XFxuICAgIHRoaXMuZGVtdXhlci5vbignY29va2llJywgZnVuY3Rpb24oY29va2llKSB7XFxuICAgICAgdmFyIGVycm9yO1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMuc2V0Q29va2llKGNvb2tpZSk7XFxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XFxuICAgICAgICBlcnJvciA9IF9lcnJvcjtcXG4gICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICB0aGlzLmRlbXV4ZXIub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xcbiAgICAgIGxpc3QuYXBwZW5kKGNodW5rKTtcXG4gICAgICBpZiAoX3RoaXMud2FpdGluZykge1xcbiAgICAgICAgcmV0dXJuIF90aGlzLmRlY29kZSgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIHRoaXMuZGVtdXhlci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgICAgX3RoaXMucmVjZWl2ZWRGaW5hbEJ1ZmZlciA9IHRydWU7XFxuICAgICAgaWYgKF90aGlzLndhaXRpbmcpIHtcXG4gICAgICAgIHJldHVybiBfdGhpcy5kZWNvZGUoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICB0aGlzLmluaXQoKTtcXG4gIH1cXG5cXG4gIERlY29kZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHt9O1xcblxcbiAgRGVjb2Rlci5wcm90b3R5cGUuc2V0Q29va2llID0gZnVuY3Rpb24oY29va2llKSB7fTtcXG5cXG4gIERlY29kZXIucHJvdG90eXBlLnJlYWRDaHVuayA9IGZ1bmN0aW9uKCkge307XFxuXFxuICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGVycm9yLCBvZmZzZXQsIHBhY2tldDtcXG5cXG4gICAgdGhpcy53YWl0aW5nID0gZmFsc2U7XFxuICAgIG9mZnNldCA9IHRoaXMuYml0c3RyZWFtLm9mZnNldCgpO1xcbiAgICB0cnkge1xcbiAgICAgIHBhY2tldCA9IHRoaXMucmVhZENodW5rKCk7XFxuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xcbiAgICAgIGVycm9yID0gX2Vycm9yO1xcbiAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgQVYuVW5kZXJmbG93RXJyb3IpKSB7XFxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAocGFja2V0KSB7XFxuICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0KTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSBlbHNlIGlmICghdGhpcy5yZWNlaXZlZEZpbmFsQnVmZmVyKSB7XFxuICAgICAgdGhpcy5iaXRzdHJlYW0uc2VlayhvZmZzZXQpO1xcbiAgICAgIHRoaXMud2FpdGluZyA9IHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9O1xcblxcbiAgRGVjb2Rlci5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xcbiAgICB2YXIgc2Vla1BvaW50O1xcblxcbiAgICBzZWVrUG9pbnQgPSB0aGlzLmRlbXV4ZXIuc2Vlayh0aW1lc3RhbXApO1xcbiAgICB0aGlzLnN0cmVhbS5zZWVrKHNlZWtQb2ludC5vZmZzZXQpO1xcbiAgICByZXR1cm4gc2Vla1BvaW50LnRpbWVzdGFtcDtcXG4gIH07XFxuXFxuICBjb2RlY3MgPSB7fTtcXG5cXG4gIERlY29kZXIucmVnaXN0ZXIgPSBmdW5jdGlvbihpZCwgZGVjb2Rlcikge1xcbiAgICByZXR1cm4gY29kZWNzW2lkXSA9IGRlY29kZXI7XFxuICB9O1xcblxcbiAgRGVjb2Rlci5maW5kID0gZnVuY3Rpb24oaWQpIHtcXG4gICAgcmV0dXJuIGNvZGVjc1tpZF0gfHwgbnVsbDtcXG4gIH07XFxuXFxuICByZXR1cm4gRGVjb2RlcjtcXG5cXG59KShBVi5FdmVudEVtaXR0ZXIpO1xcbi8vaW1wb3J0IFxcXCJkZWNvZGVyLmNvZmZlZVxcXCI7XFxuXFxudmFyIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcXG4gIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xcblxcbkFWLlF1ZXVlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgX19leHRlbmRzKFF1ZXVlLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gUXVldWUoYXNzZXQpIHtcXG4gICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgdGhpcy5hc3NldCA9IGFzc2V0O1xcbiAgICB0aGlzLndyaXRlID0gX19iaW5kKHRoaXMud3JpdGUsIHRoaXMpO1xcbiAgICB0aGlzLnJlYWR5TWFyayA9IDY0O1xcbiAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XFxuICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcXG4gICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcXG4gICAgdGhpcy5hc3NldC5vbignZGF0YScsIHRoaXMud3JpdGUpO1xcbiAgICB0aGlzLmFzc2V0Lm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gX3RoaXMuZW5kZWQgPSB0cnVlO1xcbiAgICB9KTtcXG4gICAgdGhpcy5hc3NldC5kZWNvZGVQYWNrZXQoKTtcXG4gIH1cXG5cXG4gIFF1ZXVlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xcbiAgICBpZiAoYnVmZmVyKSB7XFxuICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcXG4gICAgfVxcbiAgICBpZiAodGhpcy5idWZmZXJpbmcpIHtcXG4gICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA+PSB0aGlzLnJlYWR5TWFyayB8fCB0aGlzLmVuZGVkKSB7XFxuICAgICAgICB0aGlzLmJ1ZmZlcmluZyA9IGZhbHNlO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgncmVhZHknKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXQuZGVjb2RlUGFja2V0KCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgUXVldWUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICB0aGlzLmFzc2V0LmRlY29kZVBhY2tldCgpO1xcbiAgICByZXR1cm4gdGhpcy5idWZmZXJzLnNoaWZ0KCk7XFxuICB9O1xcblxcbiAgUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPSAwO1xcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XFxuICAgIHJldHVybiB0aGlzLmFzc2V0LmRlY29kZVBhY2tldCgpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBRdWV1ZTtcXG5cXG59KShBVi5FdmVudEVtaXR0ZXIpO1xcbi8vaW1wb3J0IFxcXCJxdWV1ZS5jb2ZmZWVcXFwiO1xcblxcbnZhciBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5BVi5BdWRpb0RldmljZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIHZhciBkZXZpY2VzO1xcblxcbiAgX19leHRlbmRzKEF1ZGlvRGV2aWNlLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gQXVkaW9EZXZpY2Uoc2FtcGxlUmF0ZSwgY2hhbm5lbHMpIHtcXG4gICAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcXG4gICAgdGhpcy5jaGFubmVscyA9IGNoYW5uZWxzO1xcbiAgICB0aGlzLnVwZGF0ZVRpbWUgPSBfX2JpbmQodGhpcy51cGRhdGVUaW1lLCB0aGlzKTtcXG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XFxuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xcbiAgICB0aGlzLl9sYXN0VGltZSA9IDA7XFxuICB9XFxuXFxuICBBdWRpb0RldmljZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIF9yZWYsXFxuICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBpZiAodGhpcy5wbGF5aW5nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHRoaXMucGxheWluZyA9IHRydWU7XFxuICAgIGlmICgoX3JlZiA9IHRoaXMuZGV2aWNlKSA9PSBudWxsKSB7XFxuXFxuICAgICAgdGhpcy5kZXZpY2UgPSB0aGlzLl9kZXZpY2UgPSBBVi5BdWRpb0RldmljZS5jcmVhdGUodGhpcy5zYW1wbGVSYXRlLCB0aGlzLmNoYW5uZWxzKTtcXG4gICAgfVxcbiAgICB0aGlzLl9sYXN0VGltZSA9IHRoaXMuZGV2aWNlLmdldERldmljZVRpbWUoKTtcXG4gICAgdGhpcy5fdGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLnVwZGF0ZVRpbWUsIDIwMCk7XFxuICAgIHJldHVybiB0aGlzLmRldmljZS5vbigncmVmaWxsJywgdGhpcy5yZWZpbGwgPSBmdW5jdGlvbihidWZmZXIpIHtcXG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgncmVmaWxsJywgYnVmZmVyKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgQXVkaW9EZXZpY2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKCF0aGlzLnBsYXlpbmcpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XFxuICAgIHRoaXMuZGV2aWNlLm9mZigncmVmaWxsJywgdGhpcy5yZWZpbGwpO1xcbiAgICByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lcik7XFxuICB9O1xcblxcbiAgQXVkaW9EZXZpY2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5zdG9wKCk7XFxuICAgIHJldHVybiB0aGlzLmRldmljZS5kZXN0cm95KCk7XFxuICB9O1xcblxcbiAgQXVkaW9EZXZpY2UucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbihjdXJyZW50VGltZSkge1xcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XFxuICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcXG4gICAgICB0aGlzLl9sYXN0VGltZSA9IHRoaXMuZGV2aWNlLmdldERldmljZVRpbWUoKTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcy5lbWl0KCd0aW1lVXBkYXRlJywgdGhpcy5jdXJyZW50VGltZSk7XFxuICB9O1xcblxcbiAgQXVkaW9EZXZpY2UucHJvdG90eXBlLnVwZGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHRpbWU7XFxuXFxuICAgIHRpbWUgPSB0aGlzLmRldmljZS5nZXREZXZpY2VUaW1lKCk7XFxuICAgIHRoaXMuY3VycmVudFRpbWUgKz0gKHRpbWUgLSB0aGlzLl9sYXN0VGltZSkgLyB0aGlzLmRldmljZS5zYW1wbGVSYXRlICogMTAwMCB8IDA7XFxuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZTtcXG4gICAgcmV0dXJuIHRoaXMuZW1pdCgndGltZVVwZGF0ZScsIHRoaXMuY3VycmVudFRpbWUpO1xcbiAgfTtcXG5cXG4gIGRldmljZXMgPSBbXTtcXG5cXG4gIEF1ZGlvRGV2aWNlLnJlZ2lzdGVyID0gZnVuY3Rpb24oZGV2aWNlKSB7XFxuICAgIHJldHVybiBkZXZpY2VzLnB1c2goZGV2aWNlKTtcXG4gIH07XFxuXFxuICBBdWRpb0RldmljZS5jcmVhdGUgPSBmdW5jdGlvbihzYW1wbGVSYXRlLCBjaGFubmVscykge1xcbiAgICB2YXIgZGV2aWNlLCBfaSwgX2xlbjtcXG5cXG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBkZXZpY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XFxuICAgICAgZGV2aWNlID0gZGV2aWNlc1tfaV07XFxuICAgICAgaWYgKGRldmljZS5zdXBwb3J0ZWQpIHtcXG4gICAgICAgIHJldHVybiBuZXcgZGV2aWNlKHNhbXBsZVJhdGUsIGNoYW5uZWxzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcblxcbiAgcmV0dXJuIEF1ZGlvRGV2aWNlO1xcblxcbn0pKEFWLkV2ZW50RW1pdHRlcik7XFxuLy9pbXBvcnQgXFxcImRldmljZS5jb2ZmZWVcXFwiO1xcblxcbnZhciBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5BVi5Bc3NldCA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIF9fZXh0ZW5kcyhBc3NldCwgX3N1cGVyKTtcXG5cXG4gIGZ1bmN0aW9uIEFzc2V0KHNvdXJjZSkge1xcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcXG4gICAgdGhpcy5fZGVjb2RlID0gX19iaW5kKHRoaXMuX2RlY29kZSwgdGhpcyk7XFxuICAgIHRoaXMuZmluZERlY29kZXIgPSBfX2JpbmQodGhpcy5maW5kRGVjb2RlciwgdGhpcyk7XFxuICAgIHRoaXMucHJvYmUgPSBfX2JpbmQodGhpcy5wcm9iZSwgdGhpcyk7XFxuICAgIHRoaXMuYnVmZmVyZWQgPSAwO1xcbiAgICB0aGlzLmR1cmF0aW9uID0gbnVsbDtcXG4gICAgdGhpcy5mb3JtYXQgPSBudWxsO1xcbiAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcXG4gICAgdGhpcy5kZW11eGVyID0gbnVsbDtcXG4gICAgdGhpcy5kZWNvZGVyID0gbnVsbDtcXG4gICAgdGhpcy5zb3VyY2Uub25jZSgnZGF0YScsIHRoaXMucHJvYmUpO1xcbiAgICB0aGlzLnNvdXJjZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcXG4gICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XFxuICAgICAgcmV0dXJuIF90aGlzLnN0b3AoKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuc291cmNlLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKGJ1ZmZlcmVkKSB7XFxuICAgICAgX3RoaXMuYnVmZmVyZWQgPSBidWZmZXJlZDtcXG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgnYnVmZmVyJywgX3RoaXMuYnVmZmVyZWQpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIEFzc2V0LmZyb21VUkwgPSBmdW5jdGlvbih1cmwpIHtcXG4gICAgdmFyIHNvdXJjZTtcXG5cXG4gICAgc291cmNlID0gbmV3IEFWLkhUVFBTb3VyY2UodXJsKTtcXG4gICAgcmV0dXJuIG5ldyBBVi5Bc3NldChzb3VyY2UpO1xcbiAgfTtcXG5cXG4gIEFzc2V0LmZyb21GaWxlID0gZnVuY3Rpb24oZmlsZSkge1xcbiAgICB2YXIgc291cmNlO1xcblxcbiAgICBzb3VyY2UgPSBuZXcgQVYuRmlsZVNvdXJjZShmaWxlKTtcXG4gICAgcmV0dXJuIG5ldyBBVi5Bc3NldChzb3VyY2UpO1xcbiAgfTtcXG5cXG4gIEFzc2V0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGRlY29kZSkge1xcbiAgICB2YXIgX3JlZjtcXG5cXG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChkZWNvZGUgIT0gbnVsbCkge1xcbiAgICAgIHRoaXMuc2hvdWxkRGVjb2RlID0gZGVjb2RlO1xcbiAgICB9XFxuICAgIGlmICgoX3JlZiA9IHRoaXMuc2hvdWxkRGVjb2RlKSA9PSBudWxsKSB7XFxuICAgICAgdGhpcy5zaG91bGREZWNvZGUgPSB0cnVlO1xcbiAgICB9XFxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcXG4gICAgdGhpcy5zb3VyY2Uuc3RhcnQoKTtcXG4gICAgaWYgKHRoaXMuZGVjb2RlciAmJiB0aGlzLnNob3VsZERlY29kZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGUoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEFzc2V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcXG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnBhdXNlKCk7XFxuICB9O1xcblxcbiAgQXNzZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBpZiAoZXZlbnQgIT09ICdmb3JtYXQnICYmIGV2ZW50ICE9PSAnZHVyYXRpb24nICYmIGV2ZW50ICE9PSAnbWV0YWRhdGEnKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmICh0aGlzW2V2ZW50XSAhPSBudWxsKSB7XFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXNbZXZlbnRdKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLm9uY2UoZXZlbnQsIGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICBfdGhpcy5zdG9wKCk7XFxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0KCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBBc3NldC5wcm90b3R5cGUuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKCk7XFxuICB9O1xcblxcbiAgQXNzZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24oY2h1bmspIHtcXG4gICAgdmFyIGRlbXV4ZXIsXFxuICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGRlbXV4ZXIgPSBBVi5EZW11eGVyLmZpbmQoY2h1bmspO1xcbiAgICBpZiAoIWRlbXV4ZXIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsICdBIGRlbXV4ZXIgZm9yIHRoaXMgY29udGFpbmVyIHdhcyBub3QgZm91bmQuJyk7XFxuICAgIH1cXG4gICAgdGhpcy5kZW11eGVyID0gbmV3IGRlbXV4ZXIodGhpcy5zb3VyY2UsIGNodW5rKTtcXG4gICAgdGhpcy5kZW11eGVyLm9uKCdmb3JtYXQnLCB0aGlzLmZpbmREZWNvZGVyKTtcXG4gICAgdGhpcy5kZW11eGVyLm9uKCdkdXJhdGlvbicsIGZ1bmN0aW9uKGR1cmF0aW9uKSB7XFxuICAgICAgX3RoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcXG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgnZHVyYXRpb24nLCBfdGhpcy5kdXJhdGlvbik7XFxuICAgIH0pO1xcbiAgICB0aGlzLmRlbXV4ZXIub24oJ21ldGFkYXRhJywgZnVuY3Rpb24obWV0YWRhdGEpIHtcXG4gICAgICBfdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdtZXRhZGF0YScsIF90aGlzLm1ldGFkYXRhKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiB0aGlzLmRlbXV4ZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xcbiAgICAgIHJldHVybiBfdGhpcy5zdG9wKCk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIEFzc2V0LnByb3RvdHlwZS5maW5kRGVjb2RlciA9IGZ1bmN0aW9uKGZvcm1hdCkge1xcbiAgICB2YXIgZGVjb2RlcixcXG4gICAgICBfdGhpcyA9IHRoaXM7XFxuXFxuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHRoaXMuZW1pdCgnZm9ybWF0JywgdGhpcy5mb3JtYXQpO1xcbiAgICBkZWNvZGVyID0gQVYuRGVjb2Rlci5maW5kKHRoaXMuZm9ybWF0LmZvcm1hdElEKTtcXG4gICAgaWYgKCFkZWNvZGVyKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBcXFwiQSBkZWNvZGVyIGZvciBcXFwiICsgdGhpcy5mb3JtYXQuZm9ybWF0SUQgKyBcXFwiIHdhcyBub3QgZm91bmQuXFxcIik7XFxuICAgIH1cXG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IGRlY29kZXIodGhpcy5kZW11eGVyLCB0aGlzLmZvcm1hdCk7XFxuICAgIHRoaXMuZGVjb2Rlci5vbignZGF0YScsIGZ1bmN0aW9uKGJ1ZmZlcikge1xcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdkYXRhJywgYnVmZmVyKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuZGVjb2Rlci5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcXG4gICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XFxuICAgICAgcmV0dXJuIF90aGlzLnN0b3AoKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuZGVjb2Rlci5vbignZW5kJywgZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2VuZCcpO1xcbiAgICB9KTtcXG4gICAgdGhpcy5lbWl0KCdkZWNvZGVTdGFydCcpO1xcbiAgICBpZiAodGhpcy5zaG91bGREZWNvZGUpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVjb2RlKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBBc3NldC5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uKCkge1xcbiAgICB3aGlsZSAodGhpcy5kZWNvZGVyLmRlY29kZSgpICYmIHRoaXMuYWN0aXZlKSB7XFxuICAgICAgY29udGludWU7XFxuICAgIH1cXG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5vbmNlKCdkYXRhJywgdGhpcy5fZGVjb2RlKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBBc3NldDtcXG5cXG59KShBVi5FdmVudEVtaXR0ZXIpO1xcbi8vaW1wb3J0IFxcXCJhc3NldC5jb2ZmZWVcXFwiO1xcblxcbnZhciBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5BVi5QbGF5ZXIgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XFxuICBfX2V4dGVuZHMoUGxheWVyLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gUGxheWVyKGFzc2V0KSB7XFxuICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgIHRoaXMuYXNzZXQgPSBhc3NldDtcXG4gICAgdGhpcy5zdGFydFBsYXlpbmcgPSBfX2JpbmQodGhpcy5zdGFydFBsYXlpbmcsIHRoaXMpO1xcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5idWZmZXJlZCA9IDA7XFxuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcXG4gICAgdGhpcy52b2x1bWUgPSAxMDA7XFxuICAgIHRoaXMucGFuID0gMDtcXG4gICAgdGhpcy5tZXRhZGF0YSA9IHt9O1xcbiAgICB0aGlzLmZpbHRlcnMgPSBbbmV3IEFWLlZvbHVtZUZpbHRlcih0aGlzLCAndm9sdW1lJyksIG5ldyBBVi5CYWxhbmNlRmlsdGVyKHRoaXMsICdwYW4nKV07XFxuICAgIHRoaXMuYXNzZXQub24oJ2J1ZmZlcicsIGZ1bmN0aW9uKGJ1ZmZlcmVkKSB7XFxuICAgICAgX3RoaXMuYnVmZmVyZWQgPSBidWZmZXJlZDtcXG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgnYnVmZmVyJywgX3RoaXMuYnVmZmVyZWQpO1xcbiAgICB9KTtcXG4gICAgdGhpcy5hc3NldC5vbignZGVjb2RlU3RhcnQnLCBmdW5jdGlvbigpIHtcXG4gICAgICBfdGhpcy5xdWV1ZSA9IG5ldyBBVi5RdWV1ZShfdGhpcy5hc3NldCk7XFxuICAgICAgcmV0dXJuIF90aGlzLnF1ZXVlLm9uY2UoJ3JlYWR5JywgX3RoaXMuc3RhcnRQbGF5aW5nKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuYXNzZXQub24oJ2Zvcm1hdCcsIGZ1bmN0aW9uKGZvcm1hdCkge1xcbiAgICAgIF90aGlzLmZvcm1hdCA9IGZvcm1hdDtcXG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgnZm9ybWF0JywgX3RoaXMuZm9ybWF0KTtcXG4gICAgfSk7XFxuICAgIHRoaXMuYXNzZXQub24oJ21ldGFkYXRhJywgZnVuY3Rpb24obWV0YWRhdGEpIHtcXG4gICAgICBfdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdtZXRhZGF0YScsIF90aGlzLm1ldGFkYXRhKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuYXNzZXQub24oJ2R1cmF0aW9uJywgZnVuY3Rpb24oZHVyYXRpb24pIHtcXG4gICAgICBfdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdkdXJhdGlvbicsIF90aGlzLmR1cmF0aW9uKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuYXNzZXQub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcXG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgUGxheWVyLmZyb21VUkwgPSBmdW5jdGlvbih1cmwpIHtcXG4gICAgdmFyIGFzc2V0O1xcblxcbiAgICBhc3NldCA9IEFWLkFzc2V0LmZyb21VUkwodXJsKTtcXG4gICAgcmV0dXJuIG5ldyBBVi5QbGF5ZXIoYXNzZXQpO1xcbiAgfTtcXG5cXG4gIFBsYXllci5mcm9tRmlsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcXG4gICAgdmFyIGFzc2V0O1xcblxcbiAgICBhc3NldCA9IEFWLkFzc2V0LmZyb21GaWxlKGZpbGUpO1xcbiAgICByZXR1cm4gbmV3IEFWLlBsYXllcihhc3NldCk7XFxuICB9O1xcblxcbiAgUGxheWVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICghdGhpcy5hc3NldCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB0aGlzLnN0YXJ0ZWRQcmVsb2FkaW5nID0gdHJ1ZTtcXG4gICAgcmV0dXJuIHRoaXMuYXNzZXQuc3RhcnQoZmFsc2UpO1xcbiAgfTtcXG5cXG4gIFBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgX3JlZjtcXG5cXG4gICAgaWYgKHRoaXMucGxheWluZykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoIXRoaXMuc3RhcnRlZFByZWxvYWRpbmcpIHtcXG4gICAgICB0aGlzLnByZWxvYWQoKTtcXG4gICAgfVxcbiAgICB0aGlzLnBsYXlpbmcgPSB0cnVlO1xcbiAgICByZXR1cm4gKF9yZWYgPSB0aGlzLmRldmljZSkgIT0gbnVsbCA/IF9yZWYuc3RhcnQoKSA6IHZvaWQgMDtcXG4gIH07XFxuXFxuICBQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBfcmVmO1xcblxcbiAgICBpZiAoIXRoaXMucGxheWluZykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcXG4gICAgcmV0dXJuIChfcmVmID0gdGhpcy5kZXZpY2UpICE9IG51bGwgPyBfcmVmLnN0b3AoKSA6IHZvaWQgMDtcXG4gIH07XFxuXFxuICBQbGF5ZXIucHJvdG90eXBlLnRvZ2dsZVBsYXliYWNrID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wYXVzZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiB0aGlzLnBsYXkoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFBsYXllci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgX3JlZjtcXG5cXG4gICAgdGhpcy5wYXVzZSgpO1xcbiAgICB0aGlzLmFzc2V0LnN0b3AoKTtcXG4gICAgcmV0dXJuIChfcmVmID0gdGhpcy5kZXZpY2UpICE9IG51bGwgPyBfcmVmLmRlc3Ryb3koKSA6IHZvaWQgMDtcXG4gIH07XFxuXFxuICBQbGF5ZXIucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcXG4gICAgdmFyIF9yZWYsXFxuICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBpZiAoKF9yZWYgPSB0aGlzLmRldmljZSkgIT0gbnVsbCkge1xcbiAgICAgIF9yZWYuc3RvcCgpO1xcbiAgICB9XFxuICAgIHRoaXMucXVldWUub25jZSgncmVhZHknLCBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgX3JlZjEsIF9yZWYyO1xcblxcbiAgICAgIGlmICgoX3JlZjEgPSBfdGhpcy5kZXZpY2UpICE9IG51bGwpIHtcXG4gICAgICAgIF9yZWYxLnNlZWsoX3RoaXMuY3VycmVudFRpbWUpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoX3RoaXMucGxheWluZykge1xcbiAgICAgICAgcmV0dXJuIChfcmVmMiA9IF90aGlzLmRldmljZSkgIT0gbnVsbCA/IF9yZWYyLnN0YXJ0KCkgOiB2b2lkIDA7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgdGltZXN0YW1wID0gKHRpbWVzdGFtcCAvIDEwMDApICogdGhpcy5mb3JtYXQuc2FtcGxlUmF0ZTtcXG4gICAgdGltZXN0YW1wID0gdGhpcy5hc3NldC5kZWNvZGVyLnNlZWsodGltZXN0YW1wKTtcXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHRpbWVzdGFtcCAvIHRoaXMuZm9ybWF0LnNhbXBsZVJhdGUgKiAxMDAwIHwgMDtcXG4gICAgdGhpcy5xdWV1ZS5yZXNldCgpO1xcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZTtcXG4gIH07XFxuXFxuICBQbGF5ZXIucHJvdG90eXBlLnN0YXJ0UGxheWluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgZGl2LCBmcmFtZSwgZnJhbWVPZmZzZXQsXFxuICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBmcmFtZSA9IHRoaXMucXVldWUucmVhZCgpO1xcbiAgICBmcmFtZU9mZnNldCA9IDA7XFxuICAgIGRpdiA9IHRoaXMuZm9ybWF0LmZsb2F0aW5nUG9pbnQgPyAxIDogTWF0aC5wb3coMiwgdGhpcy5mb3JtYXQuYml0c1BlckNoYW5uZWwgLSAxKTtcXG4gICAgdGhpcy5kZXZpY2UgPSBuZXcgQVYuQXVkaW9EZXZpY2UodGhpcy5mb3JtYXQuc2FtcGxlUmF0ZSwgdGhpcy5mb3JtYXQuY2hhbm5lbHNQZXJGcmFtZSk7XFxuICAgIHRoaXMuZGV2aWNlLm9uKCd0aW1lVXBkYXRlJywgZnVuY3Rpb24oY3VycmVudFRpbWUpIHtcXG4gICAgICBfdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdwcm9ncmVzcycsIF90aGlzLmN1cnJlbnRUaW1lKTtcXG4gICAgfSk7XFxuICAgIHRoaXMucmVmaWxsID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICAgICAgdmFyIGJ1ZmZlck9mZnNldCwgZmlsdGVyLCBpLCBtYXgsIF9pLCBfaiwgX2xlbiwgX3JlZjtcXG5cXG4gICAgICBpZiAoIV90aGlzLnBsYXlpbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgaWYgKCFmcmFtZSkge1xcbiAgICAgICAgZnJhbWUgPSBfdGhpcy5xdWV1ZS5yZWFkKCk7XFxuICAgICAgICBmcmFtZU9mZnNldCA9IDA7XFxuICAgICAgfVxcbiAgICAgIGJ1ZmZlck9mZnNldCA9IDA7XFxuICAgICAgd2hpbGUgKGZyYW1lICYmIGJ1ZmZlck9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcXG4gICAgICAgIG1heCA9IE1hdGgubWluKGZyYW1lLmxlbmd0aCAtIGZyYW1lT2Zmc2V0LCBidWZmZXIubGVuZ3RoIC0gYnVmZmVyT2Zmc2V0KTtcXG4gICAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCBtYXg7IGkgPSBfaSArPSAxKSB7XFxuICAgICAgICAgIGJ1ZmZlcltidWZmZXJPZmZzZXQrK10gPSBmcmFtZVtmcmFtZU9mZnNldCsrXSAvIGRpdjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChmcmFtZU9mZnNldCA9PT0gZnJhbWUubGVuZ3RoKSB7XFxuICAgICAgICAgIGZyYW1lID0gX3RoaXMucXVldWUucmVhZCgpO1xcbiAgICAgICAgICBmcmFtZU9mZnNldCA9IDA7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIF9yZWYgPSBfdGhpcy5maWx0ZXJzO1xcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjsgX2orKykge1xcbiAgICAgICAgZmlsdGVyID0gX3JlZltfal07XFxuICAgICAgICBmaWx0ZXIucHJvY2VzcyhidWZmZXIpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIWZyYW1lKSB7XFxuICAgICAgICBpZiAoX3RoaXMuYXNzZXQuZW5kZWQpIHtcXG4gICAgICAgICAgX3RoaXMuY3VycmVudFRpbWUgPSBfdGhpcy5kdXJhdGlvbjtcXG4gICAgICAgICAgX3RoaXMuZW1pdCgncHJvZ3Jlc3MnLCBfdGhpcy5jdXJyZW50VGltZSk7XFxuICAgICAgICAgIF90aGlzLmVtaXQoJ2VuZCcpO1xcbiAgICAgICAgICBfdGhpcy5zdG9wKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBfdGhpcy5kZXZpY2Uuc3RvcCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhpcy5kZXZpY2Uub24oJ3JlZmlsbCcsIHRoaXMucmVmaWxsKTtcXG4gICAgaWYgKHRoaXMucGxheWluZykge1xcbiAgICAgIHRoaXMuZGV2aWNlLnN0YXJ0KCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXMuZW1pdCgncmVhZHknKTtcXG4gIH07XFxuXFxuICByZXR1cm4gUGxheWVyO1xcblxcbn0pKEFWLkV2ZW50RW1pdHRlcik7XFxuLy9pbXBvcnQgXFxcInBsYXllci5jb2ZmZWVcXFwiO1xcblxcbi8vaW1wb3J0IFxcXCJyZXNhbXBsZXIuanNcXFwiO1xcbnZhciBXZWJLaXRBdWRpb0RldmljZSxcXG4gIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcXG4gIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xcblxcbldlYktpdEF1ZGlvRGV2aWNlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgdmFyIEF1ZGlvQ29udGV4dCwgc2hhcmVkQ29udGV4dDtcXG5cXG4gIF9fZXh0ZW5kcyhXZWJLaXRBdWRpb0RldmljZSwgX3N1cGVyKTtcXG5cXG4gIEFWLkF1ZGlvRGV2aWNlLnJlZ2lzdGVyKFdlYktpdEF1ZGlvRGV2aWNlKTtcXG5cXG4gIEF1ZGlvQ29udGV4dCA9IGdsb2JhbC5BdWRpb0NvbnRleHQgfHwgZ2xvYmFsLndlYmtpdEF1ZGlvQ29udGV4dDtcXG5cXG4gIFdlYktpdEF1ZGlvRGV2aWNlLnN1cHBvcnRlZCA9IHR5cGVvZiAoQXVkaW9Db250ZXh0ICE9IG51bGwgPyBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUphdmFTY3JpcHROb2RlIDogdm9pZCAwKSA9PT0gJ2Z1bmN0aW9uJztcXG5cXG4gIHNoYXJlZENvbnRleHQgPSBudWxsO1xcblxcbiAgZnVuY3Rpb24gV2ViS2l0QXVkaW9EZXZpY2Uoc2FtcGxlUmF0ZSwgY2hhbm5lbHMpIHtcXG4gICAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcXG4gICAgdGhpcy5jaGFubmVscyA9IGNoYW5uZWxzO1xcbiAgICB0aGlzLnJlZmlsbCA9IF9fYmluZCh0aGlzLnJlZmlsbCwgdGhpcyk7XFxuICAgIHRoaXMuY29udGV4dCA9IG1hc3RlciAhPSBudWxsID8gbWFzdGVyIDogc2hhcmVkQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQ7XFxuICAgIHRoaXMuZGV2aWNlU2FtcGxlUmF0ZSA9IHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xcbiAgICB0aGlzLmJ1ZmZlclNpemUgPSBNYXRoLmNlaWwoNDA5NiAvICh0aGlzLmRldmljZVNhbXBsZVJhdGUgLyB0aGlzLnNhbXBsZVJhdGUpICogdGhpcy5jaGFubmVscyk7XFxuICAgIHRoaXMuYnVmZmVyU2l6ZSArPSB0aGlzLmJ1ZmZlclNpemUgJSB0aGlzLmNoYW5uZWxzO1xcbiAgICBpZiAodGhpcy5kZXZpY2VTYW1wbGVSYXRlICE9PSB0aGlzLnNhbXBsZVJhdGUpIHtcXG4gICAgICB0aGlzLnJlc2FtcGxlciA9IG5ldyBSZXNhbXBsZXIodGhpcy5zYW1wbGVSYXRlLCB0aGlzLmRldmljZVNhbXBsZVJhdGUsIHRoaXMuY2hhbm5lbHMsIDQwOTYgKiB0aGlzLmNoYW5uZWxzKTtcXG4gICAgfVxcbiAgICB0aGlzLm5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlSmF2YVNjcmlwdE5vZGUoNDA5NiwgdGhpcy5jaGFubmVscywgdGhpcy5jaGFubmVscyk7XFxuICAgIHRoaXMubm9kZS5vbmF1ZGlvcHJvY2VzcyA9IHRoaXMucmVmaWxsO1xcbi8vICAgIHRoaXMubm9kZS5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XFxuICB9XFxuXFxuICBXZWJLaXRBdWRpb0RldmljZS5wcm90b3R5cGUucmVmaWxsID0gZnVuY3Rpb24oZXZlbnQpIHtcXG4gICAgdmFyIGNoYW5uZWxDb3VudCwgY2hhbm5lbHMsIGRhdGEsIGksIG4sIG91dHB1dEJ1ZmZlciwgX2ksIF9qLCBfaywgX3JlZjtcXG5cXG4gICAgb3V0cHV0QnVmZmVyID0gZXZlbnQub3V0cHV0QnVmZmVyO1xcbiAgICBjaGFubmVsQ291bnQgPSBvdXRwdXRCdWZmZXIubnVtYmVyT2ZDaGFubmVscztcXG4gICAgY2hhbm5lbHMgPSBuZXcgQXJyYXkoY2hhbm5lbENvdW50KTtcXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IGNoYW5uZWxDb3VudDsgaSA9IF9pICs9IDEpIHtcXG4gICAgICBjaGFubmVsc1tpXSA9IG91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShpKTtcXG4gICAgfVxcbiAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlclNpemUpO1xcbiAgICB0aGlzLmVtaXQoJ3JlZmlsbCcsIGRhdGEpO1xcbiAgICBpZiAodGhpcy5yZXNhbXBsZXIpIHtcXG4gICAgICBkYXRhID0gdGhpcy5yZXNhbXBsZXIucmVzYW1wbGVyKGRhdGEpO1xcbiAgICB9XFxuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZiA9IG91dHB1dEJ1ZmZlci5sZW5ndGg7IF9qIDwgX3JlZjsgaSA9IF9qICs9IDEpIHtcXG4gICAgICBmb3IgKG4gPSBfayA9IDA7IF9rIDwgY2hhbm5lbENvdW50OyBuID0gX2sgKz0gMSkge1xcbiAgICAgICAgY2hhbm5lbHNbbl1baV0gPSBkYXRhW2kgKiBjaGFubmVsQ291bnQgKyBuXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBXZWJLaXRBdWRpb0RldmljZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcy5ub2RlLmRpc2Nvbm5lY3QoMCk7XFxuICB9O1xcblxcbiAgV2ViS2l0QXVkaW9EZXZpY2UucHJvdG90eXBlLmdldERldmljZVRpbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSAqIHRoaXMuc2FtcGxlUmF0ZTtcXG4gIH07XFxuXFxuICByZXR1cm4gV2ViS2l0QXVkaW9EZXZpY2U7XFxuXFxufSkoQVYuRXZlbnRFbWl0dGVyKTtcXG4vL2ltcG9ydCBcXFwiZGV2aWNlcy93ZWJraXQuY29mZmVlXFxcIjtcXG5cXG52YXIgTW96aWxsYUF1ZGlvRGV2aWNlLFxcbiAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XFxuXFxuTW96aWxsYUF1ZGlvRGV2aWNlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgdmFyIGNyZWF0ZVRpbWVyLCBkZXN0cm95VGltZXI7XFxuXFxuICBfX2V4dGVuZHMoTW96aWxsYUF1ZGlvRGV2aWNlLCBfc3VwZXIpO1xcblxcbiAgQVYuQXVkaW9EZXZpY2UucmVnaXN0ZXIoTW96aWxsYUF1ZGlvRGV2aWNlKTtcXG5cXG4gIE1vemlsbGFBdWRpb0RldmljZS5zdXBwb3J0ZWQgPSAodHlwZW9mIEF1ZGlvICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBBdWRpbyAhPT0gbnVsbCkgJiYgJ21veldyaXRlQXVkaW8nIGluIG5ldyBBdWRpbztcXG5cXG4gIGZ1bmN0aW9uIE1vemlsbGFBdWRpb0RldmljZShzYW1wbGVSYXRlLCBjaGFubmVscykge1xcbiAgICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xcbiAgICB0aGlzLmNoYW5uZWxzID0gY2hhbm5lbHM7XFxuICAgIHRoaXMucmVmaWxsID0gX19iaW5kKHRoaXMucmVmaWxsLCB0aGlzKTtcXG4gICAgdGhpcy5hdWRpbyA9IG5ldyBBdWRpbztcXG4gICAgdGhpcy5hdWRpby5tb3pTZXR1cCh0aGlzLmNoYW5uZWxzLCB0aGlzLnNhbXBsZVJhdGUpO1xcbiAgICB0aGlzLndyaXRlUG9zaXRpb24gPSAwO1xcbiAgICB0aGlzLnByZWJ1ZmZlclNpemUgPSB0aGlzLnNhbXBsZVJhdGUgLyAyO1xcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xcbiAgICB0aGlzLnRpbWVyID0gY3JlYXRlVGltZXIodGhpcy5yZWZpbGwsIDEwMCk7XFxuICB9XFxuXFxuICBNb3ppbGxhQXVkaW9EZXZpY2UucHJvdG90eXBlLnJlZmlsbCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgYXZhaWxhYmxlLCBidWZmZXIsIGN1cnJlbnRQb3NpdGlvbiwgd3JpdHRlbjtcXG5cXG4gICAgaWYgKHRoaXMudGFpbCkge1xcbiAgICAgIHdyaXR0ZW4gPSB0aGlzLmF1ZGlvLm1veldyaXRlQXVkaW8odGhpcy50YWlsKTtcXG4gICAgICB0aGlzLndyaXRlUG9zaXRpb24gKz0gd3JpdHRlbjtcXG4gICAgICBpZiAodGhpcy53cml0ZVBvc2l0aW9uIDwgdGhpcy50YWlsLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YmFycmF5KHdyaXR0ZW4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBjdXJyZW50UG9zaXRpb24gPSB0aGlzLmF1ZGlvLm1vekN1cnJlbnRTYW1wbGVPZmZzZXQoKTtcXG4gICAgYXZhaWxhYmxlID0gY3VycmVudFBvc2l0aW9uICsgdGhpcy5wcmVidWZmZXJTaXplIC0gdGhpcy53cml0ZVBvc2l0aW9uO1xcbiAgICBpZiAoYXZhaWxhYmxlID4gMCkge1xcbiAgICAgIGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYXZhaWxhYmxlKTtcXG4gICAgICB0aGlzLmVtaXQoJ3JlZmlsbCcsIGJ1ZmZlcik7XFxuICAgICAgd3JpdHRlbiA9IHRoaXMuYXVkaW8ubW96V3JpdGVBdWRpbyhidWZmZXIpO1xcbiAgICAgIGlmICh3cml0dGVuIDwgYnVmZmVyLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy50YWlsID0gYnVmZmVyLnN1YmFycmF5KHdyaXR0ZW4pO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLndyaXRlUG9zaXRpb24gKz0gd3JpdHRlbjtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIE1vemlsbGFBdWRpb0RldmljZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gZGVzdHJveVRpbWVyKHRoaXMudGltZXIpO1xcbiAgfTtcXG5cXG4gIE1vemlsbGFBdWRpb0RldmljZS5wcm90b3R5cGUuZ2V0RGV2aWNlVGltZSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcy5hdWRpby5tb3pDdXJyZW50U2FtcGxlT2Zmc2V0KCkgLyB0aGlzLmNoYW5uZWxzO1xcbiAgfTtcXG5cXG4gIGNyZWF0ZVRpbWVyID0gZnVuY3Rpb24oZm4sIGludGVydmFsKSB7XFxuICAgIHZhciB1cmwsIHdvcmtlcjtcXG5cXG4gICAgdXJsID0gQVYuQnVmZmVyLm1ha2VCbG9iVVJMKFxcXCJzZXRJbnRlcnZhbChmdW5jdGlvbigpIHsgcG9zdE1lc3NhZ2UoJ3BpbmcnKTsgfSwgXFxcIiArIGludGVydmFsICsgXFxcIik7XFxcIik7XFxuICAgIGlmICh1cmwgPT0gbnVsbCkge1xcbiAgICAgIHJldHVybiBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpO1xcbiAgICB9XFxuICAgIHdvcmtlciA9IG5ldyBXb3JrZXIodXJsKTtcXG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IGZuO1xcbiAgICB3b3JrZXIudXJsID0gdXJsO1xcbiAgICByZXR1cm4gd29ya2VyO1xcbiAgfTtcXG5cXG4gIGRlc3Ryb3lUaW1lciA9IGZ1bmN0aW9uKHRpbWVyKSB7XFxuICAgIGlmICh0aW1lci50ZXJtaW5hdGUpIHtcXG4gICAgICB0aW1lci50ZXJtaW5hdGUoKTtcXG4gICAgICByZXR1cm4gVVJMLnJldm9rZU9iamVjdFVSTCh0aW1lci51cmwpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBjbGVhckludGVydmFsKHRpbWVyKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBNb3ppbGxhQXVkaW9EZXZpY2U7XFxuXFxufSkoQVYuRXZlbnRFbWl0dGVyKTtcXG4vL2ltcG9ydCBcXFwiZGV2aWNlcy9tb3ppbGxhLmNvZmZlZVxcXCI7XFxuXFxuQVYuRmlsdGVyID0gKGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gRmlsdGVyKGNvbnRleHQsIGtleSkge1xcbiAgICBpZiAoY29udGV4dCAmJiBrZXkpIHtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ZhbHVlJywge1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRba2V5XTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgRmlsdGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7fTtcXG5cXG4gIHJldHVybiBGaWx0ZXI7XFxuXFxufSkoKTtcXG4vL2ltcG9ydCBcXFwiZmlsdGVyLmNvZmZlZVxcXCI7XFxuXFxudmFyIF9yZWYsXFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcXG4gIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xcblxcbkFWLlZvbHVtZUZpbHRlciA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIF9fZXh0ZW5kcyhWb2x1bWVGaWx0ZXIsIF9zdXBlcik7XFxuXFxuICBmdW5jdGlvbiBWb2x1bWVGaWx0ZXIoKSB7XFxuICAgIF9yZWYgPSBWb2x1bWVGaWx0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIHJldHVybiBfcmVmO1xcbiAgfVxcblxcbiAgVm9sdW1lRmlsdGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICAgIHZhciBpLCB2b2wsIF9pLCBfcmVmMTtcXG5cXG4gICAgaWYgKHRoaXMudmFsdWUgPj0gMTAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgdGhpcy52YWx1ZSkpIC8gMTAwO1xcbiAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYxID0gYnVmZmVyLmxlbmd0aDsgX2kgPCBfcmVmMTsgaSA9IF9pICs9IDEpIHtcXG4gICAgICBidWZmZXJbaV0gKj0gdm9sO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIFZvbHVtZUZpbHRlcjtcXG5cXG59KShBVi5GaWx0ZXIpO1xcbi8vaW1wb3J0IFxcXCJmaWx0ZXJzL3ZvbHVtZS5jb2ZmZWVcXFwiO1xcblxcbnZhciBfcmVmLFxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5BVi5CYWxhbmNlRmlsdGVyID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgX19leHRlbmRzKEJhbGFuY2VGaWx0ZXIsIF9zdXBlcik7XFxuXFxuICBmdW5jdGlvbiBCYWxhbmNlRmlsdGVyKCkge1xcbiAgICBfcmVmID0gQmFsYW5jZUZpbHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgcmV0dXJuIF9yZWY7XFxuICB9XFxuXFxuICBCYWxhbmNlRmlsdGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICAgIHZhciBpLCBwYW4sIF9pLCBfcmVmMTtcXG5cXG4gICAgaWYgKHRoaXMudmFsdWUgPT09IDApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgcGFuID0gTWF0aC5tYXgoLTUwLCBNYXRoLm1pbig1MCwgdGhpcy52YWx1ZSkpO1xcbiAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYxID0gYnVmZmVyLmxlbmd0aDsgX2kgPCBfcmVmMTsgaSA9IF9pICs9IDIpIHtcXG4gICAgICBidWZmZXJbaV0gKj0gTWF0aC5taW4oMSwgKDUwIC0gcGFuKSAvIDUwKTtcXG4gICAgICBidWZmZXJbaSArIDFdICo9IE1hdGgubWluKDEsICg1MCArIHBhbikgLyA1MCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICByZXR1cm4gQmFsYW5jZUZpbHRlcjtcXG5cXG59KShBVi5GaWx0ZXIpO1xcbi8vaW1wb3J0IFxcXCJmaWx0ZXJzL2JhbGFuY2UuY29mZmVlXFxcIjtcXG5cXG52YXIgQ0FGRGVtdXhlciwgX3JlZixcXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XFxuXFxuQ0FGRGVtdXhlciA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIF9fZXh0ZW5kcyhDQUZEZW11eGVyLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gQ0FGRGVtdXhlcigpIHtcXG4gICAgX3JlZiA9IENBRkRlbXV4ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIHJldHVybiBfcmVmO1xcbiAgfVxcblxcbiAgQVYuRGVtdXhlci5yZWdpc3RlcihDQUZEZW11eGVyKTtcXG5cXG4gIENBRkRlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbihidWZmZXIpIHtcXG4gICAgcmV0dXJuIGJ1ZmZlci5wZWVrU3RyaW5nKDAsIDQpID09PSAnY2FmZic7XFxuICB9O1xcblxcbiAgQ0FGRGVtdXhlci5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBidWZmZXIsIGJ5dGVPZmZzZXQsIGNvb2tpZSwgZW50cmllcywgZmxhZ3MsIGksIGtleSwgbWV0YWRhdGEsIG9mZnNldCwgc2FtcGxlT2Zmc2V0LCB2YWx1ZSwgX2ksIF9qLCBfcmVmMTtcXG5cXG4gICAgaWYgKCF0aGlzLmZvcm1hdCAmJiB0aGlzLnN0cmVhbS5hdmFpbGFibGUoNjQpKSB7XFxuICAgICAgaWYgKHRoaXMuc3RyZWFtLnJlYWRTdHJpbmcoNCkgIT09ICdjYWZmJykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBcXFwiSW52YWxpZCBDQUYsIGRvZXMgbm90IGJlZ2luIHdpdGggJ2NhZmYnXFxcIik7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuc3RyZWFtLmFkdmFuY2UoNCk7XFxuICAgICAgaWYgKHRoaXMuc3RyZWFtLnJlYWRTdHJpbmcoNCkgIT09ICdkZXNjJykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBcXFwiSW52YWxpZCBDQUYsICdjYWZmJyBpcyBub3QgZm9sbG93ZWQgYnkgJ2Rlc2MnXFxcIik7XFxuICAgICAgfVxcbiAgICAgIGlmICghKHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKSA9PT0gMCAmJiB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCkgPT09IDMyKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBcXFwiSW52YWxpZCAnZGVzYycgc2l6ZSwgc2hvdWxkIGJlIDMyXFxcIik7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuZm9ybWF0ID0ge307XFxuICAgICAgdGhpcy5mb3JtYXQuc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtLnJlYWRGbG9hdDY0KCk7XFxuICAgICAgdGhpcy5mb3JtYXQuZm9ybWF0SUQgPSB0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpO1xcbiAgICAgIGZsYWdzID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICAgIGlmICh0aGlzLmZvcm1hdC5mb3JtYXRJRCA9PT0gJ2xwY20nKSB7XFxuICAgICAgICB0aGlzLmZvcm1hdC5mbG9hdGluZ1BvaW50ID0gQm9vbGVhbihmbGFncyAmIDEpO1xcbiAgICAgICAgdGhpcy5mb3JtYXQubGl0dGxlRW5kaWFuID0gQm9vbGVhbihmbGFncyAmIDIpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLmZvcm1hdC5ieXRlc1BlclBhY2tldCA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgICB0aGlzLmZvcm1hdC5mcmFtZXNQZXJQYWNrZXQgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgICAgdGhpcy5mb3JtYXQuY2hhbm5lbHNQZXJGcmFtZSA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgICB0aGlzLmZvcm1hdC5iaXRzUGVyQ2hhbm5lbCA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgICB0aGlzLmVtaXQoJ2Zvcm1hdCcsIHRoaXMuZm9ybWF0KTtcXG4gICAgfVxcbiAgICB3aGlsZSAodGhpcy5zdHJlYW0uYXZhaWxhYmxlKDEpKSB7XFxuICAgICAgaWYgKCF0aGlzLmhlYWRlckNhY2hlKSB7XFxuICAgICAgICB0aGlzLmhlYWRlckNhY2hlID0ge1xcbiAgICAgICAgICB0eXBlOiB0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpLFxcbiAgICAgICAgICBvdmVyc2l6ZTogdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpICE9PSAwLFxcbiAgICAgICAgICBzaXplOiB0aGlzLnN0cmVhbS5yZWFkVUludDMyKClcXG4gICAgICAgIH07XFxuICAgICAgICBpZiAodGhpcy5oZWFkZXJDYWNoZS5vdmVyc2l6ZSkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIFxcXCJIb2x5IFNoaXQsIGFuIG92ZXJzaXplZCBmaWxlLCBub3Qgc3VwcG9ydGVkIGluIEpTXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHN3aXRjaCAodGhpcy5oZWFkZXJDYWNoZS50eXBlKSB7XFxuICAgICAgICBjYXNlICdrdWtpJzpcXG4gICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmF2YWlsYWJsZSh0aGlzLmhlYWRlckNhY2hlLnNpemUpKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0LmZvcm1hdElEID09PSAnYWFjICcpIHtcXG4gICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc3RyZWFtLm9mZnNldCArIHRoaXMuaGVhZGVyQ2FjaGUuc2l6ZTtcXG4gICAgICAgICAgICAgIGlmIChjb29raWUgPSBNNEFEZW11eGVyLnJlYWRFc2RzKHRoaXMuc3RyZWFtKSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvb2tpZScsIGNvb2tpZSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5zZWVrKG9mZnNldCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuc3RyZWFtLnJlYWRCdWZmZXIodGhpcy5oZWFkZXJDYWNoZS5zaXplKTtcXG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29va2llJywgYnVmZmVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5oZWFkZXJDYWNoZSA9IG51bGw7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICdwYWt0JzpcXG4gICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmF2YWlsYWJsZSh0aGlzLmhlYWRlckNhY2hlLnNpemUpKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKSAhPT0gMCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCAnU2l6ZXMgZ3JlYXRlciB0aGFuIDMyIGJpdHMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMubnVtUGFja2V0cyA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpICE9PSAwKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsICdTaXplcyBncmVhdGVyIHRoYW4gMzIgYml0cyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5udW1GcmFtZXMgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgICAgICAgICAgdGhpcy5wcmltaW5nRnJhbWVzID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICAgICAgICAgIHRoaXMucmVtYWluZGVyRnJhbWVzID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHVyYXRpb24nLCB0aGlzLm51bUZyYW1lcyAvIHRoaXMuZm9ybWF0LnNhbXBsZVJhdGUgKiAxMDAwIHwgMCk7XFxuICAgICAgICAgICAgdGhpcy5zZW50RHVyYXRpb24gPSB0cnVlO1xcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwO1xcbiAgICAgICAgICAgIHNhbXBsZU9mZnNldCA9IDA7XFxuICAgICAgICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmMSA9IHRoaXMubnVtUGFja2V0czsgX2kgPCBfcmVmMTsgaSA9IF9pICs9IDEpIHtcXG4gICAgICAgICAgICAgIHRoaXMuYWRkU2Vla1BvaW50KGJ5dGVPZmZzZXQsIHNhbXBsZU9mZnNldCk7XFxuICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IHRoaXMuZm9ybWF0LmJ5dGVzUGVyUGFja2V0IHx8IE00QURlbXV4ZXIucmVhZERlc2NyTGVuKHRoaXMuc3RyZWFtKTtcXG4gICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSB0aGlzLmZvcm1hdC5mcmFtZXNQZXJQYWNrZXQgfHwgTTRBRGVtdXhlci5yZWFkRGVzY3JMZW4odGhpcy5zdHJlYW0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLmhlYWRlckNhY2hlID0gbnVsbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgJ2luZm8nOlxcbiAgICAgICAgICBlbnRyaWVzID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICAgICAgICBtZXRhZGF0YSA9IHt9O1xcbiAgICAgICAgICBmb3IgKGkgPSBfaiA9IDA7IDAgPD0gZW50cmllcyA/IF9qIDwgZW50cmllcyA6IF9qID4gZW50cmllczsgaSA9IDAgPD0gZW50cmllcyA/ICsrX2ogOiAtLV9qKSB7XFxuICAgICAgICAgICAga2V5ID0gdGhpcy5zdHJlYW0ucmVhZFN0cmluZyhudWxsKTtcXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuc3RyZWFtLnJlYWRTdHJpbmcobnVsbCk7XFxuICAgICAgICAgICAgbWV0YWRhdGFba2V5XSA9IHZhbHVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRoaXMuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XFxuICAgICAgICAgIHRoaXMuaGVhZGVyQ2FjaGUgPSBudWxsO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgJ2RhdGEnOlxcbiAgICAgICAgICBpZiAoIXRoaXMuc2VudEZpcnN0RGF0YUNodW5rKSB7XFxuICAgICAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgICAgICAgICB0aGlzLmhlYWRlckNhY2hlLnNpemUgLT0gNDtcXG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQuYnl0ZXNQZXJQYWNrZXQgIT09IDAgJiYgIXRoaXMuc2VudER1cmF0aW9uKSB7XFxuICAgICAgICAgICAgICB0aGlzLm51bUZyYW1lcyA9IHRoaXMuaGVhZGVyQ2FjaGUuc2l6ZSAvIHRoaXMuZm9ybWF0LmJ5dGVzUGVyUGFja2V0O1xcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkdXJhdGlvbicsIHRoaXMubnVtRnJhbWVzIC8gdGhpcy5mb3JtYXQuc2FtcGxlUmF0ZSAqIDEwMDAgfCAwKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5zZW50Rmlyc3REYXRhQ2h1bmsgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuc3RyZWFtLnJlYWRTaW5nbGVCdWZmZXIodGhpcy5oZWFkZXJDYWNoZS5zaXplKTtcXG4gICAgICAgICAgdGhpcy5oZWFkZXJDYWNoZS5zaXplIC09IGJ1ZmZlci5sZW5ndGg7XFxuICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGJ1ZmZlcik7XFxuICAgICAgICAgIGlmICh0aGlzLmhlYWRlckNhY2hlLnNpemUgPD0gMCkge1xcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyQ2FjaGUgPSBudWxsO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmF2YWlsYWJsZSh0aGlzLmhlYWRlckNhY2hlLnNpemUpKSB7XFxuICAgICAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZSh0aGlzLmhlYWRlckNhY2hlLnNpemUpO1xcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyQ2FjaGUgPSBudWxsO1xcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIENBRkRlbXV4ZXI7XFxuXFxufSkoQVYuRGVtdXhlcik7XFxuLy9pbXBvcnQgXFxcImRlbXV4ZXJzL2NhZi5jb2ZmZWVcXFwiO1xcblxcbnZhciBNNEFEZW11eGVyLCBfcmVmLFxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcXG4gIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xcblxcbk00QURlbXV4ZXIgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XFxuICB2YXIgQklUU19QRVJfQ0hBTk5FTCwgVFlQRVMsIGFmdGVyLCBhdG9tLCBhdG9tcywgYm9vbCwgY29udGFpbmVycywgZGlza1RyYWNrLCBnZW5yZXMsIG1ldGEsIHN0cmluZztcXG5cXG4gIF9fZXh0ZW5kcyhNNEFEZW11eGVyLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gTTRBRGVtdXhlcigpIHtcXG4gICAgX3JlZiA9IE00QURlbXV4ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIHJldHVybiBfcmVmO1xcbiAgfVxcblxcbiAgQVYuRGVtdXhlci5yZWdpc3RlcihNNEFEZW11eGVyKTtcXG5cXG4gIFRZUEVTID0gWydNNEEgJywgJ000UCAnLCAnTTRCICcsICdNNFYgJywgJ2lzb20nLCAnbXA0MicsICdxdCAgJ107XFxuXFxuICBNNEFEZW11eGVyLnByb2JlID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICAgIHZhciBfcmVmMTtcXG5cXG4gICAgcmV0dXJuIGJ1ZmZlci5wZWVrU3RyaW5nKDQsIDQpID09PSAnZnR5cCcgJiYgKF9yZWYxID0gYnVmZmVyLnBlZWtTdHJpbmcoOCwgNCksIF9faW5kZXhPZi5jYWxsKFRZUEVTLCBfcmVmMSkgPj0gMCk7XFxuICB9O1xcblxcbiAgTTRBRGVtdXhlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLmF0b21zID0gW107XFxuICAgIHRoaXMub2Zmc2V0cyA9IFtdO1xcbiAgICB0aGlzLnRyYWNrID0gbnVsbDtcXG4gICAgcmV0dXJuIHRoaXMudHJhY2tzID0gW107XFxuICB9O1xcblxcbiAgYXRvbXMgPSB7fTtcXG5cXG4gIGNvbnRhaW5lcnMgPSB7fTtcXG5cXG4gIGF0b20gPSBmdW5jdGlvbihuYW1lLCBmbikge1xcbiAgICB2YXIgYywgY29udGFpbmVyLCBfaSwgX2xlbiwgX3JlZjEsIF9yZWYyO1xcblxcbiAgICBjID0gW107XFxuICAgIF9yZWYxID0gbmFtZS5zcGxpdCgnLicpLnNsaWNlKDAsIC0xKTtcXG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xcbiAgICAgIGNvbnRhaW5lciA9IF9yZWYxW19pXTtcXG4gICAgICBjLnB1c2goY29udGFpbmVyKTtcXG4gICAgICBjb250YWluZXJzW2Muam9pbignLicpXSA9IHRydWU7XFxuICAgIH1cXG4gICAgaWYgKChfcmVmMiA9IGF0b21zW25hbWVdKSA9PSBudWxsKSB7XFxuICAgICAgYXRvbXNbbmFtZV0gPSB7fTtcXG4gICAgfVxcbiAgICByZXR1cm4gYXRvbXNbbmFtZV0uZm4gPSBmbjtcXG4gIH07XFxuXFxuICBhZnRlciA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XFxuICAgIHZhciBfcmVmMTtcXG5cXG4gICAgaWYgKChfcmVmMSA9IGF0b21zW25hbWVdKSA9PSBudWxsKSB7XFxuICAgICAgYXRvbXNbbmFtZV0gPSB7fTtcXG4gICAgfVxcbiAgICByZXR1cm4gYXRvbXNbbmFtZV0uYWZ0ZXIgPSBmbjtcXG4gIH07XFxuXFxuICBNNEFEZW11eGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGhhbmRsZXIsIHBhdGgsIHR5cGU7XFxuXFxuICAgIHRoaXNbXFxcImJyZWFrXFxcIl0gPSBmYWxzZTtcXG4gICAgd2hpbGUgKHRoaXMuc3RyZWFtLmF2YWlsYWJsZSgxKSAmJiAhdGhpc1tcXFwiYnJlYWtcXFwiXSkge1xcbiAgICAgIGlmICghdGhpcy5yZWFkSGVhZGVycykge1xcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbS5hdmFpbGFibGUoOCkpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5sZW4gPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCkgLSA4O1xcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy5zdHJlYW0ucmVhZFN0cmluZyg0KTtcXG4gICAgICAgIGlmICh0aGlzLmxlbiA9PT0gMCkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuYXRvbXMucHVzaCh0aGlzLnR5cGUpO1xcbiAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2godGhpcy5zdHJlYW0ub2Zmc2V0ICsgdGhpcy5sZW4pO1xcbiAgICAgICAgdGhpcy5yZWFkSGVhZGVycyA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIHBhdGggPSB0aGlzLmF0b21zLmpvaW4oJy4nKTtcXG4gICAgICBoYW5kbGVyID0gYXRvbXNbcGF0aF07XFxuICAgICAgaWYgKGhhbmRsZXIgIT0gbnVsbCA/IGhhbmRsZXIuZm4gOiB2b2lkIDApIHtcXG4gICAgICAgIGlmICghKHRoaXMuc3RyZWFtLmF2YWlsYWJsZSh0aGlzLmxlbikgfHwgcGF0aCA9PT0gJ21kYXQnKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBoYW5kbGVyLmZuLmNhbGwodGhpcyk7XFxuICAgICAgICBpZiAocGF0aCBpbiBjb250YWluZXJzKSB7XFxuICAgICAgICAgIHRoaXMucmVhZEhlYWRlcnMgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHBhdGggaW4gY29udGFpbmVycykge1xcbiAgICAgICAgdGhpcy5yZWFkSGVhZGVycyA9IGZhbHNlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoIXRoaXMuc3RyZWFtLmF2YWlsYWJsZSh0aGlzLmxlbikpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZSh0aGlzLmxlbik7XFxuICAgICAgfVxcbiAgICAgIHdoaWxlICh0aGlzLnN0cmVhbS5vZmZzZXQgPj0gdGhpcy5vZmZzZXRzW3RoaXMub2Zmc2V0cy5sZW5ndGggLSAxXSkge1xcbiAgICAgICAgaGFuZGxlciA9IGF0b21zW3RoaXMuYXRvbXMuam9pbignLicpXTtcXG4gICAgICAgIGlmIChoYW5kbGVyICE9IG51bGwgPyBoYW5kbGVyLmFmdGVyIDogdm9pZCAwKSB7XFxuICAgICAgICAgIGhhbmRsZXIuYWZ0ZXIuY2FsbCh0aGlzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHR5cGUgPSB0aGlzLmF0b21zLnBvcCgpO1xcbiAgICAgICAgdGhpcy5vZmZzZXRzLnBvcCgpO1xcbiAgICAgICAgdGhpcy5yZWFkSGVhZGVycyA9IGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIGF0b20oJ2Z0eXAnLCBmdW5jdGlvbigpIHtcXG4gICAgdmFyIF9yZWYxO1xcblxcbiAgICBpZiAoX3JlZjEgPSB0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpLCBfX2luZGV4T2YuY2FsbChUWVBFUywgX3JlZjEpIDwgMCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgJ05vdCBhIHZhbGlkIE00QSBmaWxlLicpO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLnN0cmVhbS5hZHZhbmNlKHRoaXMubGVuIC0gNCk7XFxuICB9KTtcXG5cXG4gIGF0b20oJ21vb3YudHJhaycsIGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLnRyYWNrID0ge307XFxuICAgIHJldHVybiB0aGlzLnRyYWNrcy5wdXNoKHRoaXMudHJhY2spO1xcbiAgfSk7XFxuXFxuICBhdG9tKCdtb292LnRyYWsudGtoZCcsIGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDgpO1xcbiAgICB0aGlzLnRyYWNrLmlkID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uYWR2YW5jZSh0aGlzLmxlbiAtIDE2KTtcXG4gIH0pO1xcblxcbiAgYXRvbSgnbW9vdi50cmFrLm1kaWEuaGRscicsIGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgICB0aGlzLnRyYWNrLnR5cGUgPSB0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDEyKTtcXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtLmFkdmFuY2UodGhpcy5sZW4gLSAyNCk7XFxuICB9KTtcXG5cXG4gIGF0b20oJ21vb3YudHJhay5tZGlhLm1kaGQnLCBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5zdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgdGhpcy5zdHJlYW0uYWR2YW5jZSg4KTtcXG4gICAgdGhpcy50cmFjay50aW1lU2NhbGUgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgIHRoaXMudHJhY2suZHVyYXRpb24gPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgIHJldHVybiB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgfSk7XFxuXFxuICBCSVRTX1BFUl9DSEFOTkVMID0ge1xcbiAgICB1bGF3OiA4LFxcbiAgICBhbGF3OiA4LFxcbiAgICBpbjI0OiAyNCxcXG4gICAgaW4zMjogMzIsXFxuICAgIGZsMzI6IDMyLFxcbiAgICBmbDY0OiA2NFxcbiAgfTtcXG5cXG4gIGF0b20oJ21vb3YudHJhay5tZGlhLm1pbmYuc3RibC5zdHNkJywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciBmb3JtYXQsIG51bUVudHJpZXMsIHZlcnNpb24sIF9yZWYxLCBfcmVmMjtcXG5cXG4gICAgdGhpcy5zdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgbnVtRW50cmllcyA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgaWYgKHRoaXMudHJhY2sudHlwZSAhPT0gJ3NvdW4nKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLmFkdmFuY2UodGhpcy5sZW4gLSA4KTtcXG4gICAgfVxcbiAgICBpZiAobnVtRW50cmllcyAhPT0gMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgXFxcIk9ubHkgZXhwZWN0aW5nIG9uZSBlbnRyeSBpbiBzYW1wbGUgZGVzY3JpcHRpb24gYXRvbSFcXFwiKTtcXG4gICAgfVxcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgICBmb3JtYXQgPSB0aGlzLnRyYWNrLmZvcm1hdCA9IHt9O1xcbiAgICBmb3JtYXQuZm9ybWF0SUQgPSB0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDYpO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDIpO1xcbiAgICB2ZXJzaW9uID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQxNigpO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDYpO1xcbiAgICBmb3JtYXQuY2hhbm5lbHNQZXJGcmFtZSA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MTYoKTtcXG4gICAgZm9ybWF0LmJpdHNQZXJDaGFubmVsID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQxNigpO1xcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgICBmb3JtYXQuc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MTYoKTtcXG4gICAgdGhpcy5zdHJlYW0uYWR2YW5jZSgyKTtcXG4gICAgaWYgKHZlcnNpb24gPT09IDEpIHtcXG4gICAgICBmb3JtYXQuZnJhbWVzUGVyUGFja2V0ID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICAgIHRoaXMuc3RyZWFtLmFkdmFuY2UoNCk7XFxuICAgICAgZm9ybWF0LmJ5dGVzUGVyRnJhbWUgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgfSBlbHNlIGlmICh2ZXJzaW9uICE9PSAwKSB7XFxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsICdVbmtub3duIHZlcnNpb24gaW4gc3RzZCBhdG9tJyk7XFxuICAgIH1cXG4gICAgaWYgKEJJVFNfUEVSX0NIQU5ORUxbZm9ybWF0LmZvcm1hdElEXSAhPSBudWxsKSB7XFxuICAgICAgZm9ybWF0LmJpdHNQZXJDaGFubmVsID0gQklUU19QRVJfQ0hBTk5FTFtmb3JtYXQuZm9ybWF0SURdO1xcbiAgICB9XFxuICAgIGZvcm1hdC5mbG9hdGluZ1BvaW50ID0gKF9yZWYxID0gZm9ybWF0LmZvcm1hdElEKSA9PT0gJ2ZsMzInIHx8IF9yZWYxID09PSAnZmw2NCc7XFxuICAgIGZvcm1hdC5saXR0bGVFbmRpYW4gPSBmb3JtYXQuZm9ybWF0SUQgPT09ICdzb3d0JyAmJiBmb3JtYXQuYml0c1BlckNoYW5uZWwgPiA4O1xcbiAgICBpZiAoKF9yZWYyID0gZm9ybWF0LmZvcm1hdElEKSA9PT0gJ3R3b3MnIHx8IF9yZWYyID09PSAnc293dCcgfHwgX3JlZjIgPT09ICdpbjI0JyB8fCBfcmVmMiA9PT0gJ2luMzInIHx8IF9yZWYyID09PSAnZmwzMicgfHwgX3JlZjIgPT09ICdmbDY0JyB8fCBfcmVmMiA9PT0gJ3JhdyAnIHx8IF9yZWYyID09PSAnTk9ORScpIHtcXG4gICAgICByZXR1cm4gZm9ybWF0LmZvcm1hdElEID0gJ2xwY20nO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIGF0b20oJ21vb3YudHJhay5tZGlhLm1pbmYuc3RibC5zdHNkLmFsYWMnLCBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5zdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgcmV0dXJuIHRoaXMudHJhY2suY29va2llID0gdGhpcy5zdHJlYW0ucmVhZEJ1ZmZlcih0aGlzLmxlbiAtIDQpO1xcbiAgfSk7XFxuXFxuICBhdG9tKCdtb292LnRyYWsubWRpYS5taW5mLnN0Ymwuc3RzZC5lc2RzJywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciBvZmZzZXQ7XFxuXFxuICAgIG9mZnNldCA9IHRoaXMuc3RyZWFtLm9mZnNldCArIHRoaXMubGVuO1xcbiAgICB0aGlzLnRyYWNrLmNvb2tpZSA9IE00QURlbXV4ZXIucmVhZEVzZHModGhpcy5zdHJlYW0pO1xcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uc2VlayhvZmZzZXQpO1xcbiAgfSk7XFxuXFxuICBhdG9tKCdtb292LnRyYWsubWRpYS5taW5mLnN0Ymwuc3RzZC53YXZlLmVuZGEnLCBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMudHJhY2suZm9ybWF0LmxpdHRsZUVuZGlhbiA9ICEhdGhpcy5zdHJlYW0ucmVhZFVJbnQxNigpO1xcbiAgfSk7XFxuXFxuICBNNEFEZW11eGVyLnJlYWREZXNjckxlbiA9IGZ1bmN0aW9uKHN0cmVhbSkge1xcbiAgICB2YXIgYywgY291bnQsIGxlbjtcXG5cXG4gICAgbGVuID0gMDtcXG4gICAgY291bnQgPSA0O1xcbiAgICB3aGlsZSAoY291bnQtLSkge1xcbiAgICAgIGMgPSBzdHJlYW0ucmVhZFVJbnQ4KCk7XFxuICAgICAgbGVuID0gKGxlbiA8PCA3KSB8IChjICYgMHg3Zik7XFxuICAgICAgaWYgKCEoYyAmIDB4ODApKSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGxlbjtcXG4gIH07XFxuXFxuICBNNEFEZW11eGVyLnJlYWRFc2RzID0gZnVuY3Rpb24oc3RyZWFtKSB7XFxuICAgIHZhciBjb2RlY19pZCwgZmxhZ3MsIGxlbiwgdGFnO1xcblxcbiAgICBzdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgdGFnID0gc3RyZWFtLnJlYWRVSW50OCgpO1xcbiAgICBsZW4gPSBNNEFEZW11eGVyLnJlYWREZXNjckxlbihzdHJlYW0pO1xcbiAgICBpZiAodGFnID09PSAweDAzKSB7XFxuICAgICAgc3RyZWFtLmFkdmFuY2UoMik7XFxuICAgICAgZmxhZ3MgPSBzdHJlYW0ucmVhZFVJbnQ4KCk7XFxuICAgICAgaWYgKGZsYWdzICYgMHg4MCkge1xcbiAgICAgICAgc3RyZWFtLmFkdmFuY2UoMik7XFxuICAgICAgfVxcbiAgICAgIGlmIChmbGFncyAmIDB4NDApIHtcXG4gICAgICAgIHN0cmVhbS5hZHZhbmNlKHN0cmVhbS5yZWFkVUludDgoKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChmbGFncyAmIDB4MjApIHtcXG4gICAgICAgIHN0cmVhbS5hZHZhbmNlKDIpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0uYWR2YW5jZSgyKTtcXG4gICAgfVxcbiAgICB0YWcgPSBzdHJlYW0ucmVhZFVJbnQ4KCk7XFxuICAgIGxlbiA9IE00QURlbXV4ZXIucmVhZERlc2NyTGVuKHN0cmVhbSk7XFxuICAgIGlmICh0YWcgPT09IDB4MDQpIHtcXG4gICAgICBjb2RlY19pZCA9IHN0cmVhbS5yZWFkVUludDgoKTtcXG4gICAgICBzdHJlYW0uYWR2YW5jZSgxKTtcXG4gICAgICBzdHJlYW0uYWR2YW5jZSgzKTtcXG4gICAgICBzdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgICBzdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgICB0YWcgPSBzdHJlYW0ucmVhZFVJbnQ4KCk7XFxuICAgICAgbGVuID0gTTRBRGVtdXhlci5yZWFkRGVzY3JMZW4oc3RyZWFtKTtcXG4gICAgICBpZiAodGFnID09PSAweDA1KSB7XFxuICAgICAgICByZXR1cm4gc3RyZWFtLnJlYWRCdWZmZXIobGVuKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcblxcbiAgYXRvbSgnbW9vdi50cmFrLm1kaWEubWluZi5zdGJsLnN0dHMnLCBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGVudHJpZXMsIGksIF9pO1xcblxcbiAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgICBlbnRyaWVzID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICB0aGlzLnRyYWNrLnN0dHMgPSBbXTtcXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IGVudHJpZXM7IGkgPSBfaSArPSAxKSB7XFxuICAgICAgdGhpcy50cmFjay5zdHRzW2ldID0ge1xcbiAgICAgICAgY291bnQ6IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKSxcXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLnN0cmVhbS5yZWFkVUludDMyKClcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLnNldHVwU2Vla1BvaW50cygpO1xcbiAgfSk7XFxuXFxuICBhdG9tKCdtb292LnRyYWsubWRpYS5taW5mLnN0Ymwuc3RzYycsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgZW50cmllcywgaSwgX2k7XFxuXFxuICAgIHRoaXMuc3RyZWFtLmFkdmFuY2UoNCk7XFxuICAgIGVudHJpZXMgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgIHRoaXMudHJhY2suc3RzYyA9IFtdO1xcbiAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgZW50cmllczsgaSA9IF9pICs9IDEpIHtcXG4gICAgICB0aGlzLnRyYWNrLnN0c2NbaV0gPSB7XFxuICAgICAgICBmaXJzdDogdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpLFxcbiAgICAgICAgY291bnQ6IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKSxcXG4gICAgICAgIGlkOiB0aGlzLnN0cmVhbS5yZWFkVUludDMyKClcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLnNldHVwU2Vla1BvaW50cygpO1xcbiAgfSk7XFxuXFxuICBhdG9tKCdtb292LnRyYWsubWRpYS5taW5mLnN0Ymwuc3RzeicsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgZW50cmllcywgaSwgX2k7XFxuXFxuICAgIHRoaXMuc3RyZWFtLmFkdmFuY2UoNCk7XFxuICAgIHRoaXMudHJhY2suc2FtcGxlU2l6ZSA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgZW50cmllcyA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgaWYgKHRoaXMudHJhY2suc2FtcGxlU2l6ZSA9PT0gMCAmJiBlbnRyaWVzID4gMCkge1xcbiAgICAgIHRoaXMudHJhY2suc2FtcGxlU2l6ZXMgPSBbXTtcXG4gICAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgZW50cmllczsgaSA9IF9pICs9IDEpIHtcXG4gICAgICAgIHRoaXMudHJhY2suc2FtcGxlU2l6ZXNbaV0gPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLnNldHVwU2Vla1BvaW50cygpO1xcbiAgfSk7XFxuXFxuICBhdG9tKCdtb292LnRyYWsubWRpYS5taW5mLnN0Ymwuc3RjbycsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgZW50cmllcywgaSwgX2k7XFxuXFxuICAgIHRoaXMuc3RyZWFtLmFkdmFuY2UoNCk7XFxuICAgIGVudHJpZXMgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgIHRoaXMudHJhY2suY2h1bmtPZmZzZXRzID0gW107XFxuICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCBlbnRyaWVzOyBpID0gX2kgKz0gMSkge1xcbiAgICAgIHRoaXMudHJhY2suY2h1bmtPZmZzZXRzW2ldID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLnNldHVwU2Vla1BvaW50cygpO1xcbiAgfSk7XFxuXFxuICBhdG9tKCdtb292LnRyYWsudHJlZi5jaGFwJywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciBlbnRyaWVzLCBpLCBfaTtcXG5cXG4gICAgZW50cmllcyA9IHRoaXMubGVuID4+IDI7XFxuICAgIHRoaXMudHJhY2suY2hhcHRlclRyYWNrcyA9IFtdO1xcbiAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgZW50cmllczsgaSA9IF9pICs9IDEpIHtcXG4gICAgICB0aGlzLnRyYWNrLmNoYXB0ZXJUcmFja3NbaV0gPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgTTRBRGVtdXhlci5wcm90b3R5cGUuc2V0dXBTZWVrUG9pbnRzID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBpLCBqLCBvZmZzZXQsIHBvc2l0aW9uLCBzYW1wbGVJbmRleCwgc2l6ZSwgc3RzY0luZGV4LCBzdHRzSW5kZXgsIHN0dHNTYW1wbGUsIHRpbWVzdGFtcCwgX2ksIF9qLCBfbGVuLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xcblxcbiAgICBpZiAoISgodGhpcy50cmFjay5jaHVua09mZnNldHMgIT0gbnVsbCkgJiYgKHRoaXMudHJhY2suc3RzYyAhPSBudWxsKSAmJiAodGhpcy50cmFjay5zYW1wbGVTaXplICE9IG51bGwpICYmICh0aGlzLnRyYWNrLnN0dHMgIT0gbnVsbCkpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHN0c2NJbmRleCA9IDA7XFxuICAgIHN0dHNJbmRleCA9IDA7XFxuICAgIHN0dHNJbmRleCA9IDA7XFxuICAgIHN0dHNTYW1wbGUgPSAwO1xcbiAgICBzYW1wbGVJbmRleCA9IDA7XFxuICAgIG9mZnNldCA9IDA7XFxuICAgIHRpbWVzdGFtcCA9IDA7XFxuICAgIHRoaXMudHJhY2suc2Vla1BvaW50cyA9IFtdO1xcbiAgICBfcmVmMSA9IHRoaXMudHJhY2suY2h1bmtPZmZzZXRzO1xcbiAgICBfcmVzdWx0cyA9IFtdO1xcbiAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcXG4gICAgICBwb3NpdGlvbiA9IF9yZWYxW2ldO1xcbiAgICAgIGZvciAoaiA9IF9qID0gMCwgX3JlZjIgPSB0aGlzLnRyYWNrLnN0c2Nbc3RzY0luZGV4XS5jb3VudDsgX2ogPCBfcmVmMjsgaiA9IF9qICs9IDEpIHtcXG4gICAgICAgIHRoaXMudHJhY2suc2Vla1BvaW50cy5wdXNoKHtcXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcXG4gICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcXG4gICAgICAgIH0pO1xcbiAgICAgICAgc2l6ZSA9IHRoaXMudHJhY2suc2FtcGxlU2l6ZSB8fCB0aGlzLnRyYWNrLnNhbXBsZVNpemVzW3NhbXBsZUluZGV4KytdO1xcbiAgICAgICAgb2Zmc2V0ICs9IHNpemU7XFxuICAgICAgICBwb3NpdGlvbiArPSBzaXplO1xcbiAgICAgICAgdGltZXN0YW1wICs9IHRoaXMudHJhY2suc3R0c1tzdHRzSW5kZXhdLmR1cmF0aW9uO1xcbiAgICAgICAgaWYgKHN0dHNJbmRleCArIDEgPCB0aGlzLnRyYWNrLnN0dHMubGVuZ3RoICYmICsrc3R0c1NhbXBsZSA9PT0gdGhpcy50cmFjay5zdHRzW3N0dHNJbmRleF0uY291bnQpIHtcXG4gICAgICAgICAgc3R0c1NhbXBsZSA9IDA7XFxuICAgICAgICAgIHN0dHNJbmRleCsrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoc3RzY0luZGV4ICsgMSA8IHRoaXMudHJhY2suc3RzYy5sZW5ndGggJiYgaSArIDEgPT09IHRoaXMudHJhY2suc3RzY1tzdHNjSW5kZXggKyAxXS5maXJzdCkge1xcbiAgICAgICAgX3Jlc3VsdHMucHVzaChzdHNjSW5kZXgrKyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIF9yZXN1bHRzO1xcbiAgfTtcXG5cXG4gIGFmdGVyKCdtb292JywgZnVuY3Rpb24oKSB7XFxuICAgIHZhciB0cmFjaywgX2ksIF9sZW4sIF9yZWYxO1xcblxcbiAgICBpZiAodGhpcy5tZGF0T2Zmc2V0ICE9IG51bGwpIHtcXG4gICAgICB0aGlzLnN0cmVhbS5zZWVrKHRoaXMubWRhdE9mZnNldCAtIDgpO1xcbiAgICB9XFxuICAgIF9yZWYxID0gdGhpcy50cmFja3M7XFxuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcXG4gICAgICB0cmFjayA9IF9yZWYxW19pXTtcXG4gICAgICBpZiAoISh0cmFjay50eXBlID09PSAnc291bicpKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgIGlmICh0aGlzLnRyYWNrLnR5cGUgIT09ICdzb3VuJykge1xcbiAgICAgIHRoaXMudHJhY2sgPSBudWxsO1xcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgJ05vIGF1ZGlvIHRyYWNrcyBpbiBtNGEgZmlsZS4nKTtcXG4gICAgfVxcbiAgICB0aGlzLmVtaXQoJ2Zvcm1hdCcsIHRoaXMudHJhY2suZm9ybWF0KTtcXG4gICAgdGhpcy5lbWl0KCdkdXJhdGlvbicsIHRoaXMudHJhY2suZHVyYXRpb24gLyB0aGlzLnRyYWNrLnRpbWVTY2FsZSAqIDEwMDAgfCAwKTtcXG4gICAgaWYgKHRoaXMudHJhY2suY29va2llKSB7XFxuICAgICAgdGhpcy5lbWl0KCdjb29raWUnLCB0aGlzLnRyYWNrLmNvb2tpZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXMuc2Vla1BvaW50cyA9IHRoaXMudHJhY2suc2Vla1BvaW50cztcXG4gIH0pO1xcblxcbiAgYXRvbSgnbWRhdCcsIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgYnl0ZXMsIGNodW5rU2l6ZSwgbGVuZ3RoLCBudW1TYW1wbGVzLCBvZmZzZXQsIHNhbXBsZSwgc2l6ZSwgX2ksIF9yZWYxO1xcblxcbiAgICBpZiAoIXRoaXMuc3RhcnRlZERhdGEpIHtcXG4gICAgICBpZiAoKF9yZWYxID0gdGhpcy5tZGF0T2Zmc2V0KSA9PSBudWxsKSB7XFxuICAgICAgICB0aGlzLm1kYXRPZmZzZXQgPSB0aGlzLnN0cmVhbS5vZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIGlmICh0aGlzLnRyYWNrcy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIGJ5dGVzID0gTWF0aC5taW4odGhpcy5zdHJlYW0ucmVtYWluaW5nQnl0ZXMoKSwgdGhpcy5sZW4pO1xcbiAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZShieXRlcyk7XFxuICAgICAgICB0aGlzLmxlbiAtPSBieXRlcztcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgdGhpcy5jaHVua0luZGV4ID0gMDtcXG4gICAgICB0aGlzLnN0c2NJbmRleCA9IDA7XFxuICAgICAgdGhpcy5zYW1wbGVJbmRleCA9IDA7XFxuICAgICAgdGhpcy50YWlsT2Zmc2V0ID0gMDtcXG4gICAgICB0aGlzLnRhaWxTYW1wbGVzID0gMDtcXG4gICAgICB0aGlzLnN0YXJ0ZWREYXRhID0gdHJ1ZTtcXG4gICAgfVxcbiAgICBpZiAoIXRoaXMucmVhZENoYXB0ZXJzKSB7XFxuICAgICAgdGhpcy5yZWFkQ2hhcHRlcnMgPSB0aGlzLnBhcnNlQ2hhcHRlcnMoKTtcXG4gICAgICBpZiAodGhpc1tcXFwiYnJlYWtcXFwiXSA9ICF0aGlzLnJlYWRDaGFwdGVycykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLnN0cmVhbS5zZWVrKHRoaXMubWRhdE9mZnNldCk7XFxuICAgIH1cXG4gICAgb2Zmc2V0ID0gdGhpcy50cmFjay5jaHVua09mZnNldHNbdGhpcy5jaHVua0luZGV4XSArIHRoaXMudGFpbE9mZnNldDtcXG4gICAgbGVuZ3RoID0gMDtcXG4gICAgaWYgKCF0aGlzLnN0cmVhbS5hdmFpbGFibGUob2Zmc2V0IC0gdGhpcy5zdHJlYW0ub2Zmc2V0KSkge1xcbiAgICAgIHRoaXNbXFxcImJyZWFrXFxcIl0gPSB0cnVlO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB0aGlzLnN0cmVhbS5zZWVrKG9mZnNldCk7XFxuICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLnRyYWNrLmNodW5rT2Zmc2V0cy5sZW5ndGgpIHtcXG4gICAgICBudW1TYW1wbGVzID0gdGhpcy50cmFjay5zdHNjW3RoaXMuc3RzY0luZGV4XS5jb3VudCAtIHRoaXMudGFpbFNhbXBsZXM7XFxuICAgICAgY2h1bmtTaXplID0gMDtcXG4gICAgICBmb3IgKHNhbXBsZSA9IF9pID0gMDsgX2kgPCBudW1TYW1wbGVzOyBzYW1wbGUgPSBfaSArPSAxKSB7XFxuICAgICAgICBzaXplID0gdGhpcy50cmFjay5zYW1wbGVTaXplIHx8IHRoaXMudHJhY2suc2FtcGxlU2l6ZXNbdGhpcy5zYW1wbGVJbmRleF07XFxuICAgICAgICBpZiAoIXRoaXMuc3RyZWFtLmF2YWlsYWJsZShsZW5ndGggKyBzaXplKSkge1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIGxlbmd0aCArPSBzaXplO1xcbiAgICAgICAgY2h1bmtTaXplICs9IHNpemU7XFxuICAgICAgICB0aGlzLnNhbXBsZUluZGV4Kys7XFxuICAgICAgfVxcbiAgICAgIGlmIChzYW1wbGUgPCBudW1TYW1wbGVzKSB7XFxuICAgICAgICB0aGlzLnRhaWxPZmZzZXQgKz0gY2h1bmtTaXplO1xcbiAgICAgICAgdGhpcy50YWlsU2FtcGxlcyArPSBzYW1wbGU7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XFxuICAgICAgICB0aGlzLnRhaWxPZmZzZXQgPSAwO1xcbiAgICAgICAgdGhpcy50YWlsU2FtcGxlcyA9IDA7XFxuICAgICAgICBpZiAodGhpcy5zdHNjSW5kZXggKyAxIDwgdGhpcy50cmFjay5zdHNjLmxlbmd0aCAmJiB0aGlzLmNodW5rSW5kZXggKyAxID09PSB0aGlzLnRyYWNrLnN0c2NbdGhpcy5zdHNjSW5kZXggKyAxXS5maXJzdCkge1xcbiAgICAgICAgICB0aGlzLnN0c2NJbmRleCsrO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG9mZnNldCArIGxlbmd0aCAhPT0gdGhpcy50cmFjay5jaHVua09mZnNldHNbdGhpcy5jaHVua0luZGV4XSkge1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcXG4gICAgICB0aGlzLmVtaXQoJ2RhdGEnLCB0aGlzLnN0cmVhbS5yZWFkQnVmZmVyKGxlbmd0aCkpO1xcbiAgICAgIHJldHVybiB0aGlzW1xcXCJicmVha1xcXCJdID0gdGhpcy5jaHVua0luZGV4ID09PSB0aGlzLnRyYWNrLmNodW5rT2Zmc2V0cy5sZW5ndGg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIHRoaXNbXFxcImJyZWFrXFxcIl0gPSB0cnVlO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIE00QURlbXV4ZXIucHJvdG90eXBlLnBhcnNlQ2hhcHRlcnMgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGJvbSwgaWQsIGxlbiwgbmV4dFRpbWVzdGFtcCwgcG9pbnQsIHRpdGxlLCB0cmFjaywgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNTtcXG5cXG4gICAgaWYgKCEoKChfcmVmMSA9IHRoaXMudHJhY2suY2hhcHRlclRyYWNrcykgIT0gbnVsbCA/IF9yZWYxLmxlbmd0aCA6IHZvaWQgMCkgPiAwKSkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICAgIGlkID0gdGhpcy50cmFjay5jaGFwdGVyVHJhY2tzWzBdO1xcbiAgICBfcmVmMiA9IHRoaXMudHJhY2tzO1xcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XFxuICAgICAgdHJhY2sgPSBfcmVmMltfaV07XFxuICAgICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICh0cmFjay5pZCAhPT0gaWQpIHtcXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgJ0NoYXB0ZXIgdHJhY2sgZG9lcyBub3QgZXhpc3QuJyk7XFxuICAgIH1cXG4gICAgaWYgKChfcmVmMyA9IHRoaXMuY2hhcHRlcnMpID09IG51bGwpIHtcXG4gICAgICB0aGlzLmNoYXB0ZXJzID0gW107XFxuICAgIH1cXG4gICAgd2hpbGUgKHRoaXMuY2hhcHRlcnMubGVuZ3RoIDwgdHJhY2suc2Vla1BvaW50cy5sZW5ndGgpIHtcXG4gICAgICBwb2ludCA9IHRyYWNrLnNlZWtQb2ludHNbdGhpcy5jaGFwdGVycy5sZW5ndGhdO1xcbiAgICAgIGlmICghdGhpcy5zdHJlYW0uYXZhaWxhYmxlKHBvaW50LnBvc2l0aW9uIC0gdGhpcy5zdHJlYW0ub2Zmc2V0ICsgMzIpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuc3RyZWFtLnNlZWsocG9pbnQucG9zaXRpb24pO1xcbiAgICAgIGxlbiA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MTYoKTtcXG4gICAgICB0aXRsZSA9IG51bGw7XFxuICAgICAgaWYgKCF0aGlzLnN0cmVhbS5hdmFpbGFibGUobGVuKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICBpZiAobGVuID4gMikge1xcbiAgICAgICAgYm9tID0gdGhpcy5zdHJlYW0ucGVla1VJbnQxNigpO1xcbiAgICAgICAgaWYgKGJvbSA9PT0gMHhmZWZmIHx8IGJvbSA9PT0gMHhmZmZlKSB7XFxuICAgICAgICAgIHRpdGxlID0gdGhpcy5zdHJlYW0ucmVhZFN0cmluZyhsZW4sICd1dGYxNi1ib20nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHRpdGxlID09IG51bGwpIHtcXG4gICAgICAgIHRpdGxlID0gdGhpcy5zdHJlYW0ucmVhZFN0cmluZyhsZW4sICd1dGY4Jyk7XFxuICAgICAgfVxcbiAgICAgIG5leHRUaW1lc3RhbXAgPSAoX3JlZjQgPSAoX3JlZjUgPSB0cmFjay5zZWVrUG9pbnRzW3RoaXMuY2hhcHRlcnMubGVuZ3RoICsgMV0pICE9IG51bGwgPyBfcmVmNS50aW1lc3RhbXAgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmNCA6IHRyYWNrLmR1cmF0aW9uO1xcbiAgICAgIHRoaXMuY2hhcHRlcnMucHVzaCh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICB0aW1lc3RhbXA6IHBvaW50LnRpbWVzdGFtcCAvIHRyYWNrLnRpbWVTY2FsZSAqIDEwMDAgfCAwLFxcbiAgICAgICAgZHVyYXRpb246IChuZXh0VGltZXN0YW1wIC0gcG9pbnQudGltZXN0YW1wKSAvIHRyYWNrLnRpbWVTY2FsZSAqIDEwMDAgfCAwXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgdGhpcy5lbWl0KCdjaGFwdGVycycsIHRoaXMuY2hhcHRlcnMpO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH07XFxuXFxuICBhdG9tKCdtb292LnVkdGEubWV0YScsIGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLm1ldGFkYXRhID0ge307XFxuICAgIHJldHVybiB0aGlzLnN0cmVhbS5hZHZhbmNlKDQpO1xcbiAgfSk7XFxuXFxuICBhZnRlcignbW9vdi51ZHRhLm1ldGEnLCBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnbWV0YWRhdGEnLCB0aGlzLm1ldGFkYXRhKTtcXG4gIH0pO1xcblxcbiAgbWV0YSA9IGZ1bmN0aW9uKGZpZWxkLCBuYW1lLCBmbikge1xcbiAgICByZXR1cm4gYXRvbShcXFwibW9vdi51ZHRhLm1ldGEuaWxzdC5cXFwiICsgZmllbGQgKyBcXFwiLmRhdGFcXFwiLCBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKDgpO1xcbiAgICAgIHRoaXMubGVuIC09IDg7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgbmFtZSk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIHN0cmluZyA9IGZ1bmN0aW9uKGZpZWxkKSB7XFxuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhW2ZpZWxkXSA9IHRoaXMuc3RyZWFtLnJlYWRTdHJpbmcodGhpcy5sZW4sICd1dGY4Jyk7XFxuICB9O1xcblxcbiAgbWV0YSgnwqlhbGInLCAnYWxidW0nLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlhcmcnLCAnYXJyYW5nZXInLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlhcnQnLCAnYXJ0aXN0Jywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ8KpQVJUJywgJ2FydGlzdCcsIHN0cmluZyk7XFxuXFxuICBtZXRhKCdhQVJUJywgJ2FsYnVtQXJ0aXN0Jywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ2NhdGcnLCAnY2F0ZWdvcnknLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqljb20nLCAnY29tcG9zZXInLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqljcHknLCAnY29weXJpZ2h0Jywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ2NwcnQnLCAnY29weXJpZ2h0Jywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ8KpY210JywgJ2NvbW1lbnRzJywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ8KpZGF5JywgJ3JlbGVhc2VEYXRlJywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ2Rlc2MnLCAnZGVzY3JpcHRpb24nLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlnZW4nLCAnZ2VucmUnLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlncnAnLCAnZ3JvdXBpbmcnLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlpc3InLCAnSVNSQycsIHN0cmluZyk7XFxuXFxuICBtZXRhKCdrZXl3JywgJ2tleXdvcmRzJywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ8KpbGFiJywgJ3JlY29yZExhYmVsJywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ2xkZXMnLCAnbG9uZ0Rlc2NyaXB0aW9uJywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ8KpbHlyJywgJ2x5cmljcycsIHN0cmluZyk7XFxuXFxuICBtZXRhKCfCqW5hbScsICd0aXRsZScsIHN0cmluZyk7XFxuXFxuICBtZXRhKCfCqXBoZycsICdyZWNvcmRpbmdDb3B5cmlnaHQnLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlwcmQnLCAncHJvZHVjZXInLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlwcmYnLCAncGVyZm9ybWVycycsIHN0cmluZyk7XFxuXFxuICBtZXRhKCdwdXJkJywgJ3B1cmNoYXNlRGF0ZScsIHN0cmluZyk7XFxuXFxuICBtZXRhKCdwdXJsJywgJ3BvZGNhc3RVUkwnLCBzdHJpbmcpO1xcblxcbiAgbWV0YSgnwqlzd2YnLCAnc29uZ3dyaXRlcicsIHN0cmluZyk7XFxuXFxuICBtZXRhKCfCqXRvbycsICdlbmNvZGVyJywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ8Kpd3J0JywgJ2NvbXBvc2VyJywgc3RyaW5nKTtcXG5cXG4gIG1ldGEoJ2NvdnInLCAnY292ZXJBcnQnLCBmdW5jdGlvbihmaWVsZCkge1xcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YVtmaWVsZF0gPSB0aGlzLnN0cmVhbS5yZWFkQnVmZmVyKHRoaXMubGVuKTtcXG4gIH0pO1xcblxcbiAgZ2VucmVzID0gW1xcXCJCbHVlc1xcXCIsIFxcXCJDbGFzc2ljIFJvY2tcXFwiLCBcXFwiQ291bnRyeVxcXCIsIFxcXCJEYW5jZVxcXCIsIFxcXCJEaXNjb1xcXCIsIFxcXCJGdW5rXFxcIiwgXFxcIkdydW5nZVxcXCIsIFxcXCJIaXAtSG9wXFxcIiwgXFxcIkphenpcXFwiLCBcXFwiTWV0YWxcXFwiLCBcXFwiTmV3IEFnZVxcXCIsIFxcXCJPbGRpZXNcXFwiLCBcXFwiT3RoZXJcXFwiLCBcXFwiUG9wXFxcIiwgXFxcIlImQlxcXCIsIFxcXCJSYXBcXFwiLCBcXFwiUmVnZ2FlXFxcIiwgXFxcIlJvY2tcXFwiLCBcXFwiVGVjaG5vXFxcIiwgXFxcIkluZHVzdHJpYWxcXFwiLCBcXFwiQWx0ZXJuYXRpdmVcXFwiLCBcXFwiU2thXFxcIiwgXFxcIkRlYXRoIE1ldGFsXFxcIiwgXFxcIlByYW5rc1xcXCIsIFxcXCJTb3VuZHRyYWNrXFxcIiwgXFxcIkV1cm8tVGVjaG5vXFxcIiwgXFxcIkFtYmllbnRcXFwiLCBcXFwiVHJpcC1Ib3BcXFwiLCBcXFwiVm9jYWxcXFwiLCBcXFwiSmF6eitGdW5rXFxcIiwgXFxcIkZ1c2lvblxcXCIsIFxcXCJUcmFuY2VcXFwiLCBcXFwiQ2xhc3NpY2FsXFxcIiwgXFxcIkluc3RydW1lbnRhbFxcXCIsIFxcXCJBY2lkXFxcIiwgXFxcIkhvdXNlXFxcIiwgXFxcIkdhbWVcXFwiLCBcXFwiU291bmQgQ2xpcFxcXCIsIFxcXCJHb3NwZWxcXFwiLCBcXFwiTm9pc2VcXFwiLCBcXFwiQWx0ZXJuUm9ja1xcXCIsIFxcXCJCYXNzXFxcIiwgXFxcIlNvdWxcXFwiLCBcXFwiUHVua1xcXCIsIFxcXCJTcGFjZVxcXCIsIFxcXCJNZWRpdGF0aXZlXFxcIiwgXFxcIkluc3RydW1lbnRhbCBQb3BcXFwiLCBcXFwiSW5zdHJ1bWVudGFsIFJvY2tcXFwiLCBcXFwiRXRobmljXFxcIiwgXFxcIkdvdGhpY1xcXCIsIFxcXCJEYXJrd2F2ZVxcXCIsIFxcXCJUZWNobm8tSW5kdXN0cmlhbFxcXCIsIFxcXCJFbGVjdHJvbmljXFxcIiwgXFxcIlBvcC1Gb2xrXFxcIiwgXFxcIkV1cm9kYW5jZVxcXCIsIFxcXCJEcmVhbVxcXCIsIFxcXCJTb3V0aGVybiBSb2NrXFxcIiwgXFxcIkNvbWVkeVxcXCIsIFxcXCJDdWx0XFxcIiwgXFxcIkdhbmdzdGFcXFwiLCBcXFwiVG9wIDQwXFxcIiwgXFxcIkNocmlzdGlhbiBSYXBcXFwiLCBcXFwiUG9wL0Z1bmtcXFwiLCBcXFwiSnVuZ2xlXFxcIiwgXFxcIk5hdGl2ZSBBbWVyaWNhblxcXCIsIFxcXCJDYWJhcmV0XFxcIiwgXFxcIk5ldyBXYXZlXFxcIiwgXFxcIlBzeWNoYWRlbGljXFxcIiwgXFxcIlJhdmVcXFwiLCBcXFwiU2hvd3R1bmVzXFxcIiwgXFxcIlRyYWlsZXJcXFwiLCBcXFwiTG8tRmlcXFwiLCBcXFwiVHJpYmFsXFxcIiwgXFxcIkFjaWQgUHVua1xcXCIsIFxcXCJBY2lkIEphenpcXFwiLCBcXFwiUG9sa2FcXFwiLCBcXFwiUmV0cm9cXFwiLCBcXFwiTXVzaWNhbFxcXCIsIFxcXCJSb2NrICYgUm9sbFxcXCIsIFxcXCJIYXJkIFJvY2tcXFwiLCBcXFwiRm9sa1xcXCIsIFxcXCJGb2xrL1JvY2tcXFwiLCBcXFwiTmF0aW9uYWwgRm9sa1xcXCIsIFxcXCJTd2luZ1xcXCIsIFxcXCJGYXN0IEZ1c2lvblxcXCIsIFxcXCJCZWJvYlxcXCIsIFxcXCJMYXRpblxcXCIsIFxcXCJSZXZpdmFsXFxcIiwgXFxcIkNlbHRpY1xcXCIsIFxcXCJCbHVlZ3Jhc3NcXFwiLCBcXFwiQXZhbnRnYXJkZVxcXCIsIFxcXCJHb3RoaWMgUm9ja1xcXCIsIFxcXCJQcm9ncmVzc2l2ZSBSb2NrXFxcIiwgXFxcIlBzeWNoZWRlbGljIFJvY2tcXFwiLCBcXFwiU3ltcGhvbmljIFJvY2tcXFwiLCBcXFwiU2xvdyBSb2NrXFxcIiwgXFxcIkJpZyBCYW5kXFxcIiwgXFxcIkNob3J1c1xcXCIsIFxcXCJFYXN5IExpc3RlbmluZ1xcXCIsIFxcXCJBY291c3RpY1xcXCIsIFxcXCJIdW1vdXJcXFwiLCBcXFwiU3BlZWNoXFxcIiwgXFxcIkNoYW5zb25cXFwiLCBcXFwiT3BlcmFcXFwiLCBcXFwiQ2hhbWJlciBNdXNpY1xcXCIsIFxcXCJTb25hdGFcXFwiLCBcXFwiU3ltcGhvbnlcXFwiLCBcXFwiQm9vdHkgQmFzc1xcXCIsIFxcXCJQcmltdXNcXFwiLCBcXFwiUG9ybiBHcm9vdmVcXFwiLCBcXFwiU2F0aXJlXFxcIiwgXFxcIlNsb3cgSmFtXFxcIiwgXFxcIkNsdWJcXFwiLCBcXFwiVGFuZ29cXFwiLCBcXFwiU2FtYmFcXFwiLCBcXFwiRm9sa2xvcmVcXFwiLCBcXFwiQmFsbGFkXFxcIiwgXFxcIlBvd2VyIEJhbGxhZFxcXCIsIFxcXCJSaHl0aG1pYyBTb3VsXFxcIiwgXFxcIkZyZWVzdHlsZVxcXCIsIFxcXCJEdWV0XFxcIiwgXFxcIlB1bmsgUm9ja1xcXCIsIFxcXCJEcnVtIFNvbG9cXFwiLCBcXFwiQSBDYXBlbGxhXFxcIiwgXFxcIkV1cm8tSG91c2VcXFwiLCBcXFwiRGFuY2UgSGFsbFxcXCJdO1xcblxcbiAgbWV0YSgnZ25yZScsICdnZW5yZScsIGZ1bmN0aW9uKGZpZWxkKSB7XFxuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhW2ZpZWxkXSA9IGdlbnJlc1t0aGlzLnN0cmVhbS5yZWFkVUludDE2KCkgLSAxXTtcXG4gIH0pO1xcblxcbiAgbWV0YSgndG1wbycsICd0ZW1wbycsIGZ1bmN0aW9uKGZpZWxkKSB7XFxuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhW2ZpZWxkXSA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MTYoKTtcXG4gIH0pO1xcblxcbiAgbWV0YSgncnRuZycsICdyYXRpbmcnLCBmdW5jdGlvbihmaWVsZCkge1xcbiAgICB2YXIgcmF0aW5nO1xcblxcbiAgICByYXRpbmcgPSB0aGlzLnN0cmVhbS5yZWFkVUludDgoKTtcXG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFbZmllbGRdID0gcmF0aW5nID09PSAyID8gJ0NsZWFuJyA6IHJhdGluZyAhPT0gMCA/ICdFeHBsaWNpdCcgOiAnTm9uZSc7XFxuICB9KTtcXG5cXG4gIGRpc2tUcmFjayA9IGZ1bmN0aW9uKGZpZWxkKSB7XFxuICAgIHRoaXMuc3RyZWFtLmFkdmFuY2UoMik7XFxuICAgIHRoaXMubWV0YWRhdGFbZmllbGRdID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQxNigpICsgJyBvZiAnICsgdGhpcy5zdHJlYW0ucmVhZFVJbnQxNigpO1xcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uYWR2YW5jZSh0aGlzLmxlbiAtIDYpO1xcbiAgfTtcXG5cXG4gIG1ldGEoJ2Rpc2snLCAnZGlza051bWJlcicsIGRpc2tUcmFjayk7XFxuXFxuICBtZXRhKCd0cmtuJywgJ3RyYWNrTnVtYmVyJywgZGlza1RyYWNrKTtcXG5cXG4gIGJvb2wgPSBmdW5jdGlvbihmaWVsZCkge1xcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YVtmaWVsZF0gPSB0aGlzLnN0cmVhbS5yZWFkVUludDgoKSA9PT0gMTtcXG4gIH07XFxuXFxuICBtZXRhKCdjcGlsJywgJ2NvbXBpbGF0aW9uJywgYm9vbCk7XFxuXFxuICBtZXRhKCdwY3N0JywgJ3BvZGNhc3QnLCBib29sKTtcXG5cXG4gIG1ldGEoJ3BnYXAnLCAnZ2FwbGVzcycsIGJvb2wpO1xcblxcbiAgcmV0dXJuIE00QURlbXV4ZXI7XFxuXFxufSkoQVYuRGVtdXhlcik7XFxuLy9pbXBvcnQgXFxcImRlbXV4ZXJzL200YS5jb2ZmZWVcXFwiO1xcblxcbnZhciBBSUZGRGVtdXhlciwgX3JlZixcXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XFxuXFxuQUlGRkRlbXV4ZXIgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XFxuICBfX2V4dGVuZHMoQUlGRkRlbXV4ZXIsIF9zdXBlcik7XFxuXFxuICBmdW5jdGlvbiBBSUZGRGVtdXhlcigpIHtcXG4gICAgX3JlZiA9IEFJRkZEZW11eGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICByZXR1cm4gX3JlZjtcXG4gIH1cXG5cXG4gIEFWLkRlbXV4ZXIucmVnaXN0ZXIoQUlGRkRlbXV4ZXIpO1xcblxcbiAgQUlGRkRlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbihidWZmZXIpIHtcXG4gICAgdmFyIF9yZWYxO1xcblxcbiAgICByZXR1cm4gYnVmZmVyLnBlZWtTdHJpbmcoMCwgNCkgPT09ICdGT1JNJyAmJiAoKF9yZWYxID0gYnVmZmVyLnBlZWtTdHJpbmcoOCwgNCkpID09PSAnQUlGRicgfHwgX3JlZjEgPT09ICdBSUZDJyk7XFxuICB9O1xcblxcbiAgQUlGRkRlbXV4ZXIucHJvdG90eXBlLnJlYWRDaHVuayA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgYnVmZmVyLCBmb3JtYXQsIG9mZnNldCwgX3JlZjE7XFxuXFxuICAgIGlmICghdGhpcy5yZWFkU3RhcnQgJiYgdGhpcy5zdHJlYW0uYXZhaWxhYmxlKDEyKSkge1xcbiAgICAgIGlmICh0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpICE9PSAnRk9STScpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgJ0ludmFsaWQgQUlGRi4nKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5maWxlU2l6ZSA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIoKTtcXG4gICAgICB0aGlzLmZpbGVUeXBlID0gdGhpcy5zdHJlYW0ucmVhZFN0cmluZyg0KTtcXG4gICAgICB0aGlzLnJlYWRTdGFydCA9IHRydWU7XFxuICAgICAgaWYgKChfcmVmMSA9IHRoaXMuZmlsZVR5cGUpICE9PSAnQUlGRicgJiYgX3JlZjEgIT09ICdBSUZDJykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCAnSW52YWxpZCBBSUZGLicpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB3aGlsZSAodGhpcy5zdHJlYW0uYXZhaWxhYmxlKDEpKSB7XFxuICAgICAgaWYgKCF0aGlzLnJlYWRIZWFkZXJzICYmIHRoaXMuc3RyZWFtLmF2YWlsYWJsZSg4KSkge1xcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy5zdHJlYW0ucmVhZFN0cmluZyg0KTtcXG4gICAgICAgIHRoaXMubGVuID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICAgIH1cXG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xcbiAgICAgICAgY2FzZSAnQ09NTSc6XFxuICAgICAgICAgIGlmICghdGhpcy5zdHJlYW0uYXZhaWxhYmxlKHRoaXMubGVuKSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0aGlzLmZvcm1hdCA9IHtcXG4gICAgICAgICAgICBmb3JtYXRJRDogJ2xwY20nLFxcbiAgICAgICAgICAgIGNoYW5uZWxzUGVyRnJhbWU6IHRoaXMuc3RyZWFtLnJlYWRVSW50MTYoKSxcXG4gICAgICAgICAgICBzYW1wbGVDb3VudDogdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpLFxcbiAgICAgICAgICAgIGJpdHNQZXJDaGFubmVsOiB0aGlzLnN0cmVhbS5yZWFkVUludDE2KCksXFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zdHJlYW0ucmVhZEZsb2F0ODAoKSxcXG4gICAgICAgICAgICBmcmFtZXNQZXJQYWNrZXQ6IDEsXFxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuOiBmYWxzZSxcXG4gICAgICAgICAgICBmbG9hdGluZ1BvaW50OiBmYWxzZVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICB0aGlzLmZvcm1hdC5ieXRlc1BlclBhY2tldCA9ICh0aGlzLmZvcm1hdC5iaXRzUGVyQ2hhbm5lbCAvIDgpICogdGhpcy5mb3JtYXQuY2hhbm5lbHNQZXJGcmFtZTtcXG4gICAgICAgICAgaWYgKHRoaXMuZmlsZVR5cGUgPT09ICdBSUZDJykge1xcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuc3RyZWFtLnJlYWRTdHJpbmcoNCk7XFxuICAgICAgICAgICAgdGhpcy5mb3JtYXQubGl0dGxlRW5kaWFuID0gZm9ybWF0ID09PSAnc293dCcgJiYgdGhpcy5mb3JtYXQuYml0c1BlckNoYW5uZWwgPiA4O1xcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0LmZsb2F0aW5nUG9pbnQgPSBmb3JtYXQgPT09ICdmbDMyJyB8fCBmb3JtYXQgPT09ICdmbDY0JztcXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAndHdvcycgfHwgZm9ybWF0ID09PSAnc293dCcgfHwgZm9ybWF0ID09PSAnZmwzMicgfHwgZm9ybWF0ID09PSAnZmw2NCcgfHwgZm9ybWF0ID09PSAnTk9ORScpIHtcXG4gICAgICAgICAgICAgIGZvcm1hdCA9ICdscGNtJztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5mb3JtYXQuZm9ybWF0SUQgPSBmb3JtYXQ7XFxuICAgICAgICAgICAgdGhpcy5sZW4gLT0gNDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKHRoaXMubGVuIC0gMTgpO1xcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Zvcm1hdCcsIHRoaXMuZm9ybWF0KTtcXG4gICAgICAgICAgdGhpcy5lbWl0KCdkdXJhdGlvbicsIHRoaXMuZm9ybWF0LnNhbXBsZUNvdW50IC8gdGhpcy5mb3JtYXQuc2FtcGxlUmF0ZSAqIDEwMDAgfCAwKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICdTU05EJzpcXG4gICAgICAgICAgaWYgKCEodGhpcy5yZWFkU1NOREhlYWRlciAmJiB0aGlzLnN0cmVhbS5hdmFpbGFibGUoNCkpKSB7XFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpO1xcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmFkdmFuY2UoNCk7XFxuICAgICAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZShvZmZzZXQpO1xcbiAgICAgICAgICAgIHRoaXMucmVhZFNTTkRIZWFkZXIgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuc3RyZWFtLnJlYWRTaW5nbGVCdWZmZXIodGhpcy5sZW4pO1xcbiAgICAgICAgICB0aGlzLmxlbiAtPSBidWZmZXIubGVuZ3RoO1xcbiAgICAgICAgICB0aGlzLnJlYWRIZWFkZXJzID0gdGhpcy5sZW4gPiAwO1xcbiAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBidWZmZXIpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIGlmICghdGhpcy5zdHJlYW0uYXZhaWxhYmxlKHRoaXMubGVuKSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0aGlzLnN0cmVhbS5hZHZhbmNlKHRoaXMubGVuKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ1NTTkQnKSB7XFxuICAgICAgICB0aGlzLnJlYWRIZWFkZXJzID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIEFJRkZEZW11eGVyO1xcblxcbn0pKEFWLkRlbXV4ZXIpO1xcbi8vaW1wb3J0IFxcXCJkZW11eGVycy9haWZmLmNvZmZlZVxcXCI7XFxuXFxudmFyIFdBVkVEZW11eGVyLCBfcmVmLFxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5XQVZFRGVtdXhlciA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIHZhciBmb3JtYXRzO1xcblxcbiAgX19leHRlbmRzKFdBVkVEZW11eGVyLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gV0FWRURlbXV4ZXIoKSB7XFxuICAgIF9yZWYgPSBXQVZFRGVtdXhlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgcmV0dXJuIF9yZWY7XFxuICB9XFxuXFxuICBBVi5EZW11eGVyLnJlZ2lzdGVyKFdBVkVEZW11eGVyKTtcXG5cXG4gIFdBVkVEZW11eGVyLnByb2JlID0gZnVuY3Rpb24oYnVmZmVyKSB7XFxuICAgIHJldHVybiBidWZmZXIucGVla1N0cmluZygwLCA0KSA9PT0gJ1JJRkYnICYmIGJ1ZmZlci5wZWVrU3RyaW5nKDgsIDQpID09PSAnV0FWRSc7XFxuICB9O1xcblxcbiAgZm9ybWF0cyA9IHtcXG4gICAgMHgwMDAxOiAnbHBjbScsXFxuICAgIDB4MDAwMzogJ2xwY20nLFxcbiAgICAweDAwMDY6ICdhbGF3JyxcXG4gICAgMHgwMDA3OiAndWxhdydcXG4gIH07XFxuXFxuICBXQVZFRGVtdXhlci5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBidWZmZXIsIGJ5dGVzLCBlbmNvZGluZztcXG5cXG4gICAgaWYgKCF0aGlzLnJlYWRTdGFydCAmJiB0aGlzLnN0cmVhbS5hdmFpbGFibGUoMTIpKSB7XFxuICAgICAgaWYgKHRoaXMuc3RyZWFtLnJlYWRTdHJpbmcoNCkgIT09ICdSSUZGJykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCAnSW52YWxpZCBXQVYgZmlsZS4nKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5maWxlU2l6ZSA9IHRoaXMuc3RyZWFtLnJlYWRVSW50MzIodHJ1ZSk7XFxuICAgICAgdGhpcy5yZWFkU3RhcnQgPSB0cnVlO1xcbiAgICAgIGlmICh0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpICE9PSAnV0FWRScpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgJ0ludmFsaWQgV0FWIGZpbGUuJyk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHdoaWxlICh0aGlzLnN0cmVhbS5hdmFpbGFibGUoMSkpIHtcXG4gICAgICBpZiAoIXRoaXMucmVhZEhlYWRlcnMgJiYgdGhpcy5zdHJlYW0uYXZhaWxhYmxlKDgpKSB7XFxuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLnN0cmVhbS5yZWFkU3RyaW5nKDQpO1xcbiAgICAgICAgdGhpcy5sZW4gPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKHRydWUpO1xcbiAgICAgIH1cXG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xcbiAgICAgICAgY2FzZSAnZm10ICc6XFxuICAgICAgICAgIGVuY29kaW5nID0gdGhpcy5zdHJlYW0ucmVhZFVJbnQxNih0cnVlKTtcXG4gICAgICAgICAgaWYgKCEoZW5jb2RpbmcgaW4gZm9ybWF0cykpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsICdVbnN1cHBvcnRlZCBmb3JtYXQgaW4gV0FWIGZpbGUuJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdGhpcy5mb3JtYXQgPSB7XFxuICAgICAgICAgICAgZm9ybWF0SUQ6IGZvcm1hdHNbZW5jb2RpbmddLFxcbiAgICAgICAgICAgIGZsb2F0aW5nUG9pbnQ6IGVuY29kaW5nID09PSAweDAwMDMsXFxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuOiBmb3JtYXRzW2VuY29kaW5nXSA9PT0gJ2xwY20nLFxcbiAgICAgICAgICAgIGNoYW5uZWxzUGVyRnJhbWU6IHRoaXMuc3RyZWFtLnJlYWRVSW50MTYodHJ1ZSksXFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zdHJlYW0ucmVhZFVJbnQzMih0cnVlKSxcXG4gICAgICAgICAgICBmcmFtZXNQZXJQYWNrZXQ6IDFcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZSg0KTtcXG4gICAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZSgyKTtcXG4gICAgICAgICAgdGhpcy5mb3JtYXQuYml0c1BlckNoYW5uZWwgPSB0aGlzLnN0cmVhbS5yZWFkVUludDE2KHRydWUpO1xcbiAgICAgICAgICB0aGlzLmZvcm1hdC5ieXRlc1BlclBhY2tldCA9ICh0aGlzLmZvcm1hdC5iaXRzUGVyQ2hhbm5lbCAvIDgpICogdGhpcy5mb3JtYXQuY2hhbm5lbHNQZXJGcmFtZTtcXG4gICAgICAgICAgdGhpcy5lbWl0KCdmb3JtYXQnLCB0aGlzLmZvcm1hdCk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAnZGF0YSc6XFxuICAgICAgICAgIGlmICghdGhpcy5zZW50RHVyYXRpb24pIHtcXG4gICAgICAgICAgICBieXRlcyA9IHRoaXMuZm9ybWF0LmJpdHNQZXJDaGFubmVsIC8gODtcXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2R1cmF0aW9uJywgdGhpcy5sZW4gLyBieXRlcyAvIHRoaXMuZm9ybWF0LmNoYW5uZWxzUGVyRnJhbWUgLyB0aGlzLmZvcm1hdC5zYW1wbGVSYXRlICogMTAwMCB8IDApO1xcbiAgICAgICAgICAgIHRoaXMuc2VudER1cmF0aW9uID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBidWZmZXIgPSB0aGlzLnN0cmVhbS5yZWFkU2luZ2xlQnVmZmVyKHRoaXMubGVuKTtcXG4gICAgICAgICAgdGhpcy5sZW4gLT0gYnVmZmVyLmxlbmd0aDtcXG4gICAgICAgICAgdGhpcy5yZWFkSGVhZGVycyA9IHRoaXMubGVuID4gMDtcXG4gICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgYnVmZmVyKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtLmF2YWlsYWJsZSh0aGlzLmxlbikpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdGhpcy5zdHJlYW0uYWR2YW5jZSh0aGlzLmxlbik7XFxuICAgICAgfVxcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdkYXRhJykge1xcbiAgICAgICAgdGhpcy5yZWFkSGVhZGVycyA9IGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBXQVZFRGVtdXhlcjtcXG5cXG59KShBVi5EZW11eGVyKTtcXG4vL2ltcG9ydCBcXFwiZGVtdXhlcnMvd2F2ZS5jb2ZmZWVcXFwiO1xcblxcbnZhciBBVURlbXV4ZXIsIF9yZWYsXFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcXG4gIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xcblxcbkFVRGVtdXhlciA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIHZhciBicHMsIGZvcm1hdHM7XFxuXFxuICBfX2V4dGVuZHMoQVVEZW11eGVyLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gQVVEZW11eGVyKCkge1xcbiAgICBfcmVmID0gQVVEZW11eGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICByZXR1cm4gX3JlZjtcXG4gIH1cXG5cXG4gIEFWLkRlbXV4ZXIucmVnaXN0ZXIoQVVEZW11eGVyKTtcXG5cXG4gIEFVRGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xcbiAgICByZXR1cm4gYnVmZmVyLnBlZWtTdHJpbmcoMCwgNCkgPT09ICcuc25kJztcXG4gIH07XFxuXFxuICBicHMgPSBbOCwgOCwgMTYsIDI0LCAzMiwgMzIsIDY0XTtcXG5cXG4gIGJwc1syNl0gPSA4O1xcblxcbiAgZm9ybWF0cyA9IHtcXG4gICAgMTogJ3VsYXcnLFxcbiAgICAyNzogJ2FsYXcnXFxuICB9O1xcblxcbiAgQVVEZW11eGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGJ5dGVzLCBkYXRhU2l6ZSwgZW5jb2RpbmcsIHNpemU7XFxuXFxuICAgIGlmICghdGhpcy5yZWFkSGVhZGVyICYmIHRoaXMuc3RyZWFtLmF2YWlsYWJsZSgyNCkpIHtcXG4gICAgICBpZiAodGhpcy5zdHJlYW0ucmVhZFN0cmluZyg0KSAhPT0gJy5zbmQnKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsICdJbnZhbGlkIEFVIGZpbGUuJyk7XFxuICAgICAgfVxcbiAgICAgIHNpemUgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgICAgZGF0YVNpemUgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgICAgZW5jb2RpbmcgPSB0aGlzLnN0cmVhbS5yZWFkVUludDMyKCk7XFxuICAgICAgdGhpcy5mb3JtYXQgPSB7XFxuICAgICAgICBmb3JtYXRJRDogZm9ybWF0c1tlbmNvZGluZ10gfHwgJ2xwY20nLFxcbiAgICAgICAgbGl0dGxlRW5kaWFuOiBmYWxzZSxcXG4gICAgICAgIGZsb2F0aW5nUG9pbnQ6IGVuY29kaW5nID09PSA2IHx8IGVuY29kaW5nID09PSA3LFxcbiAgICAgICAgYml0c1BlckNoYW5uZWw6IGJwc1tlbmNvZGluZyAtIDFdLFxcbiAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpLFxcbiAgICAgICAgY2hhbm5lbHNQZXJGcmFtZTogdGhpcy5zdHJlYW0ucmVhZFVJbnQzMigpLFxcbiAgICAgICAgZnJhbWVzUGVyUGFja2V0OiAxXFxuICAgICAgfTtcXG4gICAgICBpZiAodGhpcy5mb3JtYXQuYml0c1BlckNoYW5uZWwgPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCAnVW5zdXBwb3J0ZWQgZW5jb2RpbmcgaW4gQVUgZmlsZS4nKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5mb3JtYXQuYnl0ZXNQZXJQYWNrZXQgPSAodGhpcy5mb3JtYXQuYml0c1BlckNoYW5uZWwgLyA4KSAqIHRoaXMuZm9ybWF0LmNoYW5uZWxzUGVyRnJhbWU7XFxuICAgICAgaWYgKGRhdGFTaXplICE9PSAweGZmZmZmZmZmKSB7XFxuICAgICAgICBieXRlcyA9IHRoaXMuZm9ybWF0LmJpdHNQZXJDaGFubmVsIC8gODtcXG4gICAgICAgIHRoaXMuZW1pdCgnZHVyYXRpb24nLCBkYXRhU2l6ZSAvIGJ5dGVzIC8gdGhpcy5mb3JtYXQuY2hhbm5lbHNQZXJGcmFtZSAvIHRoaXMuZm9ybWF0LnNhbXBsZVJhdGUgKiAxMDAwIHwgMCk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuZW1pdCgnZm9ybWF0JywgdGhpcy5mb3JtYXQpO1xcbiAgICAgIHRoaXMucmVhZEhlYWRlciA9IHRydWU7XFxuICAgIH1cXG4gICAgaWYgKHRoaXMucmVhZEhlYWRlcikge1xcbiAgICAgIHdoaWxlICh0aGlzLnN0cmVhbS5hdmFpbGFibGUoMSkpIHtcXG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHRoaXMuc3RyZWFtLnJlYWRTaW5nbGVCdWZmZXIodGhpcy5zdHJlYW0ucmVtYWluaW5nQnl0ZXMoKSkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBBVURlbXV4ZXI7XFxuXFxufSkoQVYuRGVtdXhlcik7XFxuLy9pbXBvcnQgXFxcImRlbXV4ZXJzL2F1LmNvZmZlZVxcXCI7XFxuXFxudmFyIExQQ01EZWNvZGVyLCBfcmVmLFxcbiAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XFxuXFxuTFBDTURlY29kZXIgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XFxuICBfX2V4dGVuZHMoTFBDTURlY29kZXIsIF9zdXBlcik7XFxuXFxuICBmdW5jdGlvbiBMUENNRGVjb2RlcigpIHtcXG4gICAgdGhpcy5yZWFkQ2h1bmsgPSBfX2JpbmQodGhpcy5yZWFkQ2h1bmssIHRoaXMpOyAgICBfcmVmID0gTFBDTURlY29kZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIHJldHVybiBfcmVmO1xcbiAgfVxcblxcbiAgQVYuRGVjb2Rlci5yZWdpc3RlcignbHBjbScsIExQQ01EZWNvZGVyKTtcXG5cXG4gIExQQ01EZWNvZGVyLnByb3RvdHlwZS5yZWFkQ2h1bmsgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGNodW5rU2l6ZSwgaSwgbGl0dGxlRW5kaWFuLCBvdXRwdXQsIHNhbXBsZXMsIHN0cmVhbSwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbjtcXG5cXG4gICAgc3RyZWFtID0gdGhpcy5zdHJlYW07XFxuICAgIGxpdHRsZUVuZGlhbiA9IHRoaXMuZm9ybWF0LmxpdHRsZUVuZGlhbjtcXG4gICAgY2h1bmtTaXplID0gTWF0aC5taW4oNDA5Niwgc3RyZWFtLnJlbWFpbmluZ0J5dGVzKCkpO1xcbiAgICBzYW1wbGVzID0gY2h1bmtTaXplIC8gKHRoaXMuZm9ybWF0LmJpdHNQZXJDaGFubmVsIC8gOCkgfCAwO1xcbiAgICBpZiAoY2h1bmtTaXplIDwgdGhpcy5mb3JtYXQuYml0c1BlckNoYW5uZWwgLyA4KSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgaWYgKHRoaXMuZm9ybWF0LmZsb2F0aW5nUG9pbnQpIHtcXG4gICAgICBzd2l0Y2ggKHRoaXMuZm9ybWF0LmJpdHNQZXJDaGFubmVsKSB7XFxuICAgICAgICBjYXNlIDMyOlxcbiAgICAgICAgICBvdXRwdXQgPSBuZXcgRmxvYXQzMkFycmF5KHNhbXBsZXMpO1xcbiAgICAgICAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgc2FtcGxlczsgaSA9IF9pICs9IDEpIHtcXG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBzdHJlYW0ucmVhZEZsb2F0MzIobGl0dGxlRW5kaWFuKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgNjQ6XFxuICAgICAgICAgIG91dHB1dCA9IG5ldyBGbG9hdDY0QXJyYXkoc2FtcGxlcyk7XFxuICAgICAgICAgIGZvciAoaSA9IF9qID0gMDsgX2ogPCBzYW1wbGVzOyBpID0gX2ogKz0gMSkge1xcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IHN0cmVhbS5yZWFkRmxvYXQ2NChsaXR0bGVFbmRpYW4pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBiaXQgZGVwdGguJyk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN3aXRjaCAodGhpcy5mb3JtYXQuYml0c1BlckNoYW5uZWwpIHtcXG4gICAgICAgIGNhc2UgODpcXG4gICAgICAgICAgb3V0cHV0ID0gbmV3IEludDhBcnJheShzYW1wbGVzKTtcXG4gICAgICAgICAgZm9yIChpID0gX2sgPSAwOyBfayA8IHNhbXBsZXM7IGkgPSBfayArPSAxKSB7XFxuICAgICAgICAgICAgb3V0cHV0W2ldID0gc3RyZWFtLnJlYWRJbnQ4KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIDE2OlxcbiAgICAgICAgICBvdXRwdXQgPSBuZXcgSW50MTZBcnJheShzYW1wbGVzKTtcXG4gICAgICAgICAgZm9yIChpID0gX2wgPSAwOyBfbCA8IHNhbXBsZXM7IGkgPSBfbCArPSAxKSB7XFxuICAgICAgICAgICAgb3V0cHV0W2ldID0gc3RyZWFtLnJlYWRJbnQxNihsaXR0bGVFbmRpYW4pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAyNDpcXG4gICAgICAgICAgb3V0cHV0ID0gbmV3IEludDMyQXJyYXkoc2FtcGxlcyk7XFxuICAgICAgICAgIGZvciAoaSA9IF9tID0gMDsgX20gPCBzYW1wbGVzOyBpID0gX20gKz0gMSkge1xcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IHN0cmVhbS5yZWFkSW50MjQobGl0dGxlRW5kaWFuKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgMzI6XFxuICAgICAgICAgIG91dHB1dCA9IG5ldyBJbnQzMkFycmF5KHNhbXBsZXMpO1xcbiAgICAgICAgICBmb3IgKGkgPSBfbiA9IDA7IF9uIDwgc2FtcGxlczsgaSA9IF9uICs9IDEpIHtcXG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBzdHJlYW0ucmVhZEludDMyKGxpdHRsZUVuZGlhbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGJpdCBkZXB0aC4nKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG91dHB1dDtcXG4gIH07XFxuXFxuICByZXR1cm4gTFBDTURlY29kZXI7XFxuXFxufSkoQVYuRGVjb2Rlcik7XFxuLy9pbXBvcnQgXFxcImRlY29kZXJzL2xwY20uY29mZmVlXFxcIjtcXG5cXG52YXIgWExBV0RlY29kZXIsIF9yZWYsXFxuICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5YTEFXRGVjb2RlciA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIHZhciBCSUFTLCBRVUFOVF9NQVNLLCBTRUdfTUFTSywgU0VHX1NISUZULCBTSUdOX0JJVDtcXG5cXG4gIF9fZXh0ZW5kcyhYTEFXRGVjb2RlciwgX3N1cGVyKTtcXG5cXG4gIGZ1bmN0aW9uIFhMQVdEZWNvZGVyKCkge1xcbiAgICB0aGlzLnJlYWRDaHVuayA9IF9fYmluZCh0aGlzLnJlYWRDaHVuaywgdGhpcyk7ICAgIF9yZWYgPSBYTEFXRGVjb2Rlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgcmV0dXJuIF9yZWY7XFxuICB9XFxuXFxuICBBVi5EZWNvZGVyLnJlZ2lzdGVyKCd1bGF3JywgWExBV0RlY29kZXIpO1xcblxcbiAgQVYuRGVjb2Rlci5yZWdpc3RlcignYWxhdycsIFhMQVdEZWNvZGVyKTtcXG5cXG4gIFNJR05fQklUID0gMHg4MDtcXG5cXG4gIFFVQU5UX01BU0sgPSAweGY7XFxuXFxuICBTRUdfU0hJRlQgPSA0O1xcblxcbiAgU0VHX01BU0sgPSAweDcwO1xcblxcbiAgQklBUyA9IDB4ODQ7XFxuXFxuICBYTEFXRGVjb2Rlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgaSwgc2VnLCB0LCB0YWJsZSwgdmFsLCBfaSwgX2o7XFxuXFxuICAgIHRoaXMuZm9ybWF0LmJpdHNQZXJDaGFubmVsID0gMTY7XFxuICAgIHRoaXMudGFibGUgPSB0YWJsZSA9IG5ldyBJbnQxNkFycmF5KDI1Nik7XFxuICAgIGlmICh0aGlzLmZvcm1hdC5mb3JtYXRJRCA9PT0gJ3VsYXcnKSB7XFxuICAgICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcXG4gICAgICAgIHZhbCA9IH5pO1xcbiAgICAgICAgdCA9ICgodmFsICYgUVVBTlRfTUFTSykgPDwgMykgKyBCSUFTO1xcbiAgICAgICAgdCA8PD0gKHZhbCAmIFNFR19NQVNLKSA+Pj4gU0VHX1NISUZUO1xcbiAgICAgICAgdGFibGVbaV0gPSB2YWwgJiBTSUdOX0JJVCA/IEJJQVMgLSB0IDogdCAtIEJJQVM7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAoaSA9IF9qID0gMDsgX2ogPCAyNTY7IGkgPSArK19qKSB7XFxuICAgICAgICB2YWwgPSBpIF4gMHg1NTtcXG4gICAgICAgIHQgPSB2YWwgJiBRVUFOVF9NQVNLO1xcbiAgICAgICAgc2VnID0gKHZhbCAmIFNFR19NQVNLKSA+Pj4gU0VHX1NISUZUO1xcbiAgICAgICAgaWYgKHNlZykge1xcbiAgICAgICAgICB0ID0gKHQgKyB0ICsgMSArIDMyKSA8PCAoc2VnICsgMik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0ID0gKHQgKyB0ICsgMSkgPDwgMztcXG4gICAgICAgIH1cXG4gICAgICAgIHRhYmxlW2ldID0gdmFsICYgU0lHTl9CSVQgPyB0IDogLXQ7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgWExBV0RlY29kZXIucHJvdG90eXBlLnJlYWRDaHVuayA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgaSwgb3V0cHV0LCBzYW1wbGVzLCBzdHJlYW0sIHRhYmxlLCBfaTtcXG5cXG4gICAgc3RyZWFtID0gdGhpcy5zdHJlYW0sIHRhYmxlID0gdGhpcy50YWJsZTtcXG4gICAgc2FtcGxlcyA9IE1hdGgubWluKDQwOTYsIHRoaXMuc3RyZWFtLnJlbWFpbmluZ0J5dGVzKCkpO1xcbiAgICBpZiAoc2FtcGxlcyA9PT0gMCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBvdXRwdXQgPSBuZXcgSW50MTZBcnJheShzYW1wbGVzKTtcXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IHNhbXBsZXM7IGkgPSBfaSArPSAxKSB7XFxuICAgICAgb3V0cHV0W2ldID0gdGFibGVbc3RyZWFtLnJlYWRVSW50OCgpXTtcXG4gICAgfVxcbiAgICByZXR1cm4gb3V0cHV0O1xcbiAgfTtcXG5cXG4gIHJldHVybiBYTEFXRGVjb2RlcjtcXG5cXG59KShBVi5EZWNvZGVyKTtcXG4vL2ltcG9ydCBcXFwiZGVjb2RlcnMveGxhdy5jb2ZmZWVcXFwiO1xcbi8vaW1wb3J0IFxcXCJzcmMvYXVyb3JhLmNvZmZlZVxcXCI7XFxuICB2YXIgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcXG5cXG5BVi5IVFRQU291cmNlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xcbiAgX19leHRlbmRzKEhUVFBTb3VyY2UsIF9zdXBlcik7XFxuXFxuICBmdW5jdGlvbiBIVFRQU291cmNlKHVybCkge1xcbiAgICB0aGlzLnVybCA9IHVybDtcXG4gICAgdGhpcy5jaHVua1NpemUgPSAxIDw8IDIwO1xcbiAgICB0aGlzLmluZmxpZ2h0ID0gZmFsc2U7XFxuICAgIHRoaXMucmVzZXQoKTtcXG4gIH1cXG5cXG4gIEhUVFBTb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgIGlmICh0aGlzLmxlbmd0aCkge1xcbiAgICAgIGlmICghdGhpcy5pbmZsaWdodCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMubG9vcCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB0aGlzLmluZmxpZ2h0ID0gdHJ1ZTtcXG4gICAgdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgdGhpcy54aHIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcXG4gICAgICBfdGhpcy5sZW5ndGggPSBwYXJzZUludChfdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkNvbnRlbnQtTGVuZ3RoXFxcIikpO1xcbiAgICAgIF90aGlzLmluZmxpZ2h0ID0gZmFsc2U7XFxuICAgICAgcmV0dXJuIF90aGlzLmxvb3AoKTtcXG4gICAgfTtcXG4gICAgdGhpcy54aHIub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xcbiAgICAgIF90aGlzLnBhdXNlKCk7XFxuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcXG4gICAgfTtcXG4gICAgdGhpcy54aHIub25hYm9ydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuICAgICAgcmV0dXJuIF90aGlzLmluZmxpZ2h0ID0gZmFsc2U7XFxuICAgIH07XFxuICAgIHRoaXMueGhyLm9wZW4oXFxcIkhFQURcXFwiLCB0aGlzLnVybCwgdHJ1ZSk7XFxuICAgIHJldHVybiB0aGlzLnhoci5zZW5kKG51bGwpO1xcbiAgfTtcXG5cXG4gIEhUVFBTb3VyY2UucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGVuZFBvcyxcXG4gICAgICBfdGhpcyA9IHRoaXM7XFxuXFxuICAgIGlmICh0aGlzLmluZmxpZ2h0IHx8ICF0aGlzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgJ1NvbWV0aGluZyBpcyB3cm9uZyBpbiBIVFRQU291cmNlLmxvb3AnKTtcXG4gICAgfVxcbiAgICB0aGlzLmluZmxpZ2h0ID0gdHJ1ZTtcXG4gICAgdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgdGhpcy54aHIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcXG4gICAgICB2YXIgYnVmLCBidWZmZXIsIGksIHR4dCwgX2ksIF9yZWY7XFxuXFxuICAgICAgaWYgKF90aGlzLnhoci5yZXNwb25zZSkge1xcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoX3RoaXMueGhyLnJlc3BvbnNlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdHh0ID0gX3RoaXMueGhyLnJlc3BvbnNlVGV4dDtcXG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHR4dC5sZW5ndGgpO1xcbiAgICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gdHh0Lmxlbmd0aDsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcXG4gICAgICAgICAgYnVmW2ldID0gdHh0LmNoYXJDb2RlQXQoaSkgJiAweGZmO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBidWZmZXIgPSBuZXcgQVYuQnVmZmVyKGJ1Zik7XFxuICAgICAgX3RoaXMub2Zmc2V0ICs9IGJ1ZmZlci5sZW5ndGg7XFxuICAgICAgX3RoaXMuZW1pdCgnZGF0YScsIGJ1ZmZlcik7XFxuICAgICAgaWYgKF90aGlzLm9mZnNldCA+PSBfdGhpcy5sZW5ndGgpIHtcXG4gICAgICAgIF90aGlzLmVtaXQoJ2VuZCcpO1xcbiAgICAgIH1cXG4gICAgICBfdGhpcy5pbmZsaWdodCA9IGZhbHNlO1xcbiAgICAgIGlmICghKF90aGlzLm9mZnNldCA+PSBfdGhpcy5sZW5ndGgpKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMubG9vcCgpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhpcy54aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3Byb2dyZXNzJywgKF90aGlzLm9mZnNldCArIGV2ZW50LmxvYWRlZCkgLyBfdGhpcy5sZW5ndGggKiAxMDApO1xcbiAgICB9O1xcbiAgICB0aGlzLnhoci5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xcbiAgICAgIHJldHVybiBfdGhpcy5wYXVzZSgpO1xcbiAgICB9O1xcbiAgICB0aGlzLnhoci5vbmFib3J0ID0gZnVuY3Rpb24oZXZlbnQpIHtcXG4gICAgICByZXR1cm4gX3RoaXMuaW5mbGlnaHQgPSBmYWxzZTtcXG4gICAgfTtcXG4gICAgdGhpcy54aHIub3BlbihcXFwiR0VUXFxcIiwgdGhpcy51cmwsIHRydWUpO1xcbiAgICB0aGlzLnhoci5yZXNwb25zZVR5cGUgPSBcXFwiYXJyYXlidWZmZXJcXFwiO1xcbiAgICBlbmRQb3MgPSBNYXRoLm1pbih0aGlzLm9mZnNldCArIHRoaXMuY2h1bmtTaXplLCB0aGlzLmxlbmd0aCk7XFxuICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoXFxcIlJhbmdlXFxcIiwgXFxcImJ5dGVzPVxcXCIgKyB0aGlzLm9mZnNldCArIFxcXCItXFxcIiArIGVuZFBvcyk7XFxuICAgIHRoaXMueGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcXG4gICAgcmV0dXJuIHRoaXMueGhyLnNlbmQobnVsbCk7XFxuICB9O1xcblxcbiAgSFRUUFNvdXJjZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIF9yZWY7XFxuXFxuICAgIHRoaXMuaW5mbGlnaHQgPSBmYWxzZTtcXG4gICAgcmV0dXJuIChfcmVmID0gdGhpcy54aHIpICE9IG51bGwgPyBfcmVmLmFib3J0KCkgOiB2b2lkIDA7XFxuICB9O1xcblxcbiAgSFRUUFNvdXJjZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5wYXVzZSgpO1xcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgPSAwO1xcbiAgfTtcXG5cXG4gIHJldHVybiBIVFRQU291cmNlO1xcblxcbn0pKEFWLkV2ZW50RW1pdHRlcik7XFxuLy9pbXBvcnQgXFxcInNyYy9zb3VyY2VzL2Jyb3dzZXIvaHR0cC5jb2ZmZWVcXFwiO1xcbiAgdmFyIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XFxuXFxuQVYuRmlsZVNvdXJjZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcXG4gIF9fZXh0ZW5kcyhGaWxlU291cmNlLCBfc3VwZXIpO1xcblxcbiAgZnVuY3Rpb24gRmlsZVNvdXJjZShmaWxlKSB7XFxuICAgIHRoaXMuZmlsZSA9IGZpbGU7XFxuICAgIGlmICh0eXBlb2YgRmlsZVJlYWRlciA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgRmlsZVJlYWRlciA9PT0gbnVsbCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIEZpbGVSZWFkZXIgc3VwcG9ydC4nKTtcXG4gICAgfVxcbiAgICB0aGlzLm9mZnNldCA9IDA7XFxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5maWxlLnNpemU7XFxuICAgIHRoaXMuY2h1bmtTaXplID0gMSA8PCAyMDtcXG4gIH1cXG5cXG4gIEZpbGVTb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgIGlmICh0aGlzLnJlYWRlcikge1xcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmxvb3AoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdGhpcy5yZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xcbiAgICB0aGlzLnJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XFxuICAgICAgdmFyIGJ1ZjtcXG5cXG4gICAgICBidWYgPSBuZXcgQVYuQnVmZmVyKG5ldyBVaW50OEFycmF5KGUudGFyZ2V0LnJlc3VsdCkpO1xcbiAgICAgIF90aGlzLm9mZnNldCArPSBidWYubGVuZ3RoO1xcbiAgICAgIF90aGlzLmVtaXQoJ2RhdGEnLCBidWYpO1xcbiAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIGlmIChfdGhpcy5vZmZzZXQgPCBfdGhpcy5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBfdGhpcy5sb29wKCk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICB0aGlzLnJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcXG4gICAgICBpZiAoX3RoaXMub2Zmc2V0ID09PSBfdGhpcy5sZW5ndGgpIHtcXG4gICAgICAgIF90aGlzLmVtaXQoJ2VuZCcpO1xcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlYWRlciA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICB0aGlzLnJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xcbiAgICB9O1xcbiAgICB0aGlzLnJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24oZSkge1xcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdwcm9ncmVzcycsIChfdGhpcy5vZmZzZXQgKyBlLmxvYWRlZCkgLyBfdGhpcy5sZW5ndGggKiAxMDApO1xcbiAgICB9O1xcbiAgICByZXR1cm4gdGhpcy5sb29wKCk7XFxuICB9O1xcblxcbiAgRmlsZVNvdXJjZS5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgYmxvYiwgZW5kUG9zLCBzbGljZTtcXG5cXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xcbiAgICB0aGlzLmZpbGVbc2xpY2UgPSAnc2xpY2UnXSB8fCB0aGlzLmZpbGVbc2xpY2UgPSAnd2Via2l0U2xpY2UnXSB8fCB0aGlzLmZpbGVbc2xpY2UgPSAnbW96U2xpY2UnXTtcXG4gICAgZW5kUG9zID0gTWF0aC5taW4odGhpcy5vZmZzZXQgKyB0aGlzLmNodW5rU2l6ZSwgdGhpcy5sZW5ndGgpO1xcbiAgICBibG9iID0gdGhpcy5maWxlW3NsaWNlXSh0aGlzLm9mZnNldCwgZW5kUG9zKTtcXG4gICAgcmV0dXJuIHRoaXMucmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xcbiAgfTtcXG5cXG4gIEZpbGVTb3VyY2UucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBfcmVmO1xcblxcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xcbiAgICByZXR1cm4gKF9yZWYgPSB0aGlzLnJlYWRlcikgIT0gbnVsbCA/IF9yZWYuYWJvcnQoKSA6IHZvaWQgMDtcXG4gIH07XFxuXFxuICBGaWxlU291cmNlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLnBhdXNlKCk7XFxuICAgIHJldHVybiB0aGlzLm9mZnNldCA9IDA7XFxuICB9O1xcblxcbiAgcmV0dXJuIEZpbGVTb3VyY2U7XFxuXFxufSkoQVYuRXZlbnRFbWl0dGVyKTtcXG4vL2ltcG9ydCBcXFwic3JjL3NvdXJjZXMvYnJvd3Nlci9maWxlLmNvZmZlZVxcXCI7XFxuICByZXR1cm4gZ2xvYmFsLkFWID0gQVY7XFxufSkoKTtcXG5cIjtcbnZhciBhYWMgPSBcIi8qXFxuICogQUFDLmpzIC0gQWR2YW5jZWQgQXVkaW8gQ29kaW5nIGRlY29kZXIgaW4gSmF2YVNjcmlwdFxcbiAqIENyZWF0ZWQgYnkgRGV2b24gR292ZXR0XFxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBPZmZpY2lhbC5mbSBMYWJzXFxuICpcXG4gKiBBQUMuanMgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCBcXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBcXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgXFxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cXG4gKlxcbiAqIEFBQy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBcXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgXFxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBcXG4gKiBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAqXFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuXFxuICogSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxcbiAqL1xcblxcbihmdW5jdGlvbigpIHtcXG4gICAgXFxuY29uc3QgU0FNUExFX1JBVEVTID0gbmV3IEludDMyQXJyYXkoW1xcbiAgICA5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLFxcbiAgICAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTAgICAgXFxuXSk7XFxuICAgIFxcbnZhciBBRFRTRGVtdXhlciA9IEFWLkRlbXV4ZXIuZXh0ZW5kKGZ1bmN0aW9uKCkge1xcbiAgICBBVi5EZW11eGVyLnJlZ2lzdGVyKHRoaXMpO1xcbiAgICBcXG4gICAgdGhpcy5wcm9iZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xcbiAgICAgICAgdmFyIG9mZnNldCA9IHN0cmVhbS5vZmZzZXQ7XFxuICAgICAgICBcXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gZmluZCBBRFRTIHN5bmN3b3JkXFxuICAgICAgICB3aGlsZSAoc3RyZWFtLmF2YWlsYWJsZSgyKSkge1xcbiAgICAgICAgICAgIGlmICgoc3RyZWFtLnJlYWRVSW50MTYoKSAmIDB4ZmZmNikgPT09IDB4ZmZmMCkge1xcbiAgICAgICAgICAgICAgICBzdHJlYW0uc2VlayhvZmZzZXQpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIHN0cmVhbS5zZWVrKG9mZnNldCk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH07XFxuICAgICAgICBcXG4gICAgdGhpcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdGhpcy5iaXRzdHJlYW0gPSBuZXcgQVYuQml0c3RyZWFtKHRoaXMuc3RyZWFtKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIC8vIFJlYWRzIGFuIEFEVFMgaGVhZGVyXFxuICAgIC8vIFNlZSBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXFxuICAgIHRoaXMucmVhZEhlYWRlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xcbiAgICAgICAgaWYgKHN0cmVhbS5yZWFkKDEyKSAhPT0gMHhmZmYpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFEVFMgaGVhZGVyLicpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgdmFyIHJldCA9IHt9O1xcbiAgICAgICAgc3RyZWFtLmFkdmFuY2UoMyk7IC8vIG1wZWcgdmVyc2lvbiBhbmQgbGF5ZXJcXG4gICAgICAgIHZhciBwcm90ZWN0aW9uQWJzZW50ID0gISFzdHJlYW0ucmVhZCgxKTtcXG4gICAgICAgIFxcbiAgICAgICAgcmV0LnByb2ZpbGUgPSBzdHJlYW0ucmVhZCgyKSArIDE7XFxuICAgICAgICByZXQuc2FtcGxpbmdJbmRleCA9IHN0cmVhbS5yZWFkKDQpO1xcbiAgICAgICAgXFxuICAgICAgICBzdHJlYW0uYWR2YW5jZSgxKTsgLy8gcHJpdmF0ZVxcbiAgICAgICAgcmV0LmNoYW5Db25maWcgPSBzdHJlYW0ucmVhZCgzKTtcXG4gICAgICAgIHN0cmVhbS5hZHZhbmNlKDQpOyAvLyBvcmlnaW5hbC9jb3B5LCBob21lLCBjb3B5d3JpdGUsIGFuZCBjb3B5d3JpdGUgc3RhcnRcXG4gICAgICAgIFxcbiAgICAgICAgcmV0LmZyYW1lTGVuZ3RoID0gc3RyZWFtLnJlYWQoMTMpO1xcbiAgICAgICAgc3RyZWFtLmFkdmFuY2UoMTEpOyAvLyBmdWxsbmVzc1xcbiAgICAgICAgXFxuICAgICAgICByZXQubnVtRnJhbWVzID0gc3RyZWFtLnJlYWQoMikgKyAxO1xcbiAgICAgICAgXFxuICAgICAgICBpZiAoIXByb3RlY3Rpb25BYnNlbnQpXFxuICAgICAgICAgICAgc3RyZWFtLmFkdmFuY2UoMTYpO1xcbiAgICAgICAgXFxuICAgICAgICByZXR1cm4gcmV0O1xcbiAgICB9O1xcbiAgICBcXG4gICAgdGhpcy5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICBpZiAoIXRoaXMuc2VudEhlYWRlcikge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnN0cmVhbS5vZmZzZXQ7XFxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IEFEVFNEZW11eGVyLnJlYWRIZWFkZXIodGhpcy5iaXRzdHJlYW0pO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZm9ybWF0Jywge1xcbiAgICAgICAgICAgICAgICBmb3JtYXRJRDogJ2FhYyAnLFxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBTQU1QTEVfUkFURVNbaGVhZGVyLnNhbXBsaW5nSW5kZXhdLFxcbiAgICAgICAgICAgICAgICBjaGFubmVsc1BlckZyYW1lOiBoZWFkZXIuY2hhbkNvbmZpZyxcXG4gICAgICAgICAgICAgICAgYml0c1BlckNoYW5uZWw6IDE2LFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGEgbWFnaWMgY29va2llIGZyb20gdGhlIEFEVFMgaGVhZGVyXFxuICAgICAgICAgICAgdmFyIGNvb2tpZSA9IG5ldyBVaW50OEFycmF5KDIpO1xcbiAgICAgICAgICAgIGNvb2tpZVswXSA9IChoZWFkZXIucHJvZmlsZSA8PCAzKSB8ICgoaGVhZGVyLnNhbXBsaW5nSW5kZXggPj4gMSkgJiA3KTtcXG4gICAgICAgICAgICBjb29raWVbMV0gPSAoKGhlYWRlci5zYW1wbGluZ0luZGV4ICYgMSkgPDwgNykgfCAoaGVhZGVyLmNoYW5Db25maWcgPDwgMyk7XFxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb29raWUnLCBuZXcgQVYuQnVmZmVyKGNvb2tpZSkpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnNlZWsob2Zmc2V0KTtcXG4gICAgICAgICAgICB0aGlzLnNlbnRIZWFkZXIgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICB3aGlsZSAodGhpcy5zdHJlYW0uYXZhaWxhYmxlKDEpKSB7XFxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuc3RyZWFtLnJlYWRTaW5nbGVCdWZmZXIodGhpcy5zdHJlYW0ucmVtYWluaW5nQnl0ZXMoKSk7XFxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgYnVmZmVyKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG59KTsvL2ltcG9ydCBcXFwiYWR0c19kZW11eGVyLmpzXFxcIlxcbi8qXFxuICogQUFDLmpzIC0gQWR2YW5jZWQgQXVkaW8gQ29kaW5nIGRlY29kZXIgaW4gSmF2YVNjcmlwdFxcbiAqIENyZWF0ZWQgYnkgRGV2b24gR292ZXR0XFxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBPZmZpY2lhbC5mbSBMYWJzXFxuICpcXG4gKiBBQUMuanMgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCBcXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBcXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgXFxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cXG4gKlxcbiAqIEFBQy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBcXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgXFxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBcXG4gKiBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAqXFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuXFxuICogSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxcbiAqL1xcblxcbi8qXFxuICogQUFDLmpzIC0gQWR2YW5jZWQgQXVkaW8gQ29kaW5nIGRlY29kZXIgaW4gSmF2YVNjcmlwdFxcbiAqIENyZWF0ZWQgYnkgRGV2b24gR292ZXR0XFxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBPZmZpY2lhbC5mbSBMYWJzXFxuICpcXG4gKiBBQUMuanMgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCBcXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBcXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgXFxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cXG4gKlxcbiAqIEFBQy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBcXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgXFxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBcXG4gKiBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAqXFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuXFxuICogSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxcbiAqL1xcblxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAqIFNhbXBsZSBvZmZzZXQgaW50byB0aGUgd2luZG93IGluZGljYXRpbmcgdGhlIGJlZ2lubmluZyBvZiBhIHNjYWxlZmFjdG9yXFxuICogd2luZG93IGJhbmRcXG4gKlxcbiAqIHNjYWxlZmFjdG9yIHdpbmRvdyBiYW5kIC0gdGVybSBmb3Igc2NhbGVmYWN0b3IgYmFuZHMgd2l0aGluIGEgd2luZG93LFxcbiAqIGdpdmVuIGluIFRhYmxlIDQuMTEwIHRvIFRhYmxlIDQuMTI4LlxcbiAqXFxuICogc2NhbGVmYWN0b3IgYmFuZCAtIGEgc2V0IG9mIHNwZWN0cmFsIGNvZWZmaWNpZW50cyB3aGljaCBhcmUgc2NhbGVkIGJ5IG9uZVxcbiAqIHNjYWxlZmFjdG9yLiBJbiBjYXNlIG9mIEVJR0hUX1NIT1JUX1NFUVVFTkNFIGFuZCBncm91cGluZyBhIHNjYWxlZmFjdG9yIGJhbmRcXG4gKiBtYXkgY29udGFpbiBzZXZlcmFsIHNjYWxlZmFjdG9yIHdpbmRvdyBiYW5kcyBvZiBjb3JyZXNwb25kaW5nIGZyZXF1ZW5jeS4gRm9yXFxuICogYWxsIG90aGVyIHdpbmRvd19zZXF1ZW5jZXMgc2NhbGVmYWN0b3IgYmFuZHMgYW5kIHNjYWxlZmFjdG9yIHdpbmRvdyBiYW5kcyBhcmVcXG4gKiBpZGVudGljYWwuXFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuY29uc3QgU1dCX09GRlNFVF8xMDI0Xzk2ID0gbmV3IFVpbnQxNkFycmF5KFtcXG4gICAgICAwLCAgIDQsICAgOCwgIDEyLCAgMTYsICAyMCwgIDI0LCAgMjgsXFxuICAgICAzMiwgIDM2LCAgNDAsICA0NCwgIDQ4LCAgNTIsICA1NiwgIDY0LFxcbiAgICAgNzIsICA4MCwgIDg4LCAgOTYsIDEwOCwgMTIwLCAxMzIsIDE0NCxcXG4gICAgMTU2LCAxNzIsIDE4OCwgMjEyLCAyNDAsIDI3NiwgMzIwLCAzODQsXFxuICAgIDQ0OCwgNTEyLCA1NzYsIDY0MCwgNzA0LCA3NjgsIDgzMiwgODk2LFxcbiAgICA5NjAsIDEwMjRcXG5dKTtcXG5cXG5jb25zdCBTV0JfT0ZGU0VUXzEyOF85NiA9IG5ldyBVaW50MTZBcnJheShbXFxuICAgIDAsIDQsIDgsIDEyLCAxNiwgMjAsIDI0LCAzMiwgNDAsIDQ4LCA2NCwgOTIsIDEyOFxcbl0pO1xcblxcbmNvbnN0IFNXQl9PRkZTRVRfMTAyNF82NCA9IG5ldyBVaW50MTZBcnJheShbXFxuICAgICAgMCwgICA0LCAgIDgsICAxMiwgIDE2LCAgMjAsICAyNCwgIDI4LFxcbiAgICAgMzIsICAzNiwgIDQwLCAgNDQsICA0OCwgIDUyLCAgNTYsICA2NCxcXG4gICAgIDcyLCAgODAsICA4OCwgMTAwLCAxMTIsIDEyNCwgMTQwLCAxNTYsXFxuICAgIDE3MiwgMTkyLCAyMTYsIDI0MCwgMjY4LCAzMDQsIDM0NCwgMzg0LFxcbiAgICA0MjQsIDQ2NCwgNTA0LCA1NDQsIDU4NCwgNjI0LCA2NjQsIDcwNCxcXG4gICAgNzQ0LCA3ODQsIDgyNCwgODY0LCA5MDQsIDk0NCwgOTg0LCAxMDI0XFxuXSk7XFxuXFxuY29uc3QgU1dCX09GRlNFVF8xMjhfNjQgPSBuZXcgVWludDE2QXJyYXkoW1xcbiAgICAwLCA0LCA4LCAxMiwgMTYsIDIwLCAyNCwgMzIsIDQwLCA0OCwgNjQsIDkyLCAxMjhcXG5dKTtcXG5cXG5jb25zdCBTV0JfT0ZGU0VUXzEwMjRfNDggPSBuZXcgVWludDE2QXJyYXkoW1xcbiAgICAgIDAsICAgNCwgICA4LCAgMTIsICAxNiwgIDIwLCAgMjQsICAyOCxcXG4gICAgIDMyLCAgMzYsICA0MCwgIDQ4LCAgNTYsICA2NCwgIDcyLCAgODAsXFxuICAgICA4OCwgIDk2LCAxMDgsIDEyMCwgMTMyLCAxNDQsIDE2MCwgMTc2LFxcbiAgICAxOTYsIDIxNiwgMjQwLCAyNjQsIDI5MiwgMzIwLCAzNTIsIDM4NCxcXG4gICAgNDE2LCA0NDgsIDQ4MCwgNTEyLCA1NDQsIDU3NiwgNjA4LCA2NDAsXFxuICAgIDY3MiwgNzA0LCA3MzYsIDc2OCwgODAwLCA4MzIsIDg2NCwgODk2LFxcbiAgICA5MjgsIDEwMjRcXG5dKTtcXG5cXG5jb25zdCBTV0JfT0ZGU0VUXzEyOF80OCA9IG5ldyBVaW50MTZBcnJheShbXFxuICAgICAwLCAgIDQsICAgOCwgIDEyLCAgMTYsICAyMCwgIDI4LCAgMzYsXFxuICAgIDQ0LCAgNTYsICA2OCwgIDgwLCAgOTYsIDExMiwgMTI4XFxuXSk7XFxuXFxuY29uc3QgU1dCX09GRlNFVF8xMDI0XzMyID0gbmV3IFVpbnQxNkFycmF5KFtcXG4gICAgICAwLCAgIDQsICAgOCwgIDEyLCAgMTYsICAyMCwgIDI0LCAgMjgsXFxuICAgICAzMiwgIDM2LCAgNDAsICA0OCwgIDU2LCAgNjQsICA3MiwgIDgwLFxcbiAgICAgODgsICA5NiwgMTA4LCAxMjAsIDEzMiwgMTQ0LCAxNjAsIDE3NixcXG4gICAgMTk2LCAyMTYsIDI0MCwgMjY0LCAyOTIsIDMyMCwgMzUyLCAzODQsXFxuICAgIDQxNiwgNDQ4LCA0ODAsIDUxMiwgNTQ0LCA1NzYsIDYwOCwgNjQwLFxcbiAgICA2NzIsIDcwNCwgNzM2LCA3NjgsIDgwMCwgODMyLCA4NjQsIDg5NixcXG4gICAgOTI4LCA5NjAsIDk5MiwgMTAyNFxcbl0pO1xcblxcbmNvbnN0IFNXQl9PRkZTRVRfMTAyNF8yNCA9IG5ldyBVaW50MTZBcnJheShbXFxuICAgICAgMCwgICA0LCAgIDgsICAxMiwgIDE2LCAgMjAsICAyNCwgIDI4LFxcbiAgICAgMzIsICAzNiwgIDQwLCAgNDQsICA1MiwgIDYwLCAgNjgsICA3NixcXG4gICAgIDg0LCAgOTIsIDEwMCwgMTA4LCAxMTYsIDEyNCwgMTM2LCAxNDgsXFxuICAgIDE2MCwgMTcyLCAxODgsIDIwNCwgMjIwLCAyNDAsIDI2MCwgMjg0LFxcbiAgICAzMDgsIDMzNiwgMzY0LCAzOTYsIDQzMiwgNDY4LCA1MDgsIDU1MixcXG4gICAgNjAwLCA2NTIsIDcwNCwgNzY4LCA4MzIsIDg5NiwgOTYwLCAxMDI0XFxuXSk7XFxuXFxuY29uc3QgU1dCX09GRlNFVF8xMjhfMjQgPSBuZXcgVWludDE2QXJyYXkoW1xcbiAgICAgMCwgICA0LCAgIDgsICAxMiwgIDE2LCAgMjAsICAyNCwgIDI4LFxcbiAgICAzNiwgIDQ0LCAgNTIsICA2NCwgIDc2LCAgOTIsIDEwOCwgMTI4XFxuXSk7XFxuXFxuY29uc3QgU1dCX09GRlNFVF8xMDI0XzE2ID0gbmV3IFVpbnQxNkFycmF5KFtcXG4gICAgICAwLCAgIDgsICAxNiwgIDI0LCAgMzIsICA0MCwgIDQ4LCAgNTYsXFxuICAgICA2NCwgIDcyLCAgODAsICA4OCwgMTAwLCAxMTIsIDEyNCwgMTM2LFxcbiAgICAxNDgsIDE2MCwgMTcyLCAxODQsIDE5NiwgMjEyLCAyMjgsIDI0NCxcXG4gICAgMjYwLCAyODAsIDMwMCwgMzIwLCAzNDQsIDM2OCwgMzk2LCA0MjQsXFxuICAgIDQ1NiwgNDkyLCA1MzIsIDU3MiwgNjE2LCA2NjQsIDcxNiwgNzcyLFxcbiAgICA4MzIsIDg5NiwgOTYwLCAxMDI0XFxuXSk7XFxuXFxuY29uc3QgU1dCX09GRlNFVF8xMjhfMTYgPSBuZXcgVWludDE2QXJyYXkoW1xcbiAgICAgMCwgICA0LCAgIDgsICAxMiwgIDE2LCAgMjAsICAyNCwgIDI4LFxcbiAgICAzMiwgIDQwLCAgNDgsICA2MCwgIDcyLCAgODgsIDEwOCwgMTI4XFxuXSk7XFxuXFxuY29uc3QgU1dCX09GRlNFVF8xMDI0XzggPSBuZXcgVWludDE2QXJyYXkoW1xcbiAgICAgIDAsICAxMiwgIDI0LCAgMzYsICA0OCwgIDYwLCAgNzIsICA4NCxcXG4gICAgIDk2LCAxMDgsIDEyMCwgMTMyLCAxNDQsIDE1NiwgMTcyLCAxODgsXFxuICAgIDIwNCwgMjIwLCAyMzYsIDI1MiwgMjY4LCAyODgsIDMwOCwgMzI4LFxcbiAgICAzNDgsIDM3MiwgMzk2LCA0MjAsIDQ0OCwgNDc2LCA1MDgsIDU0NCxcXG4gICAgNTgwLCA2MjAsIDY2NCwgNzEyLCA3NjQsIDgyMCwgODgwLCA5NDQsXFxuICAgIDEwMjRcXG5dKTtcXG5cXG5jb25zdCBTV0JfT0ZGU0VUXzEyOF84ID0gbmV3IFVpbnQxNkFycmF5KFtcXG4gICAgIDAsICAgNCwgICA4LCAgMTIsICAxNiwgIDIwLCAgMjQsICAyOCxcXG4gICAgMzYsICA0NCwgIDUyLCAgNjAsICA3MiwgIDg4LCAxMDgsIDEyOFxcbl0pO1xcblxcbmNvbnN0IFNXQl9PRkZTRVRfMTAyNCA9IFtcXG4gICAgU1dCX09GRlNFVF8xMDI0Xzk2LFxcbiAgICBTV0JfT0ZGU0VUXzEwMjRfOTYsXFxuICAgIFNXQl9PRkZTRVRfMTAyNF82NCxcXG4gICAgU1dCX09GRlNFVF8xMDI0XzQ4LFxcbiAgICBTV0JfT0ZGU0VUXzEwMjRfNDgsXFxuICAgIFNXQl9PRkZTRVRfMTAyNF8zMixcXG4gICAgU1dCX09GRlNFVF8xMDI0XzI0LFxcbiAgICBTV0JfT0ZGU0VUXzEwMjRfMjQsXFxuICAgIFNXQl9PRkZTRVRfMTAyNF8xNixcXG4gICAgU1dCX09GRlNFVF8xMDI0XzE2LFxcbiAgICBTV0JfT0ZGU0VUXzEwMjRfMTYsXFxuICAgIFNXQl9PRkZTRVRfMTAyNF84XFxuXTtcXG5cXG5jb25zdCBTV0JfT0ZGU0VUXzEyOCA9IFtcXG4gICAgU1dCX09GRlNFVF8xMjhfOTYsXFxuICAgIFNXQl9PRkZTRVRfMTI4Xzk2LFxcbiAgICBTV0JfT0ZGU0VUXzEyOF82NCxcXG4gICAgU1dCX09GRlNFVF8xMjhfNDgsXFxuICAgIFNXQl9PRkZTRVRfMTI4XzQ4LFxcbiAgICBTV0JfT0ZGU0VUXzEyOF80OCxcXG4gICAgU1dCX09GRlNFVF8xMjhfMjQsXFxuICAgIFNXQl9PRkZTRVRfMTI4XzI0LFxcbiAgICBTV0JfT0ZGU0VUXzEyOF8xNixcXG4gICAgU1dCX09GRlNFVF8xMjhfMTYsXFxuICAgIFNXQl9PRkZTRVRfMTI4XzE2LFxcbiAgICBTV0JfT0ZGU0VUXzEyOF84XFxuXTtcXG5cXG5jb25zdCBTV0JfU0hPUlRfV0lORE9XX0NPVU5UID0gbmV3IFVpbnQ4QXJyYXkoW1xcbiAgICAxMiwgMTIsIDEyLCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1XFxuXSk7XFxuXFxuY29uc3QgU1dCX0xPTkdfV0lORE9XX0NPVU5UID0gbmV3IFVpbnQ4QXJyYXkoW1xcbiAgICA0MSwgNDEsIDQ3LCA0OSwgNDksIDUxLCA0NywgNDcsIDQzLCA0MywgNDMsIDQwXFxuXSk7XFxuXFxuLypcXG4gKiBTY2FsZWZhY3RvciBsb29rdXAgdGFibGVcXG4gKi9cXG5jb25zdCBTQ0FMRUZBQ1RPUl9UQUJMRSA9IChmdW5jdGlvbigpIHtcXG4gICAgdmFyIHRhYmxlID0gbmV3IEZsb2F0MzJBcnJheSg0MjgpO1xcbiAgICBcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0Mjg7IGkrKykge1xcbiAgICAgICAgdGFibGVbaV0gPSBNYXRoLnBvdygyLCAoaSAtIDIwMCkgLyA0KTtcXG4gICAgfVxcbiAgICBcXG4gICAgcmV0dXJuIHRhYmxlO1xcbn0pKCk7XFxuXFxuXFxuLyoqXFxuICogSW52ZXJzZSBxdWFudGl6YXRpb24gbG9va3VwIHRhYmxlXFxuICovXFxuY29uc3QgSVFfVEFCTEUgPSAoZnVuY3Rpb24oKSB7XFxuICAgIHZhciB0YWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoODE5MSksXFxuICAgICAgICBmb3VyX3RoaXJkcyA9IDQvMztcXG4gICAgICAgIFxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgxOTE7IGkrKykge1xcbiAgICAgICAgdGFibGVbaV0gPSBNYXRoLnBvdyhpLCBmb3VyX3RoaXJkcyk7XFxuICAgIH1cXG4gICAgXFxuICAgIHJldHVybiB0YWJsZTtcXG59KSgpOy8vaW1wb3J0IFxcXCJ0YWJsZXMuanNcXFwiXFxuLypcXG4gKiBBQUMuanMgLSBBZHZhbmNlZCBBdWRpbyBDb2RpbmcgZGVjb2RlciBpbiBKYXZhU2NyaXB0XFxuICogQ3JlYXRlZCBieSBEZXZvbiBHb3ZldHRcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIsIE9mZmljaWFsLmZtIExhYnNcXG4gKlxcbiAqIEFBQy5qcyBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IFxcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIFxcbiAqIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBcXG4gKiBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxcbiAqXFxuICogQUFDLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUIFxcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBcXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFxcbiAqIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXFxuICpcXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXFxuICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS5cXG4gKiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXFxuICovXFxuXFxudmFyIEh1ZmZtYW4gPSAoZnVuY3Rpb24oKSB7XFxuXFxuICAgIC8vIFtiaXQgbGVuZ3RoLCBjb2Rld29yZCwgdmFsdWVzLi4uXVxcbiAgICBjb25zdCBIQ0IxID0gW1xcbiAgICAgICAgWzEsIDAsIDAsIDAsIDAsIDBdLFxcbiAgICAgICAgWzUsIDE2LCAxLCAwLCAwLCAwXSxcXG4gICAgICAgIFs1LCAxNywgLTEsIDAsIDAsIDBdLFxcbiAgICAgICAgWzUsIDE4LCAwLCAwLCAwLCAtMV0sXFxuICAgICAgICBbNSwgMTksIDAsIDEsIDAsIDBdLFxcbiAgICAgICAgWzUsIDIwLCAwLCAwLCAwLCAxXSxcXG4gICAgICAgIFs1LCAyMSwgMCwgMCwgLTEsIDBdLFxcbiAgICAgICAgWzUsIDIyLCAwLCAwLCAxLCAwXSxcXG4gICAgICAgIFs1LCAyMywgMCwgLTEsIDAsIDBdLFxcbiAgICAgICAgWzcsIDk2LCAxLCAtMSwgMCwgMF0sXFxuICAgICAgICBbNywgOTcsIC0xLCAxLCAwLCAwXSxcXG4gICAgICAgIFs3LCA5OCwgMCwgMCwgLTEsIDFdLFxcbiAgICAgICAgWzcsIDk5LCAwLCAxLCAtMSwgMF0sXFxuICAgICAgICBbNywgMTAwLCAwLCAtMSwgMSwgMF0sXFxuICAgICAgICBbNywgMTAxLCAwLCAwLCAxLCAtMV0sXFxuICAgICAgICBbNywgMTAyLCAxLCAxLCAwLCAwXSxcXG4gICAgICAgIFs3LCAxMDMsIDAsIDAsIC0xLCAtMV0sXFxuICAgICAgICBbNywgMTA0LCAtMSwgLTEsIDAsIDBdLFxcbiAgICAgICAgWzcsIDEwNSwgMCwgLTEsIC0xLCAwXSxcXG4gICAgICAgIFs3LCAxMDYsIDEsIDAsIC0xLCAwXSxcXG4gICAgICAgIFs3LCAxMDcsIDAsIDEsIDAsIC0xXSxcXG4gICAgICAgIFs3LCAxMDgsIC0xLCAwLCAxLCAwXSxcXG4gICAgICAgIFs3LCAxMDksIDAsIDAsIDEsIDFdLFxcbiAgICAgICAgWzcsIDExMCwgMSwgMCwgMSwgMF0sXFxuICAgICAgICBbNywgMTExLCAwLCAtMSwgMCwgMV0sXFxuICAgICAgICBbNywgMTEyLCAwLCAxLCAxLCAwXSxcXG4gICAgICAgIFs3LCAxMTMsIDAsIDEsIDAsIDFdLFxcbiAgICAgICAgWzcsIDExNCwgLTEsIDAsIC0xLCAwXSxcXG4gICAgICAgIFs3LCAxMTUsIDEsIDAsIDAsIDFdLFxcbiAgICAgICAgWzcsIDExNiwgLTEsIDAsIDAsIC0xXSxcXG4gICAgICAgIFs3LCAxMTcsIDEsIDAsIDAsIC0xXSxcXG4gICAgICAgIFs3LCAxMTgsIC0xLCAwLCAwLCAxXSxcXG4gICAgICAgIFs3LCAxMTksIDAsIC0xLCAwLCAtMV0sXFxuICAgICAgICBbOSwgNDgwLCAxLCAxLCAtMSwgMF0sXFxuICAgICAgICBbOSwgNDgxLCAtMSwgMSwgLTEsIDBdLFxcbiAgICAgICAgWzksIDQ4MiwgMSwgLTEsIDEsIDBdLFxcbiAgICAgICAgWzksIDQ4MywgMCwgMSwgMSwgLTFdLFxcbiAgICAgICAgWzksIDQ4NCwgMCwgMSwgLTEsIDFdLFxcbiAgICAgICAgWzksIDQ4NSwgMCwgLTEsIDEsIDFdLFxcbiAgICAgICAgWzksIDQ4NiwgMCwgLTEsIDEsIC0xXSxcXG4gICAgICAgIFs5LCA0ODcsIDEsIC0xLCAtMSwgMF0sXFxuICAgICAgICBbOSwgNDg4LCAxLCAwLCAtMSwgMV0sXFxuICAgICAgICBbOSwgNDg5LCAwLCAxLCAtMSwgLTFdLFxcbiAgICAgICAgWzksIDQ5MCwgLTEsIDEsIDEsIDBdLFxcbiAgICAgICAgWzksIDQ5MSwgLTEsIDAsIDEsIC0xXSxcXG4gICAgICAgIFs5LCA0OTIsIC0xLCAtMSwgMSwgMF0sXFxuICAgICAgICBbOSwgNDkzLCAwLCAtMSwgLTEsIDFdLFxcbiAgICAgICAgWzksIDQ5NCwgMSwgLTEsIDAsIDFdLFxcbiAgICAgICAgWzksIDQ5NSwgMSwgLTEsIDAsIC0xXSxcXG4gICAgICAgIFs5LCA0OTYsIC0xLCAxLCAwLCAtMV0sXFxuICAgICAgICBbOSwgNDk3LCAtMSwgLTEsIC0xLCAwXSxcXG4gICAgICAgIFs5LCA0OTgsIDAsIC0xLCAtMSwgLTFdLFxcbiAgICAgICAgWzksIDQ5OSwgMCwgMSwgMSwgMV0sXFxuICAgICAgICBbOSwgNTAwLCAxLCAwLCAxLCAtMV0sXFxuICAgICAgICBbOSwgNTAxLCAxLCAxLCAwLCAxXSxcXG4gICAgICAgIFs5LCA1MDIsIC0xLCAxLCAwLCAxXSxcXG4gICAgICAgIFs5LCA1MDMsIDEsIDEsIDEsIDBdLFxcbiAgICAgICAgWzEwLCAxMDA4LCAtMSwgLTEsIDAsIDFdLFxcbiAgICAgICAgWzEwLCAxMDA5LCAtMSwgMCwgLTEsIC0xXSxcXG4gICAgICAgIFsxMCwgMTAxMCwgMSwgMSwgMCwgLTFdLFxcbiAgICAgICAgWzEwLCAxMDExLCAxLCAwLCAtMSwgLTFdLFxcbiAgICAgICAgWzEwLCAxMDEyLCAtMSwgMCwgLTEsIDFdLFxcbiAgICAgICAgWzEwLCAxMDEzLCAtMSwgLTEsIDAsIC0xXSxcXG4gICAgICAgIFsxMCwgMTAxNCwgLTEsIDAsIDEsIDFdLFxcbiAgICAgICAgWzEwLCAxMDE1LCAxLCAwLCAxLCAxXSxcXG4gICAgICAgIFsxMSwgMjAzMiwgMSwgLTEsIDEsIC0xXSxcXG4gICAgICAgIFsxMSwgMjAzMywgLTEsIDEsIC0xLCAxXSxcXG4gICAgICAgIFsxMSwgMjAzNCwgLTEsIDEsIDEsIC0xXSxcXG4gICAgICAgIFsxMSwgMjAzNSwgMSwgLTEsIC0xLCAxXSxcXG4gICAgICAgIFsxMSwgMjAzNiwgMSwgMSwgMSwgMV0sXFxuICAgICAgICBbMTEsIDIwMzcsIC0xLCAtMSwgMSwgMV0sXFxuICAgICAgICBbMTEsIDIwMzgsIDEsIDEsIC0xLCAtMV0sXFxuICAgICAgICBbMTEsIDIwMzksIC0xLCAtMSwgMSwgLTFdLFxcbiAgICAgICAgWzExLCAyMDQwLCAtMSwgLTEsIC0xLCAtMV0sXFxuICAgICAgICBbMTEsIDIwNDEsIDEsIDEsIC0xLCAxXSxcXG4gICAgICAgIFsxMSwgMjA0MiwgMSwgLTEsIDEsIDFdLFxcbiAgICAgICAgWzExLCAyMDQzLCAtMSwgMSwgMSwgMV0sXFxuICAgICAgICBbMTEsIDIwNDQsIC0xLCAxLCAtMSwgLTFdLFxcbiAgICAgICAgWzExLCAyMDQ1LCAtMSwgLTEsIC0xLCAxXSxcXG4gICAgICAgIFsxMSwgMjA0NiwgMSwgLTEsIC0xLCAtMV0sXFxuICAgICAgICBbMTEsIDIwNDcsIDEsIDEsIDEsIC0xXVxcbiAgICBdO1xcbiAgICBcXG4gICAgY29uc3QgSENCMiA9IFtcXG4gICAgICAgIFszLCAwLCAwLCAwLCAwLCAwXSxcXG4gICAgICAgIFs0LCAyLCAxLCAwLCAwLCAwXSxcXG4gICAgICAgIFs1LCA2LCAtMSwgMCwgMCwgMF0sXFxuICAgICAgICBbNSwgNywgMCwgMCwgMCwgMV0sXFxuICAgICAgICBbNSwgOCwgMCwgMCwgLTEsIDBdLFxcbiAgICAgICAgWzUsIDksIDAsIDAsIDAsIC0xXSxcXG4gICAgICAgIFs1LCAxMCwgMCwgLTEsIDAsIDBdLFxcbiAgICAgICAgWzUsIDExLCAwLCAwLCAxLCAwXSxcXG4gICAgICAgIFs1LCAxMiwgMCwgMSwgMCwgMF0sXFxuICAgICAgICBbNiwgMjYsIDAsIC0xLCAxLCAwXSxcXG4gICAgICAgIFs2LCAyNywgLTEsIDEsIDAsIDBdLFxcbiAgICAgICAgWzYsIDI4LCAwLCAxLCAtMSwgMF0sXFxuICAgICAgICBbNiwgMjksIDAsIDAsIDEsIC0xXSxcXG4gICAgICAgIFs2LCAzMCwgMCwgMSwgMCwgLTFdLFxcbiAgICAgICAgWzYsIDMxLCAwLCAwLCAtMSwgMV0sXFxuICAgICAgICBbNiwgMzIsIC0xLCAwLCAwLCAtMV0sXFxuICAgICAgICBbNiwgMzMsIDEsIC0xLCAwLCAwXSxcXG4gICAgICAgIFs2LCAzNCwgMSwgMCwgLTEsIDBdLFxcbiAgICAgICAgWzYsIDM1LCAtMSwgLTEsIDAsIDBdLFxcbiAgICAgICAgWzYsIDM2LCAwLCAwLCAtMSwgLTFdLFxcbiAgICAgICAgWzYsIDM3LCAxLCAwLCAxLCAwXSxcXG4gICAgICAgIFs2LCAzOCwgMSwgMCwgMCwgMV0sXFxuICAgICAgICBbNiwgMzksIDAsIC0xLCAwLCAxXSxcXG4gICAgICAgIFs2LCA0MCwgLTEsIDAsIDEsIDBdLFxcbiAgICAgICAgWzYsIDQxLCAwLCAxLCAwLCAxXSxcXG4gICAgICAgIFs2LCA0MiwgMCwgLTEsIC0xLCAwXSxcXG4gICAgICAgIFs2LCA0MywgLTEsIDAsIDAsIDFdLFxcbiAgICAgICAgWzYsIDQ0LCAwLCAtMSwgMCwgLTFdLFxcbiAgICAgICAgWzYsIDQ1LCAtMSwgMCwgLTEsIDBdLFxcbiAgICAgICAgWzYsIDQ2LCAxLCAxLCAwLCAwXSxcXG4gICAgICAgIFs2LCA0NywgMCwgMSwgMSwgMF0sXFxuICAgICAgICBbNiwgNDgsIDAsIDAsIDEsIDFdLFxcbiAgICAgICAgWzYsIDQ5LCAxLCAwLCAwLCAtMV0sXFxuICAgICAgICBbNywgMTAwLCAwLCAxLCAtMSwgMV0sXFxuICAgICAgICBbNywgMTAxLCAxLCAwLCAtMSwgMV0sXFxuICAgICAgICBbNywgMTAyLCAtMSwgMSwgLTEsIDBdLFxcbiAgICAgICAgWzcsIDEwMywgMCwgLTEsIDEsIC0xXSxcXG4gICAgICAgIFs3LCAxMDQsIDEsIC0xLCAxLCAwXSxcXG4gICAgICAgIFs3LCAxMDUsIDEsIDEsIDAsIC0xXSxcXG4gICAgICAgIFs3LCAxMDYsIDEsIDAsIDEsIDFdLFxcbiAgICAgICAgWzcsIDEwNywgLTEsIDEsIDEsIDBdLFxcbiAgICAgICAgWzcsIDEwOCwgMCwgLTEsIC0xLCAxXSxcXG4gICAgICAgIFs3LCAxMDksIDEsIDEsIDEsIDBdLFxcbiAgICAgICAgWzcsIDExMCwgLTEsIDAsIDEsIC0xXSxcXG4gICAgICAgIFs3LCAxMTEsIC0xLCAtMSwgLTEsIDBdLFxcbiAgICAgICAgWzcsIDExMiwgLTEsIDAsIC0xLCAxXSxcXG4gICAgICAgIFs3LCAxMTMsIDEsIC0xLCAtMSwgMF0sXFxuICAgICAgICBbNywgMTE0LCAxLCAxLCAtMSwgMF0sXFxuICAgICAgICBbOCwgMjMwLCAxLCAtMSwgMCwgMV0sXFxuICAgICAgICBbOCwgMjMxLCAtMSwgMSwgMCwgLTFdLFxcbiAgICAgICAgWzgsIDIzMiwgLTEsIC0xLCAxLCAwXSxcXG4gICAgICAgIFs4LCAyMzMsIC0xLCAwLCAxLCAxXSxcXG4gICAgICAgIFs4LCAyMzQsIC0xLCAtMSwgMCwgMV0sXFxuICAgICAgICBbOCwgMjM1LCAtMSwgLTEsIDAsIC0xXSxcXG4gICAgICAgIFs4LCAyMzYsIDAsIC0xLCAtMSwgLTFdLFxcbiAgICAgICAgWzgsIDIzNywgMSwgMCwgMSwgLTFdLFxcbiAgICAgICAgWzgsIDIzOCwgMSwgMCwgLTEsIC0xXSxcXG4gICAgICAgIFs4LCAyMzksIDAsIDEsIC0xLCAtMV0sXFxuICAgICAgICBbOCwgMjQwLCAwLCAxLCAxLCAxXSxcXG4gICAgICAgIFs4LCAyNDEsIC0xLCAxLCAwLCAxXSxcXG4gICAgICAgIFs4LCAyNDIsIC0xLCAwLCAtMSwgLTFdLFxcbiAgICAgICAgWzgsIDI0MywgMCwgMSwgMSwgLTFdLFxcbiAgICAgICAgWzgsIDI0NCwgMSwgLTEsIDAsIC0xXSxcXG4gICAgICAgIFs4LCAyNDUsIDAsIC0xLCAxLCAxXSxcXG4gICAgICAgIFs4LCAyNDYsIDEsIDEsIDAsIDFdLFxcbiAgICAgICAgWzgsIDI0NywgMSwgLTEsIDEsIC0xXSxcXG4gICAgICAgIFs4LCAyNDgsIC0xLCAxLCAtMSwgMV0sXFxuICAgICAgICBbOSwgNDk4LCAxLCAtMSwgLTEsIDFdLFxcbiAgICAgICAgWzksIDQ5OSwgLTEsIC0xLCAtMSwgLTFdLFxcbiAgICAgICAgWzksIDUwMCwgLTEsIDEsIDEsIC0xXSxcXG4gICAgICAgIFs5LCA1MDEsIC0xLCAxLCAxLCAxXSxcXG4gICAgICAgIFs5LCA1MDIsIDEsIDEsIDEsIDFdLFxcbiAgICAgICAgWzksIDUwMywgLTEsIC0xLCAxLCAtMV0sXFxuICAgICAgICBbOSwgNTA0LCAxLCAtMSwgMSwgMV0sXFxuICAgICAgICBbOSwgNTA1LCAtMSwgMSwgLTEsIC0xXSxcXG4gICAgICAgIFs5LCA1MDYsIC0xLCAtMSwgMSwgMV0sXFxuICAgICAgICBbOSwgNTA3LCAxLCAxLCAtMSwgLTFdLFxcbiAgICAgICAgWzksIDUwOCwgMSwgLTEsIC0xLCAtMV0sXFxuICAgICAgICBbOSwgNTA5LCAtMSwgLTEsIC0xLCAxXSxcXG4gICAgICAgIFs5LCA1MTAsIDEsIDEsIC0xLCAxXSxcXG4gICAgICAgIFs5LCA1MTEsIDEsIDEsIDEsIC0xXVxcbiAgICBdO1xcbiAgICBcXG4gICAgY29uc3QgSENCMyA9IFtcXG4gICAgICAgIFsxLCAwLCAwLCAwLCAwLCAwXSxcXG4gICAgICAgIFs0LCA4LCAxLCAwLCAwLCAwXSxcXG4gICAgICAgIFs0LCA5LCAwLCAwLCAwLCAxXSxcXG4gICAgICAgIFs0LCAxMCwgMCwgMSwgMCwgMF0sXFxuICAgICAgICBbNCwgMTEsIDAsIDAsIDEsIDBdLFxcbiAgICAgICAgWzUsIDI0LCAxLCAxLCAwLCAwXSxcXG4gICAgICAgIFs1LCAyNSwgMCwgMCwgMSwgMV0sXFxuICAgICAgICBbNiwgNTIsIDAsIDEsIDEsIDBdLFxcbiAgICAgICAgWzYsIDUzLCAwLCAxLCAwLCAxXSxcXG4gICAgICAgIFs2LCA1NCwgMSwgMCwgMSwgMF0sXFxuICAgICAgICBbNiwgNTUsIDAsIDEsIDEsIDFdLFxcbiAgICAgICAgWzYsIDU2LCAxLCAwLCAwLCAxXSxcXG4gICAgICAgIFs2LCA1NywgMSwgMSwgMSwgMF0sXFxuICAgICAgICBbNywgMTE2LCAxLCAxLCAxLCAxXSxcXG4gICAgICAgIFs3LCAxMTcsIDEsIDAsIDEsIDFdLFxcbiAgICAgICAgWzcsIDExOCwgMSwgMSwgMCwgMV0sXFxuICAgICAgICBbOCwgMjM4LCAyLCAwLCAwLCAwXSxcXG4gICAgICAgIFs4LCAyMzksIDAsIDAsIDAsIDJdLFxcbiAgICAgICAgWzgsIDI0MCwgMCwgMCwgMSwgMl0sXFxuICAgICAgICBbOCwgMjQxLCAyLCAxLCAwLCAwXSxcXG4gICAgICAgIFs4LCAyNDIsIDEsIDIsIDEsIDBdLFxcbiAgICAgICAgWzksIDQ4NiwgMCwgMCwgMiwgMV0sXFxuICAgICAgICBbOSwgNDg3LCAwLCAxLCAyLCAxXSxcXG4gICAgICAgIFs5LCA0ODgsIDEsIDIsIDAsIDBdLFxcbiAgICAgICAgWzksIDQ4OSwgMCwgMSwgMSwgMl0sXFxuICAgICAgICBbOSwgNDkwLCAyLCAxLCAxLCAwXSxcXG4gICAgICAgIFs5LCA0OTEsIDAsIDAsIDIsIDBdLFxcbiAgICAgICAgWzksIDQ5MiwgMCwgMiwgMSwgMF0sXFxuICAgICAgICBbOSwgNDkzLCAwLCAxLCAyLCAwXSxcXG4gICAgICAgIFs5LCA0OTQsIDAsIDIsIDAsIDBdLFxcbiAgICAgICAgWzksIDQ5NSwgMCwgMSwgMCwgMl0sXFxuICAgICAgICBbOSwgNDk2LCAyLCAwLCAxLCAwXSxcXG4gICAgICAgIFs5LCA0OTcsIDEsIDIsIDEsIDFdLFxcbiAgICAgICAgWzksIDQ5OCwgMCwgMiwgMSwgMV0sXFxuICAgICAgICBbOSwgNDk5LCAxLCAxLCAyLCAwXSxcXG4gICAgICAgIFs5LCA1MDAsIDEsIDEsIDIsIDFdLFxcbiAgICAgICAgWzEwLCAxMDAyLCAxLCAyLCAwLCAxXSxcXG4gICAgICAgIFsxMCwgMTAwMywgMSwgMCwgMiwgMF0sXFxuICAgICAgICBbMTAsIDEwMDQsIDEsIDAsIDIsIDFdLFxcbiAgICAgICAgWzEwLCAxMDA1LCAwLCAyLCAwLCAxXSxcXG4gICAgICAgIFsxMCwgMTAwNiwgMiwgMSwgMSwgMV0sXFxuICAgICAgICBbMTAsIDEwMDcsIDEsIDEsIDEsIDJdLFxcbiAgICAgICAgWzEwLCAxMDA4LCAyLCAxLCAwLCAxXSxcXG4gICAgICAgIFsxMCwgMTAwOSwgMSwgMCwgMSwgMl0sXFxuICAgICAgICBbMTAsIDEwMTAsIDAsIDAsIDIsIDJdLFxcbiAgICAgICAgWzEwLCAxMDExLCAwLCAxLCAyLCAyXSxcXG4gICAgICAgIFsxMCwgMTAxMiwgMiwgMiwgMSwgMF0sXFxuICAgICAgICBbMTAsIDEwMTMsIDEsIDIsIDIsIDBdLFxcbiAgICAgICAgWzEwLCAxMDE0LCAxLCAwLCAwLCAyXSxcXG4gICAgICAgIFsxMCwgMTAxNSwgMiwgMCwgMCwgMV0sXFxuICAgICAgICBbMTAsIDEwMTYsIDAsIDIsIDIsIDFdLFxcbiAgICAgICAgWzExLCAyMDM0LCAyLCAyLCAwLCAwXSxcXG4gICAgICAgIFsxMSwgMjAzNSwgMSwgMiwgMiwgMV0sXFxuICAgICAgICBbMTEsIDIwMzYsIDEsIDEsIDAsIDJdLFxcbiAgICAgICAgWzExLCAyMDM3LCAyLCAwLCAxLCAxXSxcXG4gICAgICAgIFsxMSwgMjAzOCwgMSwgMSwgMiwgMl0sXFxuICAgICAgICBbMTEsIDIwMzksIDIsIDIsIDEsIDFdLFxcbiAgICAgICAgWzExLCAyMDQwLCAwLCAyLCAyLCAwXSxcXG4gICAgICAgIFsxMSwgMjA0MSwgMCwgMiwgMSwgMl0sXFxuICAgICAgICBbMTIsIDQwODQsIDEsIDAsIDIsIDJdLFxcbiAgICAgICAgWzEyLCA0MDg1LCAyLCAyLCAwLCAxXSxcXG4gICAgICAgIFsxMiwgNDA4NiwgMiwgMSwgMiwgMF0sXFxuICAgICAgICBbMTIsIDQwODcsIDIsIDIsIDIsIDBdLFxcbiAgICAgICAgWzEyLCA0MDg4LCAwLCAyLCAyLCAyXSxcXG4gICAgICAgIFsxMiwgNDA4OSwgMiwgMiwgMiwgMV0sXFxuICAgICAgICBbMTIsIDQwOTAsIDIsIDEsIDIsIDFdLFxcbiAgICAgICAgWzEyLCA0MDkxLCAxLCAyLCAxLCAyXSxcXG4gICAgICAgIFsxMiwgNDA5MiwgMSwgMiwgMiwgMl0sXFxuICAgICAgICBbMTMsIDgxODYsIDAsIDIsIDAsIDJdLFxcbiAgICAgICAgWzEzLCA4MTg3LCAyLCAwLCAyLCAwXSxcXG4gICAgICAgIFsxMywgODE4OCwgMSwgMiwgMCwgMl0sXFxuICAgICAgICBbMTQsIDE2Mzc4LCAyLCAwLCAyLCAxXSxcXG4gICAgICAgIFsxNCwgMTYzNzksIDIsIDEsIDEsIDJdLFxcbiAgICAgICAgWzE0LCAxNjM4MCwgMiwgMSwgMCwgMl0sXFxuICAgICAgICBbMTUsIDMyNzYyLCAyLCAyLCAyLCAyXSxcXG4gICAgICAgIFsxNSwgMzI3NjMsIDIsIDIsIDEsIDJdLFxcbiAgICAgICAgWzE1LCAzMjc2NCwgMiwgMSwgMiwgMl0sXFxuICAgICAgICBbMTUsIDMyNzY1LCAyLCAwLCAxLCAyXSxcXG4gICAgICAgIFsxNSwgMzI3NjYsIDIsIDAsIDAsIDJdLFxcbiAgICAgICAgWzE2LCA2NTUzNCwgMiwgMiwgMCwgMl0sXFxuICAgICAgICBbMTYsIDY1NTM1LCAyLCAwLCAyLCAyXVxcbiAgICBdO1xcbiAgICBcXG4gICAgY29uc3QgSENCNCA9IFtcXG4gICAgICAgIFs0LCAwLCAxLCAxLCAxLCAxXSxcXG4gICAgICAgIFs0LCAxLCAwLCAxLCAxLCAxXSxcXG4gICAgICAgIFs0LCAyLCAxLCAxLCAwLCAxXSxcXG4gICAgICAgIFs0LCAzLCAxLCAxLCAxLCAwXSxcXG4gICAgICAgIFs0LCA0LCAxLCAwLCAxLCAxXSxcXG4gICAgICAgIFs0LCA1LCAxLCAwLCAwLCAwXSxcXG4gICAgICAgIFs0LCA2LCAxLCAxLCAwLCAwXSxcXG4gICAgICAgIFs0LCA3LCAwLCAwLCAwLCAwXSxcXG4gICAgICAgIFs0LCA4LCAwLCAwLCAxLCAxXSxcXG4gICAgICAgIFs0LCA5LCAxLCAwLCAxLCAwXSxcXG4gICAgICAgIFs1LCAyMCwgMSwgMCwgMCwgMV0sXFxuICAgICAgICBbNSwgMjEsIDAsIDEsIDEsIDBdLFxcbiAgICAgICAgWzUsIDIyLCAwLCAwLCAwLCAxXSxcXG4gICAgICAgIFs1LCAyMywgMCwgMSwgMCwgMV0sXFxuICAgICAgICBbNSwgMjQsIDAsIDAsIDEsIDBdLFxcbiAgICAgICAgWzUsIDI1LCAwLCAxLCAwLCAwXSxcXG4gICAgICAgIFs3LCAxMDQsIDIsIDEsIDEsIDFdLFxcbiAgICAgICAgWzcsIDEwNSwgMSwgMSwgMiwgMV0sXFxuICAgICAgICBbNywgMTA2LCAxLCAyLCAxLCAxXSxcXG4gICAgICAgIFs3LCAxMDcsIDEsIDEsIDEsIDJdLFxcbiAgICAgICAgWzcsIDEwOCwgMiwgMSwgMSwgMF0sXFxuICAgICAgICBbNywgMTA5LCAyLCAxLCAwLCAxXSxcXG4gICAgICAgIFs3LCAxMTAsIDEsIDIsIDEsIDBdLFxcbiAgICAgICAgWzcsIDExMSwgMiwgMCwgMSwgMV0sXFxuICAgICAgICBbNywgMTEyLCAwLCAxLCAyLCAxXSxcXG4gICAgICAgIFs4LCAyMjYsIDAsIDEsIDEsIDJdLFxcbiAgICAgICAgWzgsIDIyNywgMSwgMSwgMiwgMF0sXFxuICAgICAgICBbOCwgMjI4LCAwLCAyLCAxLCAxXSxcXG4gICAgICAgIFs4LCAyMjksIDEsIDAsIDEsIDJdLFxcbiAgICAgICAgWzgsIDIzMCwgMSwgMiwgMCwgMV0sXFxuICAgICAgICBbOCwgMjMxLCAxLCAxLCAwLCAyXSxcXG4gICAgICAgIFs4LCAyMzIsIDEsIDAsIDIsIDFdLFxcbiAgICAgICAgWzgsIDIzMywgMiwgMSwgMCwgMF0sXFxuICAgICAgICBbOCwgMjM0LCAyLCAwLCAxLCAwXSxcXG4gICAgICAgIFs4LCAyMzUsIDEsIDIsIDAsIDBdLFxcbiAgICAgICAgWzgsIDIzNiwgMiwgMCwgMCwgMV0sXFxuICAgICAgICBbOCwgMjM3LCAwLCAxLCAwLCAyXSxcXG4gICAgICAgIFs4LCAyMzgsIDAsIDIsIDEsIDBdLFxcbiAgICAgICAgWzgsIDIzOSwgMCwgMCwgMSwgMl0sXFxuICAgICAgICBbOCwgMjQwLCAwLCAxLCAyLCAwXSxcXG4gICAgICAgIFs4LCAyNDEsIDAsIDIsIDAsIDFdLFxcbiAgICAgICAgWzgsIDI0MiwgMSwgMCwgMCwgMl0sXFxuICAgICAgICBbOCwgMjQzLCAwLCAwLCAyLCAxXSxcXG4gICAgICAgIFs4LCAyNDQsIDEsIDAsIDIsIDBdLFxcbiAgICAgICAgWzgsIDI0NSwgMiwgMCwgMCwgMF0sXFxuICAgICAgICBbOCwgMjQ2LCAwLCAwLCAwLCAyXSxcXG4gICAgICAgIFs5LCA0OTQsIDAsIDIsIDAsIDBdLFxcbiAgICAgICAgWzksIDQ5NSwgMCwgMCwgMiwgMF0sXFxuICAgICAgICBbOSwgNDk2LCAxLCAyLCAyLCAxXSxcXG4gICAgICAgIFs5LCA0OTcsIDIsIDIsIDEsIDFdLFxcbiAgICAgICAgWzksIDQ5OCwgMiwgMSwgMiwgMV0sXFxuICAgICAgICBbOSwgNDk5LCAxLCAxLCAyLCAyXSxcXG4gICAgICAgIFs5LCA1MDAsIDEsIDIsIDEsIDJdLFxcbiAgICAgICAgWzksIDUwMSwgMiwgMSwgMSwgMl0sXFxuICAgICAgICBbMTAsIDEwMDQsIDEsIDIsIDIsIDBdLFxcbiAgICAgICAgWzEwLCAxMDA1LCAyLCAyLCAxLCAwXSxcXG4gICAgICAgIFsxMCwgMTAwNiwgMiwgMSwgMiwgMF0sXFxuICAgICAgICBbMTAsIDEwMDcsIDAsIDIsIDIsIDFdLFxcbiAgICAgICAgWzEwLCAxMDA4LCAwLCAxLCAyLCAyXSxcXG4gICAgICAgIFsxMCwgMTAwOSwgMiwgMiwgMCwgMV0sXFxuICAgICAgICBbMTAsIDEwMTAsIDAsIDIsIDEsIDJdLFxcbiAgICAgICAgWzEwLCAxMDExLCAyLCAwLCAyLCAxXSxcXG4gICAgICAgIFsxMCwgMTAxMiwgMSwgMCwgMiwgMl0sXFxuICAgICAgICBbMTAsIDEwMTMsIDIsIDIsIDIsIDFdLFxcbiAgICAgICAgWzEwLCAxMDE0LCAxLCAyLCAwLCAyXSxcXG4gICAgICAgIFsxMCwgMTAxNSwgMiwgMCwgMSwgMl0sXFxuICAgICAgICBbMTAsIDEwMTYsIDIsIDEsIDAsIDJdLFxcbiAgICAgICAgWzEwLCAxMDE3LCAxLCAyLCAyLCAyXSxcXG4gICAgICAgIFsxMSwgMjAzNiwgMiwgMSwgMiwgMl0sXFxuICAgICAgICBbMTEsIDIwMzcsIDIsIDIsIDEsIDJdLFxcbiAgICAgICAgWzExLCAyMDM4LCAwLCAyLCAyLCAwXSxcXG4gICAgICAgIFsxMSwgMjAzOSwgMiwgMiwgMCwgMF0sXFxuICAgICAgICBbMTEsIDIwNDAsIDAsIDAsIDIsIDJdLFxcbiAgICAgICAgWzExLCAyMDQxLCAyLCAwLCAyLCAwXSxcXG4gICAgICAgIFsxMSwgMjA0MiwgMCwgMiwgMCwgMl0sXFxuICAgICAgICBbMTEsIDIwNDMsIDIsIDAsIDAsIDJdLFxcbiAgICAgICAgWzExLCAyMDQ0LCAyLCAyLCAyLCAyXSxcXG4gICAgICAgIFsxMSwgMjA0NSwgMCwgMiwgMiwgMl0sXFxuICAgICAgICBbMTEsIDIwNDYsIDIsIDIsIDIsIDBdLFxcbiAgICAgICAgWzEyLCA0MDk0LCAyLCAyLCAwLCAyXSxcXG4gICAgICAgIFsxMiwgNDA5NSwgMiwgMCwgMiwgMl1cXG4gICAgXTtcXG4gICAgXFxuICAgIGNvbnN0IEhDQjUgPSBbXFxuICAgICAgICBbMSwgMCwgMCwgMF0sXFxuICAgICAgICBbNCwgOCwgLTEsIDBdLFxcbiAgICAgICAgWzQsIDksIDEsIDBdLFxcbiAgICAgICAgWzQsIDEwLCAwLCAxXSxcXG4gICAgICAgIFs0LCAxMSwgMCwgLTFdLFxcbiAgICAgICAgWzUsIDI0LCAxLCAtMV0sXFxuICAgICAgICBbNSwgMjUsIC0xLCAxXSxcXG4gICAgICAgIFs1LCAyNiwgLTEsIC0xXSxcXG4gICAgICAgIFs1LCAyNywgMSwgMV0sXFxuICAgICAgICBbNywgMTEyLCAtMiwgMF0sXFxuICAgICAgICBbNywgMTEzLCAwLCAyXSxcXG4gICAgICAgIFs3LCAxMTQsIDIsIDBdLFxcbiAgICAgICAgWzcsIDExNSwgMCwgLTJdLFxcbiAgICAgICAgWzgsIDIzMiwgLTIsIC0xXSxcXG4gICAgICAgIFs4LCAyMzMsIDIsIDFdLFxcbiAgICAgICAgWzgsIDIzNCwgLTEsIC0yXSxcXG4gICAgICAgIFs4LCAyMzUsIDEsIDJdLFxcbiAgICAgICAgWzgsIDIzNiwgLTIsIDFdLFxcbiAgICAgICAgWzgsIDIzNywgMiwgLTFdLFxcbiAgICAgICAgWzgsIDIzOCwgLTEsIDJdLFxcbiAgICAgICAgWzgsIDIzOSwgMSwgLTJdLFxcbiAgICAgICAgWzgsIDI0MCwgLTMsIDBdLFxcbiAgICAgICAgWzgsIDI0MSwgMywgMF0sXFxuICAgICAgICBbOCwgMjQyLCAwLCAtM10sXFxuICAgICAgICBbOCwgMjQzLCAwLCAzXSxcXG4gICAgICAgIFs5LCA0ODgsIC0zLCAtMV0sXFxuICAgICAgICBbOSwgNDg5LCAxLCAzXSxcXG4gICAgICAgIFs5LCA0OTAsIDMsIDFdLFxcbiAgICAgICAgWzksIDQ5MSwgLTEsIC0zXSxcXG4gICAgICAgIFs5LCA0OTIsIC0zLCAxXSxcXG4gICAgICAgIFs5LCA0OTMsIDMsIC0xXSxcXG4gICAgICAgIFs5LCA0OTQsIDEsIC0zXSxcXG4gICAgICAgIFs5LCA0OTUsIC0xLCAzXSxcXG4gICAgICAgIFs5LCA0OTYsIC0yLCAyXSxcXG4gICAgICAgIFs5LCA0OTcsIDIsIDJdLFxcbiAgICAgICAgWzksIDQ5OCwgLTIsIC0yXSxcXG4gICAgICAgIFs5LCA0OTksIDIsIC0yXSxcXG4gICAgICAgIFsxMCwgMTAwMCwgLTMsIC0yXSxcXG4gICAgICAgIFsxMCwgMTAwMSwgMywgLTJdLFxcbiAgICAgICAgWzEwLCAxMDAyLCAtMiwgM10sXFxuICAgICAgICBbMTAsIDEwMDMsIDIsIC0zXSxcXG4gICAgICAgIFsxMCwgMTAwNCwgMywgMl0sXFxuICAgICAgICBbMTAsIDEwMDUsIDIsIDNdLFxcbiAgICAgICAgWzEwLCAxMDA2LCAtMywgMl0sXFxuICAgICAgICBbMTAsIDEwMDcsIC0yLCAtM10sXFxuICAgICAgICBbMTAsIDEwMDgsIDAsIC00XSxcXG4gICAgICAgIFsxMCwgMTAwOSwgLTQsIDBdLFxcbiAgICAgICAgWzEwLCAxMDEwLCA0LCAxXSxcXG4gICAgICAgIFsxMCwgMTAxMSwgNCwgMF0sXFxuICAgICAgICBbMTEsIDIwMjQsIC00LCAtMV0sXFxuICAgICAgICBbMTEsIDIwMjUsIDAsIDRdLFxcbiAgICAgICAgWzExLCAyMDI2LCA0LCAtMV0sXFxuICAgICAgICBbMTEsIDIwMjcsIC0xLCAtNF0sXFxuICAgICAgICBbMTEsIDIwMjgsIDEsIDRdLFxcbiAgICAgICAgWzExLCAyMDI5LCAtMSwgNF0sXFxuICAgICAgICBbMTEsIDIwMzAsIC00LCAxXSxcXG4gICAgICAgIFsxMSwgMjAzMSwgMSwgLTRdLFxcbiAgICAgICAgWzExLCAyMDMyLCAzLCAtM10sXFxuICAgICAgICBbMTEsIDIwMzMsIC0zLCAtM10sXFxuICAgICAgICBbMTEsIDIwMzQsIC0zLCAzXSxcXG4gICAgICAgIFsxMSwgMjAzNSwgLTIsIDRdLFxcbiAgICAgICAgWzExLCAyMDM2LCAtNCwgLTJdLFxcbiAgICAgICAgWzExLCAyMDM3LCA0LCAyXSxcXG4gICAgICAgIFsxMSwgMjAzOCwgMiwgLTRdLFxcbiAgICAgICAgWzExLCAyMDM5LCAyLCA0XSxcXG4gICAgICAgIFsxMSwgMjA0MCwgMywgM10sXFxuICAgICAgICBbMTEsIDIwNDEsIC00LCAyXSxcXG4gICAgICAgIFsxMiwgNDA4NCwgLTIsIC00XSxcXG4gICAgICAgIFsxMiwgNDA4NSwgNCwgLTJdLFxcbiAgICAgICAgWzEyLCA0MDg2LCAzLCAtNF0sXFxuICAgICAgICBbMTIsIDQwODcsIC00LCAtM10sXFxuICAgICAgICBbMTIsIDQwODgsIC00LCAzXSxcXG4gICAgICAgIFsxMiwgNDA4OSwgMywgNF0sXFxuICAgICAgICBbMTIsIDQwOTAsIC0zLCA0XSxcXG4gICAgICAgIFsxMiwgNDA5MSwgNCwgM10sXFxuICAgICAgICBbMTIsIDQwOTIsIDQsIC0zXSxcXG4gICAgICAgIFsxMiwgNDA5MywgLTMsIC00XSxcXG4gICAgICAgIFsxMywgODE4OCwgNCwgLTRdLFxcbiAgICAgICAgWzEzLCA4MTg5LCAtNCwgNF0sXFxuICAgICAgICBbMTMsIDgxOTAsIDQsIDRdLFxcbiAgICAgICAgWzEzLCA4MTkxLCAtNCwgLTRdXFxuICAgIF07XFxuICAgIFxcbiAgICBjb25zdCBIQ0I2ID0gW1xcbiAgICAgICAgWzQsIDAsIDAsIDBdLFxcbiAgICAgICAgWzQsIDEsIDEsIDBdLFxcbiAgICAgICAgWzQsIDIsIDAsIC0xXSxcXG4gICAgICAgIFs0LCAzLCAwLCAxXSxcXG4gICAgICAgIFs0LCA0LCAtMSwgMF0sXFxuICAgICAgICBbNCwgNSwgMSwgMV0sXFxuICAgICAgICBbNCwgNiwgLTEsIDFdLFxcbiAgICAgICAgWzQsIDcsIDEsIC0xXSxcXG4gICAgICAgIFs0LCA4LCAtMSwgLTFdLFxcbiAgICAgICAgWzYsIDM2LCAyLCAtMV0sXFxuICAgICAgICBbNiwgMzcsIDIsIDFdLFxcbiAgICAgICAgWzYsIDM4LCAtMiwgMV0sXFxuICAgICAgICBbNiwgMzksIC0yLCAtMV0sXFxuICAgICAgICBbNiwgNDAsIC0yLCAwXSxcXG4gICAgICAgIFs2LCA0MSwgLTEsIDJdLFxcbiAgICAgICAgWzYsIDQyLCAyLCAwXSxcXG4gICAgICAgIFs2LCA0MywgMSwgLTJdLFxcbiAgICAgICAgWzYsIDQ0LCAxLCAyXSxcXG4gICAgICAgIFs2LCA0NSwgMCwgLTJdLFxcbiAgICAgICAgWzYsIDQ2LCAtMSwgLTJdLFxcbiAgICAgICAgWzYsIDQ3LCAwLCAyXSxcXG4gICAgICAgIFs2LCA0OCwgMiwgLTJdLFxcbiAgICAgICAgWzYsIDQ5LCAtMiwgMl0sXFxuICAgICAgICBbNiwgNTAsIC0yLCAtMl0sXFxuICAgICAgICBbNiwgNTEsIDIsIDJdLFxcbiAgICAgICAgWzcsIDEwNCwgLTMsIDFdLFxcbiAgICAgICAgWzcsIDEwNSwgMywgMV0sXFxuICAgICAgICBbNywgMTA2LCAzLCAtMV0sXFxuICAgICAgICBbNywgMTA3LCAtMSwgM10sXFxuICAgICAgICBbNywgMTA4LCAtMywgLTFdLFxcbiAgICAgICAgWzcsIDEwOSwgMSwgM10sXFxuICAgICAgICBbNywgMTEwLCAxLCAtM10sXFxuICAgICAgICBbNywgMTExLCAtMSwgLTNdLFxcbiAgICAgICAgWzcsIDExMiwgMywgMF0sXFxuICAgICAgICBbNywgMTEzLCAtMywgMF0sXFxuICAgICAgICBbNywgMTE0LCAwLCAtM10sXFxuICAgICAgICBbNywgMTE1LCAwLCAzXSxcXG4gICAgICAgIFs3LCAxMTYsIDMsIDJdLFxcbiAgICAgICAgWzgsIDIzNCwgLTMsIC0yXSxcXG4gICAgICAgIFs4LCAyMzUsIC0yLCAzXSxcXG4gICAgICAgIFs4LCAyMzYsIDIsIDNdLFxcbiAgICAgICAgWzgsIDIzNywgMywgLTJdLFxcbiAgICAgICAgWzgsIDIzOCwgMiwgLTNdLFxcbiAgICAgICAgWzgsIDIzOSwgLTIsIC0zXSxcXG4gICAgICAgIFs4LCAyNDAsIC0zLCAyXSxcXG4gICAgICAgIFs4LCAyNDEsIDMsIDNdLFxcbiAgICAgICAgWzksIDQ4NCwgMywgLTNdLFxcbiAgICAgICAgWzksIDQ4NSwgLTMsIC0zXSxcXG4gICAgICAgIFs5LCA0ODYsIC0zLCAzXSxcXG4gICAgICAgIFs5LCA0ODcsIDEsIC00XSxcXG4gICAgICAgIFs5LCA0ODgsIC0xLCAtNF0sXFxuICAgICAgICBbOSwgNDg5LCA0LCAxXSxcXG4gICAgICAgIFs5LCA0OTAsIC00LCAxXSxcXG4gICAgICAgIFs5LCA0OTEsIC00LCAtMV0sXFxuICAgICAgICBbOSwgNDkyLCAxLCA0XSxcXG4gICAgICAgIFs5LCA0OTMsIDQsIC0xXSxcXG4gICAgICAgIFs5LCA0OTQsIC0xLCA0XSxcXG4gICAgICAgIFs5LCA0OTUsIDAsIC00XSxcXG4gICAgICAgIFs5LCA0OTYsIC00LCAyXSxcXG4gICAgICAgIFs5LCA0OTcsIC00LCAtMl0sXFxuICAgICAgICBbOSwgNDk4LCAyLCA0XSxcXG4gICAgICAgIFs5LCA0OTksIC0yLCAtNF0sXFxuICAgICAgICBbOSwgNTAwLCAtNCwgMF0sXFxuICAgICAgICBbOSwgNTAxLCA0LCAyXSxcXG4gICAgICAgIFs5LCA1MDIsIDQsIC0yXSxcXG4gICAgICAgIFs5LCA1MDMsIC0yLCA0XSxcXG4gICAgICAgIFs5LCA1MDQsIDQsIDBdLFxcbiAgICAgICAgWzksIDUwNSwgMiwgLTRdLFxcbiAgICAgICAgWzksIDUwNiwgMCwgNF0sXFxuICAgICAgICBbMTAsIDEwMTQsIC0zLCAtNF0sXFxuICAgICAgICBbMTAsIDEwMTUsIC0zLCA0XSxcXG4gICAgICAgIFsxMCwgMTAxNiwgMywgLTRdLFxcbiAgICAgICAgWzEwLCAxMDE3LCA0LCAtM10sXFxuICAgICAgICBbMTAsIDEwMTgsIDMsIDRdLFxcbiAgICAgICAgWzEwLCAxMDE5LCA0LCAzXSxcXG4gICAgICAgIFsxMCwgMTAyMCwgLTQsIDNdLFxcbiAgICAgICAgWzEwLCAxMDIxLCAtNCwgLTNdLFxcbiAgICAgICAgWzExLCAyMDQ0LCA0LCA0XSxcXG4gICAgICAgIFsxMSwgMjA0NSwgLTQsIDRdLFxcbiAgICAgICAgWzExLCAyMDQ2LCAtNCwgLTRdLFxcbiAgICAgICAgWzExLCAyMDQ3LCA0LCAtNF1cXG4gICAgXTtcXG4gICAgXFxuICAgIGNvbnN0IEhDQjcgPSBbXFxuICAgICAgICBbMSwgMCwgMCwgMF0sXFxuICAgICAgICBbMywgNCwgMSwgMF0sXFxuICAgICAgICBbMywgNSwgMCwgMV0sXFxuICAgICAgICBbNCwgMTIsIDEsIDFdLFxcbiAgICAgICAgWzYsIDUyLCAyLCAxXSxcXG4gICAgICAgIFs2LCA1MywgMSwgMl0sXFxuICAgICAgICBbNiwgNTQsIDIsIDBdLFxcbiAgICAgICAgWzYsIDU1LCAwLCAyXSxcXG4gICAgICAgIFs3LCAxMTIsIDMsIDFdLFxcbiAgICAgICAgWzcsIDExMywgMSwgM10sXFxuICAgICAgICBbNywgMTE0LCAyLCAyXSxcXG4gICAgICAgIFs3LCAxMTUsIDMsIDBdLFxcbiAgICAgICAgWzcsIDExNiwgMCwgM10sXFxuICAgICAgICBbOCwgMjM0LCAyLCAzXSxcXG4gICAgICAgIFs4LCAyMzUsIDMsIDJdLFxcbiAgICAgICAgWzgsIDIzNiwgMSwgNF0sXFxuICAgICAgICBbOCwgMjM3LCA0LCAxXSxcXG4gICAgICAgIFs4LCAyMzgsIDEsIDVdLFxcbiAgICAgICAgWzgsIDIzOSwgNSwgMV0sXFxuICAgICAgICBbOCwgMjQwLCAzLCAzXSxcXG4gICAgICAgIFs4LCAyNDEsIDIsIDRdLFxcbiAgICAgICAgWzgsIDI0MiwgMCwgNF0sXFxuICAgICAgICBbOCwgMjQzLCA0LCAwXSxcXG4gICAgICAgIFs5LCA0ODgsIDQsIDJdLFxcbiAgICAgICAgWzksIDQ4OSwgMiwgNV0sXFxuICAgICAgICBbOSwgNDkwLCA1LCAyXSxcXG4gICAgICAgIFs5LCA0OTEsIDAsIDVdLFxcbiAgICAgICAgWzksIDQ5MiwgNiwgMV0sXFxuICAgICAgICBbOSwgNDkzLCA1LCAwXSxcXG4gICAgICAgIFs5LCA0OTQsIDEsIDZdLFxcbiAgICAgICAgWzksIDQ5NSwgNCwgM10sXFxuICAgICAgICBbOSwgNDk2LCAzLCA1XSxcXG4gICAgICAgIFs5LCA0OTcsIDMsIDRdLFxcbiAgICAgICAgWzksIDQ5OCwgNSwgM10sXFxuICAgICAgICBbOSwgNDk5LCAyLCA2XSxcXG4gICAgICAgIFs5LCA1MDAsIDYsIDJdLFxcbiAgICAgICAgWzksIDUwMSwgMSwgN10sXFxuICAgICAgICBbMTAsIDEwMDQsIDMsIDZdLFxcbiAgICAgICAgWzEwLCAxMDA1LCAwLCA2XSxcXG4gICAgICAgIFsxMCwgMTAwNiwgNiwgMF0sXFxuICAgICAgICBbMTAsIDEwMDcsIDQsIDRdLFxcbiAgICAgICAgWzEwLCAxMDA4LCA3LCAxXSxcXG4gICAgICAgIFsxMCwgMTAwOSwgNCwgNV0sXFxuICAgICAgICBbMTAsIDEwMTAsIDcsIDJdLFxcbiAgICAgICAgWzEwLCAxMDExLCA1LCA0XSxcXG4gICAgICAgIFsxMCwgMTAxMiwgNiwgM10sXFxuICAgICAgICBbMTAsIDEwMTMsIDIsIDddLFxcbiAgICAgICAgWzEwLCAxMDE0LCA3LCAzXSxcXG4gICAgICAgIFsxMCwgMTAxNSwgNiwgNF0sXFxuICAgICAgICBbMTAsIDEwMTYsIDUsIDVdLFxcbiAgICAgICAgWzEwLCAxMDE3LCA0LCA2XSxcXG4gICAgICAgIFsxMCwgMTAxOCwgMywgN10sXFxuICAgICAgICBbMTEsIDIwMzgsIDcsIDBdLFxcbiAgICAgICAgWzExLCAyMDM5LCAwLCA3XSxcXG4gICAgICAgIFsxMSwgMjA0MCwgNiwgNV0sXFxuICAgICAgICBbMTEsIDIwNDEsIDUsIDZdLFxcbiAgICAgICAgWzExLCAyMDQyLCA3LCA0XSxcXG4gICAgICAgIFsxMSwgMjA0MywgNCwgN10sXFxuICAgICAgICBbMTEsIDIwNDQsIDUsIDddLFxcbiAgICAgICAgWzExLCAyMDQ1LCA3LCA1XSxcXG4gICAgICAgIFsxMiwgNDA5MiwgNywgNl0sXFxuICAgICAgICBbMTIsIDQwOTMsIDYsIDZdLFxcbiAgICAgICAgWzEyLCA0MDk0LCA2LCA3XSxcXG4gICAgICAgIFsxMiwgNDA5NSwgNywgN11cXG4gICAgXTtcXG4gICAgXFxuICAgIGNvbnN0IEhDQjggPSBbXFxuICAgICAgICBbMywgMCwgMSwgMV0sXFxuICAgICAgICBbNCwgMiwgMiwgMV0sXFxuICAgICAgICBbNCwgMywgMSwgMF0sXFxuICAgICAgICBbNCwgNCwgMSwgMl0sXFxuICAgICAgICBbNCwgNSwgMCwgMV0sXFxuICAgICAgICBbNCwgNiwgMiwgMl0sXFxuICAgICAgICBbNSwgMTQsIDAsIDBdLFxcbiAgICAgICAgWzUsIDE1LCAyLCAwXSxcXG4gICAgICAgIFs1LCAxNiwgMCwgMl0sXFxuICAgICAgICBbNSwgMTcsIDMsIDFdLFxcbiAgICAgICAgWzUsIDE4LCAxLCAzXSxcXG4gICAgICAgIFs1LCAxOSwgMywgMl0sXFxuICAgICAgICBbNSwgMjAsIDIsIDNdLFxcbiAgICAgICAgWzYsIDQyLCAzLCAzXSxcXG4gICAgICAgIFs2LCA0MywgNCwgMV0sXFxuICAgICAgICBbNiwgNDQsIDEsIDRdLFxcbiAgICAgICAgWzYsIDQ1LCA0LCAyXSxcXG4gICAgICAgIFs2LCA0NiwgMiwgNF0sXFxuICAgICAgICBbNiwgNDcsIDMsIDBdLFxcbiAgICAgICAgWzYsIDQ4LCAwLCAzXSxcXG4gICAgICAgIFs2LCA0OSwgNCwgM10sXFxuICAgICAgICBbNiwgNTAsIDMsIDRdLFxcbiAgICAgICAgWzYsIDUxLCA1LCAyXSxcXG4gICAgICAgIFs3LCAxMDQsIDUsIDFdLFxcbiAgICAgICAgWzcsIDEwNSwgMiwgNV0sXFxuICAgICAgICBbNywgMTA2LCAxLCA1XSxcXG4gICAgICAgIFs3LCAxMDcsIDUsIDNdLFxcbiAgICAgICAgWzcsIDEwOCwgMywgNV0sXFxuICAgICAgICBbNywgMTA5LCA0LCA0XSxcXG4gICAgICAgIFs3LCAxMTAsIDUsIDRdLFxcbiAgICAgICAgWzcsIDExMSwgMCwgNF0sXFxuICAgICAgICBbNywgMTEyLCA0LCA1XSxcXG4gICAgICAgIFs3LCAxMTMsIDQsIDBdLFxcbiAgICAgICAgWzcsIDExNCwgMiwgNl0sXFxuICAgICAgICBbNywgMTE1LCA2LCAyXSxcXG4gICAgICAgIFs3LCAxMTYsIDYsIDFdLFxcbiAgICAgICAgWzcsIDExNywgMSwgNl0sXFxuICAgICAgICBbOCwgMjM2LCAzLCA2XSxcXG4gICAgICAgIFs4LCAyMzcsIDYsIDNdLFxcbiAgICAgICAgWzgsIDIzOCwgNSwgNV0sXFxuICAgICAgICBbOCwgMjM5LCA1LCAwXSxcXG4gICAgICAgIFs4LCAyNDAsIDYsIDRdLFxcbiAgICAgICAgWzgsIDI0MSwgMCwgNV0sXFxuICAgICAgICBbOCwgMjQyLCA0LCA2XSxcXG4gICAgICAgIFs4LCAyNDMsIDcsIDFdLFxcbiAgICAgICAgWzgsIDI0NCwgNywgMl0sXFxuICAgICAgICBbOCwgMjQ1LCAyLCA3XSxcXG4gICAgICAgIFs4LCAyNDYsIDYsIDVdLFxcbiAgICAgICAgWzgsIDI0NywgNywgM10sXFxuICAgICAgICBbOCwgMjQ4LCAxLCA3XSxcXG4gICAgICAgIFs4LCAyNDksIDUsIDZdLFxcbiAgICAgICAgWzgsIDI1MCwgMywgN10sXFxuICAgICAgICBbOSwgNTAyLCA2LCA2XSxcXG4gICAgICAgIFs5LCA1MDMsIDcsIDRdLFxcbiAgICAgICAgWzksIDUwNCwgNiwgMF0sXFxuICAgICAgICBbOSwgNTA1LCA0LCA3XSxcXG4gICAgICAgIFs5LCA1MDYsIDAsIDZdLFxcbiAgICAgICAgWzksIDUwNywgNywgNV0sXFxuICAgICAgICBbOSwgNTA4LCA3LCA2XSxcXG4gICAgICAgIFs5LCA1MDksIDYsIDddLFxcbiAgICAgICAgWzEwLCAxMDIwLCA1LCA3XSxcXG4gICAgICAgIFsxMCwgMTAyMSwgNywgMF0sXFxuICAgICAgICBbMTAsIDEwMjIsIDAsIDddLFxcbiAgICAgICAgWzEwLCAxMDIzLCA3LCA3XVxcbiAgICBdO1xcbiAgICBcXG4gICAgY29uc3QgSENCOSA9IFtcXG4gICAgICAgIFsxLCAwLCAwLCAwXSxcXG4gICAgICAgIFszLCA0LCAxLCAwXSxcXG4gICAgICAgIFszLCA1LCAwLCAxXSxcXG4gICAgICAgIFs0LCAxMiwgMSwgMV0sXFxuICAgICAgICBbNiwgNTIsIDIsIDFdLFxcbiAgICAgICAgWzYsIDUzLCAxLCAyXSxcXG4gICAgICAgIFs2LCA1NCwgMiwgMF0sXFxuICAgICAgICBbNiwgNTUsIDAsIDJdLFxcbiAgICAgICAgWzcsIDExMiwgMywgMV0sXFxuICAgICAgICBbNywgMTEzLCAyLCAyXSxcXG4gICAgICAgIFs3LCAxMTQsIDEsIDNdLFxcbiAgICAgICAgWzgsIDIzMCwgMywgMF0sXFxuICAgICAgICBbOCwgMjMxLCAwLCAzXSxcXG4gICAgICAgIFs4LCAyMzIsIDIsIDNdLFxcbiAgICAgICAgWzgsIDIzMywgMywgMl0sXFxuICAgICAgICBbOCwgMjM0LCAxLCA0XSxcXG4gICAgICAgIFs4LCAyMzUsIDQsIDFdLFxcbiAgICAgICAgWzgsIDIzNiwgMiwgNF0sXFxuICAgICAgICBbOCwgMjM3LCAxLCA1XSxcXG4gICAgICAgIFs5LCA0NzYsIDQsIDJdLFxcbiAgICAgICAgWzksIDQ3NywgMywgM10sXFxuICAgICAgICBbOSwgNDc4LCAwLCA0XSxcXG4gICAgICAgIFs5LCA0NzksIDQsIDBdLFxcbiAgICAgICAgWzksIDQ4MCwgNSwgMV0sXFxuICAgICAgICBbOSwgNDgxLCAyLCA1XSxcXG4gICAgICAgIFs5LCA0ODIsIDEsIDZdLFxcbiAgICAgICAgWzksIDQ4MywgMywgNF0sXFxuICAgICAgICBbOSwgNDg0LCA1LCAyXSxcXG4gICAgICAgIFs5LCA0ODUsIDYsIDFdLFxcbiAgICAgICAgWzksIDQ4NiwgNCwgM10sXFxuICAgICAgICBbMTAsIDk3NCwgMCwgNV0sXFxuICAgICAgICBbMTAsIDk3NSwgMiwgNl0sXFxuICAgICAgICBbMTAsIDk3NiwgNSwgMF0sXFxuICAgICAgICBbMTAsIDk3NywgMSwgN10sXFxuICAgICAgICBbMTAsIDk3OCwgMywgNV0sXFxuICAgICAgICBbMTAsIDk3OSwgMSwgOF0sXFxuICAgICAgICBbMTAsIDk4MCwgOCwgMV0sXFxuICAgICAgICBbMTAsIDk4MSwgNCwgNF0sXFxuICAgICAgICBbMTAsIDk4MiwgNSwgM10sXFxuICAgICAgICBbMTAsIDk4MywgNiwgMl0sXFxuICAgICAgICBbMTAsIDk4NCwgNywgMV0sXFxuICAgICAgICBbMTAsIDk4NSwgMCwgNl0sXFxuICAgICAgICBbMTAsIDk4NiwgOCwgMl0sXFxuICAgICAgICBbMTAsIDk4NywgMiwgOF0sXFxuICAgICAgICBbMTAsIDk4OCwgMywgNl0sXFxuICAgICAgICBbMTAsIDk4OSwgMiwgN10sXFxuICAgICAgICBbMTAsIDk5MCwgNCwgNV0sXFxuICAgICAgICBbMTAsIDk5MSwgOSwgMV0sXFxuICAgICAgICBbMTAsIDk5MiwgMSwgOV0sXFxuICAgICAgICBbMTAsIDk5MywgNywgMl0sXFxuICAgICAgICBbMTEsIDE5ODgsIDYsIDBdLFxcbiAgICAgICAgWzExLCAxOTg5LCA1LCA0XSxcXG4gICAgICAgIFsxMSwgMTk5MCwgNiwgM10sXFxuICAgICAgICBbMTEsIDE5OTEsIDgsIDNdLFxcbiAgICAgICAgWzExLCAxOTkyLCAwLCA3XSxcXG4gICAgICAgIFsxMSwgMTk5MywgOSwgMl0sXFxuICAgICAgICBbMTEsIDE5OTQsIDMsIDhdLFxcbiAgICAgICAgWzExLCAxOTk1LCA0LCA2XSxcXG4gICAgICAgIFsxMSwgMTk5NiwgMywgN10sXFxuICAgICAgICBbMTEsIDE5OTcsIDAsIDhdLFxcbiAgICAgICAgWzExLCAxOTk4LCAxMCwgMV0sXFxuICAgICAgICBbMTEsIDE5OTksIDYsIDRdLFxcbiAgICAgICAgWzExLCAyMDAwLCAyLCA5XSxcXG4gICAgICAgIFsxMSwgMjAwMSwgNSwgNV0sXFxuICAgICAgICBbMTEsIDIwMDIsIDgsIDBdLFxcbiAgICAgICAgWzExLCAyMDAzLCA3LCAwXSxcXG4gICAgICAgIFsxMSwgMjAwNCwgNywgM10sXFxuICAgICAgICBbMTEsIDIwMDUsIDEwLCAyXSxcXG4gICAgICAgIFsxMSwgMjAwNiwgOSwgM10sXFxuICAgICAgICBbMTEsIDIwMDcsIDgsIDRdLFxcbiAgICAgICAgWzExLCAyMDA4LCAxLCAxMF0sXFxuICAgICAgICBbMTEsIDIwMDksIDcsIDRdLFxcbiAgICAgICAgWzExLCAyMDEwLCA2LCA1XSxcXG4gICAgICAgIFsxMSwgMjAxMSwgNSwgNl0sXFxuICAgICAgICBbMTEsIDIwMTIsIDQsIDhdLFxcbiAgICAgICAgWzExLCAyMDEzLCA0LCA3XSxcXG4gICAgICAgIFsxMSwgMjAxNCwgMywgOV0sXFxuICAgICAgICBbMTEsIDIwMTUsIDExLCAxXSxcXG4gICAgICAgIFsxMSwgMjAxNiwgNSwgOF0sXFxuICAgICAgICBbMTEsIDIwMTcsIDksIDBdLFxcbiAgICAgICAgWzExLCAyMDE4LCA4LCA1XSxcXG4gICAgICAgIFsxMiwgNDAzOCwgMTAsIDNdLFxcbiAgICAgICAgWzEyLCA0MDM5LCAyLCAxMF0sXFxuICAgICAgICBbMTIsIDQwNDAsIDAsIDldLFxcbiAgICAgICAgWzEyLCA0MDQxLCAxMSwgMl0sXFxuICAgICAgICBbMTIsIDQwNDIsIDksIDRdLFxcbiAgICAgICAgWzEyLCA0MDQzLCA2LCA2XSxcXG4gICAgICAgIFsxMiwgNDA0NCwgMTIsIDFdLFxcbiAgICAgICAgWzEyLCA0MDQ1LCA0LCA5XSxcXG4gICAgICAgIFsxMiwgNDA0NiwgOCwgNl0sXFxuICAgICAgICBbMTIsIDQwNDcsIDEsIDExXSxcXG4gICAgICAgIFsxMiwgNDA0OCwgOSwgNV0sXFxuICAgICAgICBbMTIsIDQwNDksIDEwLCA0XSxcXG4gICAgICAgIFsxMiwgNDA1MCwgNSwgN10sXFxuICAgICAgICBbMTIsIDQwNTEsIDcsIDVdLFxcbiAgICAgICAgWzEyLCA0MDUyLCAyLCAxMV0sXFxuICAgICAgICBbMTIsIDQwNTMsIDEsIDEyXSxcXG4gICAgICAgIFsxMiwgNDA1NCwgMTIsIDJdLFxcbiAgICAgICAgWzEyLCA0MDU1LCAxMSwgM10sXFxuICAgICAgICBbMTIsIDQwNTYsIDMsIDEwXSxcXG4gICAgICAgIFsxMiwgNDA1NywgNSwgOV0sXFxuICAgICAgICBbMTIsIDQwNTgsIDYsIDddLFxcbiAgICAgICAgWzEyLCA0MDU5LCA4LCA3XSxcXG4gICAgICAgIFsxMiwgNDA2MCwgMTEsIDRdLFxcbiAgICAgICAgWzEyLCA0MDYxLCAwLCAxMF0sXFxuICAgICAgICBbMTIsIDQwNjIsIDcsIDZdLFxcbiAgICAgICAgWzEyLCA0MDYzLCAxMiwgM10sXFxuICAgICAgICBbMTIsIDQwNjQsIDEwLCAwXSxcXG4gICAgICAgIFsxMiwgNDA2NSwgMTAsIDVdLFxcbiAgICAgICAgWzEyLCA0MDY2LCA0LCAxMF0sXFxuICAgICAgICBbMTIsIDQwNjcsIDYsIDhdLFxcbiAgICAgICAgWzEyLCA0MDY4LCAyLCAxMl0sXFxuICAgICAgICBbMTIsIDQwNjksIDksIDZdLFxcbiAgICAgICAgWzEyLCA0MDcwLCA5LCA3XSxcXG4gICAgICAgIFsxMiwgNDA3MSwgNCwgMTFdLFxcbiAgICAgICAgWzEyLCA0MDcyLCAxMSwgMF0sXFxuICAgICAgICBbMTIsIDQwNzMsIDYsIDldLFxcbiAgICAgICAgWzEyLCA0MDc0LCAzLCAxMV0sXFxuICAgICAgICBbMTIsIDQwNzUsIDUsIDEwXSxcXG4gICAgICAgIFsxMywgODE1MiwgOCwgOF0sXFxuICAgICAgICBbMTMsIDgxNTMsIDcsIDhdLFxcbiAgICAgICAgWzEzLCA4MTU0LCAxMiwgNV0sXFxuICAgICAgICBbMTMsIDgxNTUsIDMsIDEyXSxcXG4gICAgICAgIFsxMywgODE1NiwgMTEsIDVdLFxcbiAgICAgICAgWzEzLCA4MTU3LCA3LCA3XSxcXG4gICAgICAgIFsxMywgODE1OCwgMTIsIDRdLFxcbiAgICAgICAgWzEzLCA4MTU5LCAxMSwgNl0sXFxuICAgICAgICBbMTMsIDgxNjAsIDEwLCA2XSxcXG4gICAgICAgIFsxMywgODE2MSwgNCwgMTJdLFxcbiAgICAgICAgWzEzLCA4MTYyLCA3LCA5XSxcXG4gICAgICAgIFsxMywgODE2MywgNSwgMTFdLFxcbiAgICAgICAgWzEzLCA4MTY0LCAwLCAxMV0sXFxuICAgICAgICBbMTMsIDgxNjUsIDEyLCA2XSxcXG4gICAgICAgIFsxMywgODE2NiwgNiwgMTBdLFxcbiAgICAgICAgWzEzLCA4MTY3LCAxMiwgMF0sXFxuICAgICAgICBbMTMsIDgxNjgsIDEwLCA3XSxcXG4gICAgICAgIFsxMywgODE2OSwgNSwgMTJdLFxcbiAgICAgICAgWzEzLCA4MTcwLCA3LCAxMF0sXFxuICAgICAgICBbMTMsIDgxNzEsIDksIDhdLFxcbiAgICAgICAgWzEzLCA4MTcyLCAwLCAxMl0sXFxuICAgICAgICBbMTMsIDgxNzMsIDExLCA3XSxcXG4gICAgICAgIFsxMywgODE3NCwgOCwgOV0sXFxuICAgICAgICBbMTMsIDgxNzUsIDksIDldLFxcbiAgICAgICAgWzEzLCA4MTc2LCAxMCwgOF0sXFxuICAgICAgICBbMTMsIDgxNzcsIDcsIDExXSxcXG4gICAgICAgIFsxMywgODE3OCwgMTIsIDddLFxcbiAgICAgICAgWzEzLCA4MTc5LCA2LCAxMV0sXFxuICAgICAgICBbMTMsIDgxODAsIDgsIDExXSxcXG4gICAgICAgIFsxMywgODE4MSwgMTEsIDhdLFxcbiAgICAgICAgWzEzLCA4MTgyLCA3LCAxMl0sXFxuICAgICAgICBbMTMsIDgxODMsIDYsIDEyXSxcXG4gICAgICAgIFsxNCwgMTYzNjgsIDgsIDEwXSxcXG4gICAgICAgIFsxNCwgMTYzNjksIDEwLCA5XSxcXG4gICAgICAgIFsxNCwgMTYzNzAsIDgsIDEyXSxcXG4gICAgICAgIFsxNCwgMTYzNzEsIDksIDEwXSxcXG4gICAgICAgIFsxNCwgMTYzNzIsIDksIDExXSxcXG4gICAgICAgIFsxNCwgMTYzNzMsIDksIDEyXSxcXG4gICAgICAgIFsxNCwgMTYzNzQsIDEwLCAxMV0sXFxuICAgICAgICBbMTQsIDE2Mzc1LCAxMiwgOV0sXFxuICAgICAgICBbMTQsIDE2Mzc2LCAxMCwgMTBdLFxcbiAgICAgICAgWzE0LCAxNjM3NywgMTEsIDldLFxcbiAgICAgICAgWzE0LCAxNjM3OCwgMTIsIDhdLFxcbiAgICAgICAgWzE0LCAxNjM3OSwgMTEsIDEwXSxcXG4gICAgICAgIFsxNCwgMTYzODAsIDEyLCAxMF0sXFxuICAgICAgICBbMTQsIDE2MzgxLCAxMiwgMTFdLFxcbiAgICAgICAgWzE1LCAzMjc2NCwgMTAsIDEyXSxcXG4gICAgICAgIFsxNSwgMzI3NjUsIDExLCAxMV0sXFxuICAgICAgICBbMTUsIDMyNzY2LCAxMSwgMTJdLFxcbiAgICAgICAgWzE1LCAzMjc2NywgMTIsIDEyXVxcbiAgICBdO1xcbiAgICBcXG4gICAgY29uc3QgSENCMTAgPSBbXFxuICAgICAgICBbNCwgMCwgMSwgMV0sXFxuICAgICAgICBbNCwgMSwgMSwgMl0sXFxuICAgICAgICBbNCwgMiwgMiwgMV0sXFxuICAgICAgICBbNSwgNiwgMiwgMl0sXFxuICAgICAgICBbNSwgNywgMSwgMF0sXFxuICAgICAgICBbNSwgOCwgMCwgMV0sXFxuICAgICAgICBbNSwgOSwgMSwgM10sXFxuICAgICAgICBbNSwgMTAsIDMsIDJdLFxcbiAgICAgICAgWzUsIDExLCAzLCAxXSxcXG4gICAgICAgIFs1LCAxMiwgMiwgM10sXFxuICAgICAgICBbNSwgMTMsIDMsIDNdLFxcbiAgICAgICAgWzYsIDI4LCAyLCAwXSxcXG4gICAgICAgIFs2LCAyOSwgMCwgMl0sXFxuICAgICAgICBbNiwgMzAsIDIsIDRdLFxcbiAgICAgICAgWzYsIDMxLCA0LCAyXSxcXG4gICAgICAgIFs2LCAzMiwgMSwgNF0sXFxuICAgICAgICBbNiwgMzMsIDQsIDFdLFxcbiAgICAgICAgWzYsIDM0LCAwLCAwXSxcXG4gICAgICAgIFs2LCAzNSwgNCwgM10sXFxuICAgICAgICBbNiwgMzYsIDMsIDRdLFxcbiAgICAgICAgWzYsIDM3LCAzLCAwXSxcXG4gICAgICAgIFs2LCAzOCwgMCwgM10sXFxuICAgICAgICBbNiwgMzksIDQsIDRdLFxcbiAgICAgICAgWzYsIDQwLCAyLCA1XSxcXG4gICAgICAgIFs2LCA0MSwgNSwgMl0sXFxuICAgICAgICBbNywgODQsIDEsIDVdLFxcbiAgICAgICAgWzcsIDg1LCA1LCAxXSxcXG4gICAgICAgIFs3LCA4NiwgNSwgM10sXFxuICAgICAgICBbNywgODcsIDMsIDVdLFxcbiAgICAgICAgWzcsIDg4LCA1LCA0XSxcXG4gICAgICAgIFs3LCA4OSwgNCwgNV0sXFxuICAgICAgICBbNywgOTAsIDYsIDJdLFxcbiAgICAgICAgWzcsIDkxLCAyLCA2XSxcXG4gICAgICAgIFs3LCA5MiwgNiwgM10sXFxuICAgICAgICBbNywgOTMsIDQsIDBdLFxcbiAgICAgICAgWzcsIDk0LCA2LCAxXSxcXG4gICAgICAgIFs3LCA5NSwgMCwgNF0sXFxuICAgICAgICBbNywgOTYsIDEsIDZdLFxcbiAgICAgICAgWzcsIDk3LCAzLCA2XSxcXG4gICAgICAgIFs3LCA5OCwgNSwgNV0sXFxuICAgICAgICBbNywgOTksIDYsIDRdLFxcbiAgICAgICAgWzcsIDEwMCwgNCwgNl0sXFxuICAgICAgICBbOCwgMjAyLCA2LCA1XSxcXG4gICAgICAgIFs4LCAyMDMsIDcsIDJdLFxcbiAgICAgICAgWzgsIDIwNCwgMywgN10sXFxuICAgICAgICBbOCwgMjA1LCAyLCA3XSxcXG4gICAgICAgIFs4LCAyMDYsIDUsIDZdLFxcbiAgICAgICAgWzgsIDIwNywgOCwgMl0sXFxuICAgICAgICBbOCwgMjA4LCA3LCAzXSxcXG4gICAgICAgIFs4LCAyMDksIDUsIDBdLFxcbiAgICAgICAgWzgsIDIxMCwgNywgMV0sXFxuICAgICAgICBbOCwgMjExLCAwLCA1XSxcXG4gICAgICAgIFs4LCAyMTIsIDgsIDFdLFxcbiAgICAgICAgWzgsIDIxMywgMSwgN10sXFxuICAgICAgICBbOCwgMjE0LCA4LCAzXSxcXG4gICAgICAgIFs4LCAyMTUsIDcsIDRdLFxcbiAgICAgICAgWzgsIDIxNiwgNCwgN10sXFxuICAgICAgICBbOCwgMjE3LCAyLCA4XSxcXG4gICAgICAgIFs4LCAyMTgsIDYsIDZdLFxcbiAgICAgICAgWzgsIDIxOSwgNywgNV0sXFxuICAgICAgICBbOCwgMjIwLCAxLCA4XSxcXG4gICAgICAgIFs4LCAyMjEsIDMsIDhdLFxcbiAgICAgICAgWzgsIDIyMiwgOCwgNF0sXFxuICAgICAgICBbOCwgMjIzLCA0LCA4XSxcXG4gICAgICAgIFs4LCAyMjQsIDUsIDddLFxcbiAgICAgICAgWzgsIDIyNSwgOCwgNV0sXFxuICAgICAgICBbOCwgMjI2LCA1LCA4XSxcXG4gICAgICAgIFs5LCA0NTQsIDcsIDZdLFxcbiAgICAgICAgWzksIDQ1NSwgNiwgN10sXFxuICAgICAgICBbOSwgNDU2LCA5LCAyXSxcXG4gICAgICAgIFs5LCA0NTcsIDYsIDBdLFxcbiAgICAgICAgWzksIDQ1OCwgNiwgOF0sXFxuICAgICAgICBbOSwgNDU5LCA5LCAzXSxcXG4gICAgICAgIFs5LCA0NjAsIDMsIDldLFxcbiAgICAgICAgWzksIDQ2MSwgOSwgMV0sXFxuICAgICAgICBbOSwgNDYyLCAyLCA5XSxcXG4gICAgICAgIFs5LCA0NjMsIDAsIDZdLFxcbiAgICAgICAgWzksIDQ2NCwgOCwgNl0sXFxuICAgICAgICBbOSwgNDY1LCA5LCA0XSxcXG4gICAgICAgIFs5LCA0NjYsIDQsIDldLFxcbiAgICAgICAgWzksIDQ2NywgMTAsIDJdLFxcbiAgICAgICAgWzksIDQ2OCwgMSwgOV0sXFxuICAgICAgICBbOSwgNDY5LCA3LCA3XSxcXG4gICAgICAgIFs5LCA0NzAsIDgsIDddLFxcbiAgICAgICAgWzksIDQ3MSwgOSwgNV0sXFxuICAgICAgICBbOSwgNDcyLCA3LCA4XSxcXG4gICAgICAgIFs5LCA0NzMsIDEwLCAzXSxcXG4gICAgICAgIFs5LCA0NzQsIDUsIDldLFxcbiAgICAgICAgWzksIDQ3NSwgMTAsIDRdLFxcbiAgICAgICAgWzksIDQ3NiwgMiwgMTBdLFxcbiAgICAgICAgWzksIDQ3NywgMTAsIDFdLFxcbiAgICAgICAgWzksIDQ3OCwgMywgMTBdLFxcbiAgICAgICAgWzksIDQ3OSwgOSwgNl0sXFxuICAgICAgICBbOSwgNDgwLCA2LCA5XSxcXG4gICAgICAgIFs5LCA0ODEsIDgsIDBdLFxcbiAgICAgICAgWzksIDQ4MiwgNCwgMTBdLFxcbiAgICAgICAgWzksIDQ4MywgNywgMF0sXFxuICAgICAgICBbOSwgNDg0LCAxMSwgMl0sXFxuICAgICAgICBbMTAsIDk3MCwgNywgOV0sXFxuICAgICAgICBbMTAsIDk3MSwgMTEsIDNdLFxcbiAgICAgICAgWzEwLCA5NzIsIDEwLCA2XSxcXG4gICAgICAgIFsxMCwgOTczLCAxLCAxMF0sXFxuICAgICAgICBbMTAsIDk3NCwgMTEsIDFdLFxcbiAgICAgICAgWzEwLCA5NzUsIDksIDddLFxcbiAgICAgICAgWzEwLCA5NzYsIDAsIDddLFxcbiAgICAgICAgWzEwLCA5NzcsIDgsIDhdLFxcbiAgICAgICAgWzEwLCA5NzgsIDEwLCA1XSxcXG4gICAgICAgIFsxMCwgOTc5LCAzLCAxMV0sXFxuICAgICAgICBbMTAsIDk4MCwgNSwgMTBdLFxcbiAgICAgICAgWzEwLCA5ODEsIDgsIDldLFxcbiAgICAgICAgWzEwLCA5ODIsIDExLCA1XSxcXG4gICAgICAgIFsxMCwgOTgzLCAwLCA4XSxcXG4gICAgICAgIFsxMCwgOTg0LCAxMSwgNF0sXFxuICAgICAgICBbMTAsIDk4NSwgMiwgMTFdLFxcbiAgICAgICAgWzEwLCA5ODYsIDcsIDEwXSxcXG4gICAgICAgIFsxMCwgOTg3LCA2LCAxMF0sXFxuICAgICAgICBbMTAsIDk4OCwgMTAsIDddLFxcbiAgICAgICAgWzEwLCA5ODksIDQsIDExXSxcXG4gICAgICAgIFsxMCwgOTkwLCAxLCAxMV0sXFxuICAgICAgICBbMTAsIDk5MSwgMTIsIDJdLFxcbiAgICAgICAgWzEwLCA5OTIsIDksIDhdLFxcbiAgICAgICAgWzEwLCA5OTMsIDEyLCAzXSxcXG4gICAgICAgIFsxMCwgOTk0LCAxMSwgNl0sXFxuICAgICAgICBbMTAsIDk5NSwgNSwgMTFdLFxcbiAgICAgICAgWzEwLCA5OTYsIDEyLCA0XSxcXG4gICAgICAgIFsxMCwgOTk3LCAxMSwgN10sXFxuICAgICAgICBbMTAsIDk5OCwgMTIsIDVdLFxcbiAgICAgICAgWzEwLCA5OTksIDMsIDEyXSxcXG4gICAgICAgIFsxMCwgMTAwMCwgNiwgMTFdLFxcbiAgICAgICAgWzEwLCAxMDAxLCA5LCAwXSxcXG4gICAgICAgIFsxMCwgMTAwMiwgMTAsIDhdLFxcbiAgICAgICAgWzEwLCAxMDAzLCAxMCwgMF0sXFxuICAgICAgICBbMTAsIDEwMDQsIDEyLCAxXSxcXG4gICAgICAgIFsxMCwgMTAwNSwgMCwgOV0sXFxuICAgICAgICBbMTAsIDEwMDYsIDQsIDEyXSxcXG4gICAgICAgIFsxMCwgMTAwNywgOSwgOV0sXFxuICAgICAgICBbMTAsIDEwMDgsIDEyLCA2XSxcXG4gICAgICAgIFsxMCwgMTAwOSwgMiwgMTJdLFxcbiAgICAgICAgWzEwLCAxMDEwLCA4LCAxMF0sXFxuICAgICAgICBbMTEsIDIwMjIsIDksIDEwXSxcXG4gICAgICAgIFsxMSwgMjAyMywgMSwgMTJdLFxcbiAgICAgICAgWzExLCAyMDI0LCAxMSwgOF0sXFxuICAgICAgICBbMTEsIDIwMjUsIDEyLCA3XSxcXG4gICAgICAgIFsxMSwgMjAyNiwgNywgMTFdLFxcbiAgICAgICAgWzExLCAyMDI3LCA1LCAxMl0sXFxuICAgICAgICBbMTEsIDIwMjgsIDYsIDEyXSxcXG4gICAgICAgIFsxMSwgMjAyOSwgMTAsIDldLFxcbiAgICAgICAgWzExLCAyMDMwLCA4LCAxMV0sXFxuICAgICAgICBbMTEsIDIwMzEsIDEyLCA4XSxcXG4gICAgICAgIFsxMSwgMjAzMiwgMCwgMTBdLFxcbiAgICAgICAgWzExLCAyMDMzLCA3LCAxMl0sXFxuICAgICAgICBbMTEsIDIwMzQsIDExLCAwXSxcXG4gICAgICAgIFsxMSwgMjAzNSwgMTAsIDEwXSxcXG4gICAgICAgIFsxMSwgMjAzNiwgMTEsIDldLFxcbiAgICAgICAgWzExLCAyMDM3LCAxMSwgMTBdLFxcbiAgICAgICAgWzExLCAyMDM4LCAwLCAxMV0sXFxuICAgICAgICBbMTEsIDIwMzksIDExLCAxMV0sXFxuICAgICAgICBbMTEsIDIwNDAsIDksIDExXSxcXG4gICAgICAgIFsxMSwgMjA0MSwgMTAsIDExXSxcXG4gICAgICAgIFsxMSwgMjA0MiwgMTIsIDBdLFxcbiAgICAgICAgWzExLCAyMDQzLCA4LCAxMl0sXFxuICAgICAgICBbMTIsIDQwODgsIDEyLCA5XSxcXG4gICAgICAgIFsxMiwgNDA4OSwgMTAsIDEyXSxcXG4gICAgICAgIFsxMiwgNDA5MCwgOSwgMTJdLFxcbiAgICAgICAgWzEyLCA0MDkxLCAxMSwgMTJdLFxcbiAgICAgICAgWzEyLCA0MDkyLCAxMiwgMTFdLFxcbiAgICAgICAgWzEyLCA0MDkzLCAwLCAxMl0sXFxuICAgICAgICBbMTIsIDQwOTQsIDEyLCAxMF0sXFxuICAgICAgICBbMTIsIDQwOTUsIDEyLCAxMl1cXG4gICAgXTtcXG4gICAgXFxuICAgIGNvbnN0IEhDQjExID0gW1xcbiAgICAgICAgWzQsIDAsIDAsIDBdLFxcbiAgICAgICAgWzQsIDEsIDEsIDFdLFxcbiAgICAgICAgWzUsIDQsIDE2LCAxNl0sXFxuICAgICAgICBbNSwgNSwgMSwgMF0sXFxuICAgICAgICBbNSwgNiwgMCwgMV0sXFxuICAgICAgICBbNSwgNywgMiwgMV0sXFxuICAgICAgICBbNSwgOCwgMSwgMl0sXFxuICAgICAgICBbNSwgOSwgMiwgMl0sXFxuICAgICAgICBbNiwgMjAsIDEsIDNdLFxcbiAgICAgICAgWzYsIDIxLCAzLCAxXSxcXG4gICAgICAgIFs2LCAyMiwgMywgMl0sXFxuICAgICAgICBbNiwgMjMsIDIsIDBdLFxcbiAgICAgICAgWzYsIDI0LCAyLCAzXSxcXG4gICAgICAgIFs2LCAyNSwgMCwgMl0sXFxuICAgICAgICBbNiwgMjYsIDMsIDNdLFxcbiAgICAgICAgWzcsIDU0LCA0LCAxXSxcXG4gICAgICAgIFs3LCA1NSwgMSwgNF0sXFxuICAgICAgICBbNywgNTYsIDQsIDJdLFxcbiAgICAgICAgWzcsIDU3LCAyLCA0XSxcXG4gICAgICAgIFs3LCA1OCwgNCwgM10sXFxuICAgICAgICBbNywgNTksIDMsIDRdLFxcbiAgICAgICAgWzcsIDYwLCAzLCAwXSxcXG4gICAgICAgIFs3LCA2MSwgMCwgM10sXFxuICAgICAgICBbNywgNjIsIDUsIDFdLFxcbiAgICAgICAgWzcsIDYzLCA1LCAyXSxcXG4gICAgICAgIFs3LCA2NCwgMiwgNV0sXFxuICAgICAgICBbNywgNjUsIDQsIDRdLFxcbiAgICAgICAgWzcsIDY2LCAxLCA1XSxcXG4gICAgICAgIFs3LCA2NywgNSwgM10sXFxuICAgICAgICBbNywgNjgsIDMsIDVdLFxcbiAgICAgICAgWzcsIDY5LCA1LCA0XSxcXG4gICAgICAgIFs4LCAxNDAsIDQsIDVdLFxcbiAgICAgICAgWzgsIDE0MSwgNiwgMl0sXFxuICAgICAgICBbOCwgMTQyLCAyLCA2XSxcXG4gICAgICAgIFs4LCAxNDMsIDYsIDFdLFxcbiAgICAgICAgWzgsIDE0NCwgNiwgM10sXFxuICAgICAgICBbOCwgMTQ1LCAzLCA2XSxcXG4gICAgICAgIFs4LCAxNDYsIDEsIDZdLFxcbiAgICAgICAgWzgsIDE0NywgNCwgMTZdLFxcbiAgICAgICAgWzgsIDE0OCwgMywgMTZdLFxcbiAgICAgICAgWzgsIDE0OSwgMTYsIDVdLFxcbiAgICAgICAgWzgsIDE1MCwgMTYsIDNdLFxcbiAgICAgICAgWzgsIDE1MSwgMTYsIDRdLFxcbiAgICAgICAgWzgsIDE1MiwgNiwgNF0sXFxuICAgICAgICBbOCwgMTUzLCAxNiwgNl0sXFxuICAgICAgICBbOCwgMTU0LCA0LCAwXSxcXG4gICAgICAgIFs4LCAxNTUsIDQsIDZdLFxcbiAgICAgICAgWzgsIDE1NiwgMCwgNF0sXFxuICAgICAgICBbOCwgMTU3LCAyLCAxNl0sXFxuICAgICAgICBbOCwgMTU4LCA1LCA1XSxcXG4gICAgICAgIFs4LCAxNTksIDUsIDE2XSxcXG4gICAgICAgIFs4LCAxNjAsIDE2LCA3XSxcXG4gICAgICAgIFs4LCAxNjEsIDE2LCAyXSxcXG4gICAgICAgIFs4LCAxNjIsIDE2LCA4XSxcXG4gICAgICAgIFs4LCAxNjMsIDIsIDddLFxcbiAgICAgICAgWzgsIDE2NCwgNywgMl0sXFxuICAgICAgICBbOCwgMTY1LCAzLCA3XSxcXG4gICAgICAgIFs4LCAxNjYsIDYsIDVdLFxcbiAgICAgICAgWzgsIDE2NywgNSwgNl0sXFxuICAgICAgICBbOCwgMTY4LCA2LCAxNl0sXFxuICAgICAgICBbOCwgMTY5LCAxNiwgMTBdLFxcbiAgICAgICAgWzgsIDE3MCwgNywgM10sXFxuICAgICAgICBbOCwgMTcxLCA3LCAxXSxcXG4gICAgICAgIFs4LCAxNzIsIDE2LCA5XSxcXG4gICAgICAgIFs4LCAxNzMsIDcsIDE2XSxcXG4gICAgICAgIFs4LCAxNzQsIDEsIDE2XSxcXG4gICAgICAgIFs4LCAxNzUsIDEsIDddLFxcbiAgICAgICAgWzgsIDE3NiwgNCwgN10sXFxuICAgICAgICBbOCwgMTc3LCAxNiwgMTFdLFxcbiAgICAgICAgWzgsIDE3OCwgNywgNF0sXFxuICAgICAgICBbOCwgMTc5LCAxNiwgMTJdLFxcbiAgICAgICAgWzgsIDE4MCwgOCwgMTZdLFxcbiAgICAgICAgWzgsIDE4MSwgMTYsIDFdLFxcbiAgICAgICAgWzgsIDE4MiwgNiwgNl0sXFxuICAgICAgICBbOCwgMTgzLCA5LCAxNl0sXFxuICAgICAgICBbOCwgMTg0LCAyLCA4XSxcXG4gICAgICAgIFs4LCAxODUsIDUsIDddLFxcbiAgICAgICAgWzgsIDE4NiwgMTAsIDE2XSxcXG4gICAgICAgIFs4LCAxODcsIDE2LCAxM10sXFxuICAgICAgICBbOCwgMTg4LCA4LCAzXSxcXG4gICAgICAgIFs4LCAxODksIDgsIDJdLFxcbiAgICAgICAgWzgsIDE5MCwgMywgOF0sXFxuICAgICAgICBbOCwgMTkxLCA1LCAwXSxcXG4gICAgICAgIFs4LCAxOTIsIDE2LCAxNF0sXFxuICAgICAgICBbOCwgMTkzLCAxMSwgMTZdLFxcbiAgICAgICAgWzgsIDE5NCwgNywgNV0sXFxuICAgICAgICBbOCwgMTk1LCA0LCA4XSxcXG4gICAgICAgIFs4LCAxOTYsIDYsIDddLFxcbiAgICAgICAgWzgsIDE5NywgNywgNl0sXFxuICAgICAgICBbOCwgMTk4LCAwLCA1XSxcXG4gICAgICAgIFs5LCAzOTgsIDgsIDRdLFxcbiAgICAgICAgWzksIDM5OSwgMTYsIDE1XSxcXG4gICAgICAgIFs5LCA0MDAsIDEyLCAxNl0sXFxuICAgICAgICBbOSwgNDAxLCAxLCA4XSxcXG4gICAgICAgIFs5LCA0MDIsIDgsIDFdLFxcbiAgICAgICAgWzksIDQwMywgMTQsIDE2XSxcXG4gICAgICAgIFs5LCA0MDQsIDUsIDhdLFxcbiAgICAgICAgWzksIDQwNSwgMTMsIDE2XSxcXG4gICAgICAgIFs5LCA0MDYsIDMsIDldLFxcbiAgICAgICAgWzksIDQwNywgOCwgNV0sXFxuICAgICAgICBbOSwgNDA4LCA3LCA3XSxcXG4gICAgICAgIFs5LCA0MDksIDIsIDldLFxcbiAgICAgICAgWzksIDQxMCwgOCwgNl0sXFxuICAgICAgICBbOSwgNDExLCA5LCAyXSxcXG4gICAgICAgIFs5LCA0MTIsIDksIDNdLFxcbiAgICAgICAgWzksIDQxMywgMTUsIDE2XSxcXG4gICAgICAgIFs5LCA0MTQsIDQsIDldLFxcbiAgICAgICAgWzksIDQxNSwgNiwgOF0sXFxuICAgICAgICBbOSwgNDE2LCA2LCAwXSxcXG4gICAgICAgIFs5LCA0MTcsIDksIDRdLFxcbiAgICAgICAgWzksIDQxOCwgNSwgOV0sXFxuICAgICAgICBbOSwgNDE5LCA4LCA3XSxcXG4gICAgICAgIFs5LCA0MjAsIDcsIDhdLFxcbiAgICAgICAgWzksIDQyMSwgMSwgOV0sXFxuICAgICAgICBbOSwgNDIyLCAxMCwgM10sXFxuICAgICAgICBbOSwgNDIzLCAwLCA2XSxcXG4gICAgICAgIFs5LCA0MjQsIDEwLCAyXSxcXG4gICAgICAgIFs5LCA0MjUsIDksIDFdLFxcbiAgICAgICAgWzksIDQyNiwgOSwgNV0sXFxuICAgICAgICBbOSwgNDI3LCA0LCAxMF0sXFxuICAgICAgICBbOSwgNDI4LCAyLCAxMF0sXFxuICAgICAgICBbOSwgNDI5LCA5LCA2XSxcXG4gICAgICAgIFs5LCA0MzAsIDMsIDEwXSxcXG4gICAgICAgIFs5LCA0MzEsIDYsIDldLFxcbiAgICAgICAgWzksIDQzMiwgMTAsIDRdLFxcbiAgICAgICAgWzksIDQzMywgOCwgOF0sXFxuICAgICAgICBbOSwgNDM0LCAxMCwgNV0sXFxuICAgICAgICBbOSwgNDM1LCA5LCA3XSxcXG4gICAgICAgIFs5LCA0MzYsIDExLCAzXSxcXG4gICAgICAgIFs5LCA0MzcsIDEsIDEwXSxcXG4gICAgICAgIFs5LCA0MzgsIDcsIDBdLFxcbiAgICAgICAgWzksIDQzOSwgMTAsIDZdLFxcbiAgICAgICAgWzksIDQ0MCwgNywgOV0sXFxuICAgICAgICBbOSwgNDQxLCAzLCAxMV0sXFxuICAgICAgICBbOSwgNDQyLCA1LCAxMF0sXFxuICAgICAgICBbOSwgNDQzLCAxMCwgMV0sXFxuICAgICAgICBbOSwgNDQ0LCA0LCAxMV0sXFxuICAgICAgICBbOSwgNDQ1LCAxMSwgMl0sXFxuICAgICAgICBbOSwgNDQ2LCAxMywgMl0sXFxuICAgICAgICBbOSwgNDQ3LCA2LCAxMF0sXFxuICAgICAgICBbOSwgNDQ4LCAxMywgM10sXFxuICAgICAgICBbOSwgNDQ5LCAyLCAxMV0sXFxuICAgICAgICBbOSwgNDUwLCAxNiwgMF0sXFxuICAgICAgICBbOSwgNDUxLCA1LCAxMV0sXFxuICAgICAgICBbOSwgNDUyLCAxMSwgNV0sXFxuICAgICAgICBbMTAsIDkwNiwgMTEsIDRdLFxcbiAgICAgICAgWzEwLCA5MDcsIDksIDhdLFxcbiAgICAgICAgWzEwLCA5MDgsIDcsIDEwXSxcXG4gICAgICAgIFsxMCwgOTA5LCA4LCA5XSxcXG4gICAgICAgIFsxMCwgOTEwLCAwLCAxNl0sXFxuICAgICAgICBbMTAsIDkxMSwgNCwgMTNdLFxcbiAgICAgICAgWzEwLCA5MTIsIDAsIDddLFxcbiAgICAgICAgWzEwLCA5MTMsIDMsIDEzXSxcXG4gICAgICAgIFsxMCwgOTE0LCAxMSwgNl0sXFxuICAgICAgICBbMTAsIDkxNSwgMTMsIDFdLFxcbiAgICAgICAgWzEwLCA5MTYsIDEzLCA0XSxcXG4gICAgICAgIFsxMCwgOTE3LCAxMiwgM10sXFxuICAgICAgICBbMTAsIDkxOCwgMiwgMTNdLFxcbiAgICAgICAgWzEwLCA5MTksIDEzLCA1XSxcXG4gICAgICAgIFsxMCwgOTIwLCA4LCAxMF0sXFxuICAgICAgICBbMTAsIDkyMSwgNiwgMTFdLFxcbiAgICAgICAgWzEwLCA5MjIsIDEwLCA4XSxcXG4gICAgICAgIFsxMCwgOTIzLCAxMCwgN10sXFxuICAgICAgICBbMTAsIDkyNCwgMTQsIDJdLFxcbiAgICAgICAgWzEwLCA5MjUsIDEyLCA0XSxcXG4gICAgICAgIFsxMCwgOTI2LCAxLCAxMV0sXFxuICAgICAgICBbMTAsIDkyNywgNCwgMTJdLFxcbiAgICAgICAgWzEwLCA5MjgsIDExLCAxXSxcXG4gICAgICAgIFsxMCwgOTI5LCAzLCAxMl0sXFxuICAgICAgICBbMTAsIDkzMCwgMSwgMTNdLFxcbiAgICAgICAgWzEwLCA5MzEsIDEyLCAyXSxcXG4gICAgICAgIFsxMCwgOTMyLCA3LCAxMV0sXFxuICAgICAgICBbMTAsIDkzMywgMywgMTRdLFxcbiAgICAgICAgWzEwLCA5MzQsIDUsIDEyXSxcXG4gICAgICAgIFsxMCwgOTM1LCA1LCAxM10sXFxuICAgICAgICBbMTAsIDkzNiwgMTQsIDRdLFxcbiAgICAgICAgWzEwLCA5MzcsIDQsIDE0XSxcXG4gICAgICAgIFsxMCwgOTM4LCAxMSwgN10sXFxuICAgICAgICBbMTAsIDkzOSwgMTQsIDNdLFxcbiAgICAgICAgWzEwLCA5NDAsIDEyLCA1XSxcXG4gICAgICAgIFsxMCwgOTQxLCAxMywgNl0sXFxuICAgICAgICBbMTAsIDk0MiwgMTIsIDZdLFxcbiAgICAgICAgWzEwLCA5NDMsIDgsIDBdLFxcbiAgICAgICAgWzEwLCA5NDQsIDExLCA4XSxcXG4gICAgICAgIFsxMCwgOTQ1LCAyLCAxMl0sXFxuICAgICAgICBbMTAsIDk0NiwgOSwgOV0sXFxuICAgICAgICBbMTAsIDk0NywgMTQsIDVdLFxcbiAgICAgICAgWzEwLCA5NDgsIDYsIDEzXSxcXG4gICAgICAgIFsxMCwgOTQ5LCAxMCwgMTBdLFxcbiAgICAgICAgWzEwLCA5NTAsIDE1LCAyXSxcXG4gICAgICAgIFsxMCwgOTUxLCA4LCAxMV0sXFxuICAgICAgICBbMTAsIDk1MiwgOSwgMTBdLFxcbiAgICAgICAgWzEwLCA5NTMsIDE0LCA2XSxcXG4gICAgICAgIFsxMCwgOTU0LCAxMCwgOV0sXFxuICAgICAgICBbMTAsIDk1NSwgNSwgMTRdLFxcbiAgICAgICAgWzEwLCA5NTYsIDExLCA5XSxcXG4gICAgICAgIFsxMCwgOTU3LCAxNCwgMV0sXFxuICAgICAgICBbMTAsIDk1OCwgMiwgMTRdLFxcbiAgICAgICAgWzEwLCA5NTksIDYsIDEyXSxcXG4gICAgICAgIFsxMCwgOTYwLCAxLCAxMl0sXFxuICAgICAgICBbMTAsIDk2MSwgMTMsIDhdLFxcbiAgICAgICAgWzEwLCA5NjIsIDAsIDhdLFxcbiAgICAgICAgWzEwLCA5NjMsIDEzLCA3XSxcXG4gICAgICAgIFsxMCwgOTY0LCA3LCAxMl0sXFxuICAgICAgICBbMTAsIDk2NSwgMTIsIDddLFxcbiAgICAgICAgWzEwLCA5NjYsIDcsIDEzXSxcXG4gICAgICAgIFsxMCwgOTY3LCAxNSwgM10sXFxuICAgICAgICBbMTAsIDk2OCwgMTIsIDFdLFxcbiAgICAgICAgWzEwLCA5NjksIDYsIDE0XSxcXG4gICAgICAgIFsxMCwgOTcwLCAyLCAxNV0sXFxuICAgICAgICBbMTAsIDk3MSwgMTUsIDVdLFxcbiAgICAgICAgWzEwLCA5NzIsIDE1LCA0XSxcXG4gICAgICAgIFsxMCwgOTczLCAxLCAxNF0sXFxuICAgICAgICBbMTAsIDk3NCwgOSwgMTFdLFxcbiAgICAgICAgWzEwLCA5NzUsIDQsIDE1XSxcXG4gICAgICAgIFsxMCwgOTc2LCAxNCwgN10sXFxuICAgICAgICBbMTAsIDk3NywgOCwgMTNdLFxcbiAgICAgICAgWzEwLCA5NzgsIDEzLCA5XSxcXG4gICAgICAgIFsxMCwgOTc5LCA4LCAxMl0sXFxuICAgICAgICBbMTAsIDk4MCwgNSwgMTVdLFxcbiAgICAgICAgWzEwLCA5ODEsIDMsIDE1XSxcXG4gICAgICAgIFsxMCwgOTgyLCAxMCwgMTFdLFxcbiAgICAgICAgWzEwLCA5ODMsIDExLCAxMF0sXFxuICAgICAgICBbMTAsIDk4NCwgMTIsIDhdLFxcbiAgICAgICAgWzEwLCA5ODUsIDE1LCA2XSxcXG4gICAgICAgIFsxMCwgOTg2LCAxNSwgN10sXFxuICAgICAgICBbMTAsIDk4NywgOCwgMTRdLFxcbiAgICAgICAgWzEwLCA5ODgsIDE1LCAxXSxcXG4gICAgICAgIFsxMCwgOTg5LCA3LCAxNF0sXFxuICAgICAgICBbMTAsIDk5MCwgOSwgMF0sXFxuICAgICAgICBbMTAsIDk5MSwgMCwgOV0sXFxuICAgICAgICBbMTAsIDk5MiwgOSwgMTNdLFxcbiAgICAgICAgWzEwLCA5OTMsIDksIDEyXSxcXG4gICAgICAgIFsxMCwgOTk0LCAxMiwgOV0sXFxuICAgICAgICBbMTAsIDk5NSwgMTQsIDhdLFxcbiAgICAgICAgWzEwLCA5OTYsIDEwLCAxM10sXFxuICAgICAgICBbMTAsIDk5NywgMTQsIDldLFxcbiAgICAgICAgWzEwLCA5OTgsIDEyLCAxMF0sXFxuICAgICAgICBbMTAsIDk5OSwgNiwgMTVdLFxcbiAgICAgICAgWzEwLCAxMDAwLCA3LCAxNV0sXFxuICAgICAgICBbMTEsIDIwMDIsIDksIDE0XSxcXG4gICAgICAgIFsxMSwgMjAwMywgMTUsIDhdLFxcbiAgICAgICAgWzExLCAyMDA0LCAxMSwgMTFdLFxcbiAgICAgICAgWzExLCAyMDA1LCAxMSwgMTRdLFxcbiAgICAgICAgWzExLCAyMDA2LCAxLCAxNV0sXFxuICAgICAgICBbMTEsIDIwMDcsIDEwLCAxMl0sXFxuICAgICAgICBbMTEsIDIwMDgsIDEwLCAxNF0sXFxuICAgICAgICBbMTEsIDIwMDksIDEzLCAxMV0sXFxuICAgICAgICBbMTEsIDIwMTAsIDEzLCAxMF0sXFxuICAgICAgICBbMTEsIDIwMTEsIDExLCAxM10sXFxuICAgICAgICBbMTEsIDIwMTIsIDExLCAxMl0sXFxuICAgICAgICBbMTEsIDIwMTMsIDgsIDE1XSxcXG4gICAgICAgIFsxMSwgMjAxNCwgMTQsIDExXSxcXG4gICAgICAgIFsxMSwgMjAxNSwgMTMsIDEyXSxcXG4gICAgICAgIFsxMSwgMjAxNiwgMTIsIDEzXSxcXG4gICAgICAgIFsxMSwgMjAxNywgMTUsIDldLFxcbiAgICAgICAgWzExLCAyMDE4LCAxNCwgMTBdLFxcbiAgICAgICAgWzExLCAyMDE5LCAxMCwgMF0sXFxuICAgICAgICBbMTEsIDIwMjAsIDEyLCAxMV0sXFxuICAgICAgICBbMTEsIDIwMjEsIDksIDE1XSxcXG4gICAgICAgIFsxMSwgMjAyMiwgMCwgMTBdLFxcbiAgICAgICAgWzExLCAyMDIzLCAxMiwgMTJdLFxcbiAgICAgICAgWzExLCAyMDI0LCAxMSwgMF0sXFxuICAgICAgICBbMTEsIDIwMjUsIDEyLCAxNF0sXFxuICAgICAgICBbMTEsIDIwMjYsIDEwLCAxNV0sXFxuICAgICAgICBbMTEsIDIwMjcsIDEzLCAxM10sXFxuICAgICAgICBbMTEsIDIwMjgsIDAsIDEzXSxcXG4gICAgICAgIFsxMSwgMjAyOSwgMTQsIDEyXSxcXG4gICAgICAgIFsxMSwgMjAzMCwgMTUsIDEwXSxcXG4gICAgICAgIFsxMSwgMjAzMSwgMTUsIDExXSxcXG4gICAgICAgIFsxMSwgMjAzMiwgMTEsIDE1XSxcXG4gICAgICAgIFsxMSwgMjAzMywgMTQsIDEzXSxcXG4gICAgICAgIFsxMSwgMjAzNCwgMTMsIDBdLFxcbiAgICAgICAgWzExLCAyMDM1LCAwLCAxMV0sXFxuICAgICAgICBbMTEsIDIwMzYsIDEzLCAxNF0sXFxuICAgICAgICBbMTEsIDIwMzcsIDE1LCAxMl0sXFxuICAgICAgICBbMTEsIDIwMzgsIDE1LCAxM10sXFxuICAgICAgICBbMTEsIDIwMzksIDEyLCAxNV0sXFxuICAgICAgICBbMTEsIDIwNDAsIDE0LCAwXSxcXG4gICAgICAgIFsxMSwgMjA0MSwgMTQsIDE0XSxcXG4gICAgICAgIFsxMSwgMjA0MiwgMTMsIDE1XSxcXG4gICAgICAgIFsxMSwgMjA0MywgMTIsIDBdLFxcbiAgICAgICAgWzExLCAyMDQ0LCAxNCwgMTVdLFxcbiAgICAgICAgWzEyLCA0MDkwLCAwLCAxNF0sXFxuICAgICAgICBbMTIsIDQwOTEsIDAsIDEyXSxcXG4gICAgICAgIFsxMiwgNDA5MiwgMTUsIDE0XSxcXG4gICAgICAgIFsxMiwgNDA5MywgMTUsIDBdLFxcbiAgICAgICAgWzEyLCA0MDk0LCAwLCAxNV0sXFxuICAgICAgICBbMTIsIDQwOTUsIDE1LCAxNV1cXG4gICAgXTtcXG4gICAgXFxuICAgIGNvbnN0IEhDQl9TRiA9IFtcXG4gICAgICAgIFsxLCAwLCA2MF0sXFxuICAgICAgICBbMywgNCwgNTldLFxcbiAgICAgICAgWzQsIDEwLCA2MV0sXFxuICAgICAgICBbNCwgMTEsIDU4XSxcXG4gICAgICAgIFs0LCAxMiwgNjJdLFxcbiAgICAgICAgWzUsIDI2LCA1N10sXFxuICAgICAgICBbNSwgMjcsIDYzXSxcXG4gICAgICAgIFs2LCA1NiwgNTZdLFxcbiAgICAgICAgWzYsIDU3LCA2NF0sXFxuICAgICAgICBbNiwgNTgsIDU1XSxcXG4gICAgICAgIFs2LCA1OSwgNjVdLFxcbiAgICAgICAgWzcsIDEyMCwgNjZdLFxcbiAgICAgICAgWzcsIDEyMSwgNTRdLFxcbiAgICAgICAgWzcsIDEyMiwgNjddLFxcbiAgICAgICAgWzgsIDI0NiwgNTNdLFxcbiAgICAgICAgWzgsIDI0NywgNjhdLFxcbiAgICAgICAgWzgsIDI0OCwgNTJdLFxcbiAgICAgICAgWzgsIDI0OSwgNjldLFxcbiAgICAgICAgWzgsIDI1MCwgNTFdLFxcbiAgICAgICAgWzksIDUwMiwgNzBdLFxcbiAgICAgICAgWzksIDUwMywgNTBdLFxcbiAgICAgICAgWzksIDUwNCwgNDldLFxcbiAgICAgICAgWzksIDUwNSwgNzFdLFxcbiAgICAgICAgWzEwLCAxMDEyLCA3Ml0sXFxuICAgICAgICBbMTAsIDEwMTMsIDQ4XSxcXG4gICAgICAgIFsxMCwgMTAxNCwgNzNdLFxcbiAgICAgICAgWzEwLCAxMDE1LCA0N10sXFxuICAgICAgICBbMTAsIDEwMTYsIDc0XSxcXG4gICAgICAgIFsxMCwgMTAxNywgNDZdLFxcbiAgICAgICAgWzExLCAyMDM2LCA3Nl0sXFxuICAgICAgICBbMTEsIDIwMzcsIDc1XSxcXG4gICAgICAgIFsxMSwgMjAzOCwgNzddLFxcbiAgICAgICAgWzExLCAyMDM5LCA3OF0sXFxuICAgICAgICBbMTEsIDIwNDAsIDQ1XSxcXG4gICAgICAgIFsxMSwgMjA0MSwgNDNdLFxcbiAgICAgICAgWzEyLCA0MDg0LCA0NF0sXFxuICAgICAgICBbMTIsIDQwODUsIDc5XSxcXG4gICAgICAgIFsxMiwgNDA4NiwgNDJdLFxcbiAgICAgICAgWzEyLCA0MDg3LCA0MV0sXFxuICAgICAgICBbMTIsIDQwODgsIDgwXSxcXG4gICAgICAgIFsxMiwgNDA4OSwgNDBdLFxcbiAgICAgICAgWzEzLCA4MTgwLCA4MV0sXFxuICAgICAgICBbMTMsIDgxODEsIDM5XSxcXG4gICAgICAgIFsxMywgODE4MiwgODJdLFxcbiAgICAgICAgWzEzLCA4MTgzLCAzOF0sXFxuICAgICAgICBbMTMsIDgxODQsIDgzXSxcXG4gICAgICAgIFsxNCwgMTYzNzAsIDM3XSxcXG4gICAgICAgIFsxNCwgMTYzNzEsIDM1XSxcXG4gICAgICAgIFsxNCwgMTYzNzIsIDg1XSxcXG4gICAgICAgIFsxNCwgMTYzNzMsIDMzXSxcXG4gICAgICAgIFsxNCwgMTYzNzQsIDM2XSxcXG4gICAgICAgIFsxNCwgMTYzNzUsIDM0XSxcXG4gICAgICAgIFsxNCwgMTYzNzYsIDg0XSxcXG4gICAgICAgIFsxNCwgMTYzNzcsIDMyXSxcXG4gICAgICAgIFsxNSwgMzI3NTYsIDg3XSxcXG4gICAgICAgIFsxNSwgMzI3NTcsIDg5XSxcXG4gICAgICAgIFsxNSwgMzI3NTgsIDMwXSxcXG4gICAgICAgIFsxNSwgMzI3NTksIDMxXSxcXG4gICAgICAgIFsxNiwgNjU1MjAsIDg2XSxcXG4gICAgICAgIFsxNiwgNjU1MjEsIDI5XSxcXG4gICAgICAgIFsxNiwgNjU1MjIsIDI2XSxcXG4gICAgICAgIFsxNiwgNjU1MjMsIDI3XSxcXG4gICAgICAgIFsxNiwgNjU1MjQsIDI4XSxcXG4gICAgICAgIFsxNiwgNjU1MjUsIDI0XSxcXG4gICAgICAgIFsxNiwgNjU1MjYsIDg4XSxcXG4gICAgICAgIFsxNywgMTMxMDU0LCAyNV0sXFxuICAgICAgICBbMTcsIDEzMTA1NSwgMjJdLFxcbiAgICAgICAgWzE3LCAxMzEwNTYsIDIzXSxcXG4gICAgICAgIFsxOCwgMjYyMTE0LCA5MF0sXFxuICAgICAgICBbMTgsIDI2MjExNSwgMjFdLFxcbiAgICAgICAgWzE4LCAyNjIxMTYsIDE5XSxcXG4gICAgICAgIFsxOCwgMjYyMTE3LCAzXSxcXG4gICAgICAgIFsxOCwgMjYyMTE4LCAxXSxcXG4gICAgICAgIFsxOCwgMjYyMTE5LCAyXSxcXG4gICAgICAgIFsxOCwgMjYyMTIwLCAwXSxcXG4gICAgICAgIFsxOSwgNTI0MjQyLCA5OF0sXFxuICAgICAgICBbMTksIDUyNDI0MywgOTldLFxcbiAgICAgICAgWzE5LCA1MjQyNDQsIDEwMF0sXFxuICAgICAgICBbMTksIDUyNDI0NSwgMTAxXSxcXG4gICAgICAgIFsxOSwgNTI0MjQ2LCAxMDJdLFxcbiAgICAgICAgWzE5LCA1MjQyNDcsIDExN10sXFxuICAgICAgICBbMTksIDUyNDI0OCwgOTddLFxcbiAgICAgICAgWzE5LCA1MjQyNDksIDkxXSxcXG4gICAgICAgIFsxOSwgNTI0MjUwLCA5Ml0sXFxuICAgICAgICBbMTksIDUyNDI1MSwgOTNdLFxcbiAgICAgICAgWzE5LCA1MjQyNTIsIDk0XSxcXG4gICAgICAgIFsxOSwgNTI0MjUzLCA5NV0sXFxuICAgICAgICBbMTksIDUyNDI1NCwgOTZdLFxcbiAgICAgICAgWzE5LCA1MjQyNTUsIDEwNF0sXFxuICAgICAgICBbMTksIDUyNDI1NiwgMTExXSxcXG4gICAgICAgIFsxOSwgNTI0MjU3LCAxMTJdLFxcbiAgICAgICAgWzE5LCA1MjQyNTgsIDExM10sXFxuICAgICAgICBbMTksIDUyNDI1OSwgMTE0XSxcXG4gICAgICAgIFsxOSwgNTI0MjYwLCAxMTVdLFxcbiAgICAgICAgWzE5LCA1MjQyNjEsIDExNl0sXFxuICAgICAgICBbMTksIDUyNDI2MiwgMTEwXSxcXG4gICAgICAgIFsxOSwgNTI0MjYzLCAxMDVdLFxcbiAgICAgICAgWzE5LCA1MjQyNjQsIDEwNl0sXFxuICAgICAgICBbMTksIDUyNDI2NSwgMTA3XSxcXG4gICAgICAgIFsxOSwgNTI0MjY2LCAxMDhdLFxcbiAgICAgICAgWzE5LCA1MjQyNjcsIDEwOV0sXFxuICAgICAgICBbMTksIDUyNDI2OCwgMTE4XSxcXG4gICAgICAgIFsxOSwgNTI0MjY5LCA2XSxcXG4gICAgICAgIFsxOSwgNTI0MjcwLCA4XSxcXG4gICAgICAgIFsxOSwgNTI0MjcxLCA5XSxcXG4gICAgICAgIFsxOSwgNTI0MjcyLCAxMF0sXFxuICAgICAgICBbMTksIDUyNDI3MywgNV0sXFxuICAgICAgICBbMTksIDUyNDI3NCwgMTAzXSxcXG4gICAgICAgIFsxOSwgNTI0Mjc1LCAxMjBdLFxcbiAgICAgICAgWzE5LCA1MjQyNzYsIDExOV0sXFxuICAgICAgICBbMTksIDUyNDI3NywgNF0sXFxuICAgICAgICBbMTksIDUyNDI3OCwgN10sXFxuICAgICAgICBbMTksIDUyNDI3OSwgMTVdLFxcbiAgICAgICAgWzE5LCA1MjQyODAsIDE2XSxcXG4gICAgICAgIFsxOSwgNTI0MjgxLCAxOF0sXFxuICAgICAgICBbMTksIDUyNDI4MiwgMjBdLFxcbiAgICAgICAgWzE5LCA1MjQyODMsIDE3XSxcXG4gICAgICAgIFsxOSwgNTI0Mjg0LCAxMV0sXFxuICAgICAgICBbMTksIDUyNDI4NSwgMTJdLFxcbiAgICAgICAgWzE5LCA1MjQyODYsIDE0XSxcXG4gICAgICAgIFsxOSwgNTI0Mjg3LCAxM11cXG4gICAgXTtcXG4gICAgXFxuICAgIGNvbnN0IENPREVCT09LUyA9IFtIQ0IxLCBIQ0IyLCBIQ0IzLCBIQ0I0LCBIQ0I1LCBIQ0I2LCBIQ0I3LCBIQ0I4LCBIQ0I5LCBIQ0IxMCwgSENCMTFdO1xcbiAgICBjb25zdCBVTlNJR05FRCA9IFtmYWxzZSwgZmFsc2UsIHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0sXFxuICAgICAgICAgIFFVQURfTEVOID0gNCwgXFxuICAgICAgICAgIFBBSVJfTEVOID0gMjtcXG4gICAgXFxuICAgIHZhciBIdWZmbWFuID0ge1xcbiAgICAgICAgZmluZE9mZnNldDogZnVuY3Rpb24oc3RyZWFtLCB0YWJsZSkge1xcbiAgICAgICAgICAgIHZhciBvZmYgPSAwLFxcbiAgICAgICAgICAgICAgICBsZW4gPSB0YWJsZVtvZmZdWzBdLFxcbiAgICAgICAgICAgICAgICBjdyA9IHN0cmVhbS5yZWFkKGxlbik7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHdoaWxlIChjdyAhPT0gdGFibGVbb2ZmXVsxXSkge1xcbiAgICAgICAgICAgICAgICB2YXIgaiA9IHRhYmxlWysrb2ZmXVswXSAtIGxlbjtcXG4gICAgICAgICAgICAgICAgbGVuID0gdGFibGVbb2ZmXVswXTtcXG4gICAgICAgICAgICAgICAgY3cgPDw9IGo7XFxuICAgICAgICAgICAgICAgIGN3IHw9IHN0cmVhbS5yZWFkKGopO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICByZXR1cm4gb2ZmO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcbiAgICAgICAgc2lnblZhbHVlczogZnVuY3Rpb24oc3RyZWFtLCBkYXRhLCBvZmYsIGxlbikge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBvZmY7IGkgPCBvZmYgKyBsZW47IGkrKykge1xcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBzdHJlYW0ucmVhZCgxKSlcXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSAtZGF0YVtpXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxuICAgICAgICBnZXRFc2NhcGU6IGZ1bmN0aW9uKHN0cmVhbSwgcykge1xcbiAgICAgICAgICAgIHZhciBpID0gNDtcXG4gICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnJlYWQoMSkpXFxuICAgICAgICAgICAgICAgIGkrKztcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgdmFyIGogPSBzdHJlYW0ucmVhZChpKSB8ICgxIDw8IGkpO1xcbiAgICAgICAgICAgIHJldHVybiBzIDwgMCA/IC1qIDogajtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXG4gICAgICAgIGRlY29kZVNjYWxlRmFjdG9yOiBmdW5jdGlvbihzdHJlYW0pIHtcXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5maW5kT2Zmc2V0KHN0cmVhbSwgSENCX1NGKTtcXG4gICAgICAgICAgICByZXR1cm4gSENCX1NGW29mZnNldF1bMl07XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxuICAgICAgICBkZWNvZGVTcGVjdHJhbERhdGE6IGZ1bmN0aW9uKHN0cmVhbSwgY2IsIGRhdGEsIG9mZikge1xcbiAgICAgICAgICAgIHZhciBIQ0IgPSBDT0RFQk9PS1NbY2IgLSAxXSxcXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5maW5kT2Zmc2V0KHN0cmVhbSwgSENCKTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgZGF0YVtvZmZdID0gSENCW29mZnNldF1bMl07XFxuICAgICAgICAgICAgZGF0YVtvZmYgKyAxXSA9IEhDQltvZmZzZXRdWzNdO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGlmIChjYiA8IDUpIHtcXG4gICAgICAgICAgICAgICAgZGF0YVtvZmYgKyAyXSA9IEhDQltvZmZzZXRdWzRdO1xcbiAgICAgICAgICAgICAgICBkYXRhW29mZiArIDNdID0gSENCW29mZnNldF1bNV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIHNpZ24gYW5kIGVzY2FwZVxcbiAgICAgICAgICAgIGlmIChjYiA8IDExKSB7XFxuICAgICAgICAgICAgICAgIGlmIChVTlNJR05FRFtjYiAtIDFdKVxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduVmFsdWVzKHN0cmVhbSwgZGF0YSwgb2ZmLCBjYiA8IDUgPyBRVUFEX0xFTiA6IFBBSVJfTEVOKTtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2IgPT09IDExIHx8IGNiID4gMTUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5zaWduVmFsdWVzKHN0cmVhbSwgZGF0YSwgb2ZmLCBjYiA8IDUgPyBRVUFEX0xFTiA6IFBBSVJfTEVOKTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkYXRhW29mZl0pID09PSAxNikgXFxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZl0gPSB0aGlzLmdldEVzY2FwZShzdHJlYW0sIGRhdGFbb2ZmXSk7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRhdGFbb2ZmICsgMV0pID09PSAxNilcXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2ZmICsgMV0gPSB0aGlzLmdldEVzY2FwZShzdHJlYW0sIGRhdGFbb2ZmICsgMV0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiSHVmZm1hbjogdW5rbm93biBzcGVjdHJhbCBjb2RlYm9vazogXFxcIiArIGNiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICByZXR1cm4gSHVmZm1hbjtcXG4gICAgXFxufSkoKTsvL2ltcG9ydCBcXFwiaHVmZm1hbi5qc1xcXCJcXG4vKlxcbiAqIEFBQy5qcyAtIEFkdmFuY2VkIEF1ZGlvIENvZGluZyBkZWNvZGVyIGluIEphdmFTY3JpcHRcXG4gKiBDcmVhdGVkIGJ5IERldm9uIEdvdmV0dFxcbiAqIENvcHlyaWdodCAoYykgMjAxMiwgT2ZmaWNpYWwuZm0gTGFic1xcbiAqXFxuICogQUFDLmpzIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQgXFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgXFxuICogcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIFxcbiAqIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXFxuICpcXG4gKiBBQUMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVQgXFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIFxcbiAqIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgXFxuICogUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cXG4gKlxcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcXG4gKiBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LlxcbiAqIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cXG4gKi9cXG5cXG52YXIgVE5TID0gKGZ1bmN0aW9uKCkge1xcbiAgICBcXG4gICAgLy8gVGVtcG9yYWwgTm9pc2UgU2hhcGluZ1xcbiAgICBmdW5jdGlvbiBUTlMoY29uZmlnKSB7XFxuICAgICAgICB0aGlzLm1heEJhbmRzID0gVE5TX01BWF9CQU5EU18xMDI0W2NvbmZpZy5zYW1wbGVJbmRleF1cXG4gICAgICAgIHRoaXMubkZpbHQgPSBuZXcgSW50MzJBcnJheSg4KTtcXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbmV3IEFycmF5KDgpO1xcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgQXJyYXkoOCk7XFxuICAgICAgICB0aGlzLm9yZGVyID0gbmV3IEFycmF5KDgpO1xcbiAgICAgICAgdGhpcy5jb2VmID0gbmV3IEFycmF5KDgpO1xcbiAgICAgICAgXFxuICAgICAgICAvLyBQcm9iYWJseSBjb3VsZCBhbGxvY2F0ZSB0aGVzZSBhcyBuZWVkZWRcXG4gICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgODsgdysrKSB7XFxuICAgICAgICAgICAgdGhpcy5sZW5ndGhbd10gPSBuZXcgSW50MzJBcnJheSg0KTtcXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvblt3XSA9IG5ldyBBcnJheSg0KTtcXG4gICAgICAgICAgICB0aGlzLm9yZGVyW3ddID0gbmV3IEludDMyQXJyYXkoNCk7XFxuICAgICAgICAgICAgdGhpcy5jb2VmW3ddID0gbmV3IEFycmF5KDQpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZvciAodmFyIGZpbHQgPSAwOyBmaWx0IDwgNDsgZmlsdCsrKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuY29lZlt3XVtmaWx0XSA9IG5ldyBGbG9hdDMyQXJyYXkoVE5TX01BWF9PUkRFUik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICB0aGlzLmxwYyA9IG5ldyBGbG9hdDMyQXJyYXkoVE5TX01BWF9PUkRFUik7XFxuICAgICAgICB0aGlzLnRtcCA9IG5ldyBGbG9hdDMyQXJyYXkoVE5TX01BWF9PUkRFUik7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgVE5TX01BWF9PUkRFUiA9IDIwLFxcbiAgICAgICAgICBTSE9SVF9CSVRTID0gWzEsIDQsIDNdLFxcbiAgICAgICAgICBMT05HX0JJVFMgPSBbMiwgNiwgNV07XFxuICAgICAgICAgIFxcbiAgICBjb25zdCBUTlNfQ09FRl8xXzMgPSBbMC4wMDAwMDAwMCwgLTAuNDMzODgzNzMsIDAuNjQyNzg3NTgsIDAuMzQyMDIwMTVdLFxcblxcbiAgICAgICAgICBUTlNfQ09FRl8wXzMgPSBbMC4wMDAwMDAwMCwgLTAuNDMzODgzNzMsIC0wLjc4MTgzMTUwLCAtMC45NzQ5Mjc5MCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAuOTg0ODA3NzMsIDAuODY2MDI1MzksIDAuNjQyNzg3NTgsIDAuMzQyMDIwMTVdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgIFROU19DT0VGXzFfNCA9IFswLjAwMDAwMDAwLCAtMC4yMDc5MTE3MCwgLTAuNDA2NzM2NjQsIC0wLjU4Nzc4NTI0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMC42NzM2OTU2MiwgMC41MjY0MzIxNiwgMC4zNjEyNDE2NywgMC4xODM3NDk1MV0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgVE5TX0NPRUZfMF80ID0gWzAuMDAwMDAwMDAsIC0wLjIwNzkxMTcwLCAtMC40MDY3MzY2NCwgLTAuNTg3Nzg1MjQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAtMC43NDMxNDQ4MSwgLTAuODY2MDI1MzksIC0wLjk1MTA1NjU0LCAtMC45OTQ1MjE5MixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAuOTk1NzM0MTYsIDAuOTYxODI1NjEsIDAuODk1MTYzMzAsIDAuNzk4MDE3MjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLjY3MzY5NTYyLCAwLjUyNjQzMjE2LCAwLjM2MTI0MTY3LCAwLjE4Mzc0OTUxXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICBUTlNfVEFCTEVTID0gW1ROU19DT0VGXzBfMywgVE5TX0NPRUZfMF80LCBUTlNfQ09FRl8xXzMsIFROU19DT0VGXzFfNF07XFxuICAgICAgICAgIFxcbiAgICBjb25zdCBUTlNfTUFYX0JBTkRTXzEwMjQgPSBbMzEsIDMxLCAzNCwgNDAsIDQyLCA1MSwgNDYsIDQ2LCA0MiwgNDIsIDQyLCAzOSwgMzldLFxcbiAgICAgICAgICBUTlNfTUFYX0JBTkRTXzEyOCA9IFs5LCA5LCAxMCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTRdO1xcbiAgICBcXG4gICAgVE5TLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHJlYW0sIGluZm8pIHtcXG4gICAgICAgIHZhciB3aW5kb3dDb3VudCA9IGluZm8ud2luZG93Q291bnQsXFxuICAgICAgICAgICAgYml0cyA9IGluZm8ud2luZG93U2VxdWVuY2UgPT09IElDU3RyZWFtLkVJR0hUX1NIT1JUX1NFUVVFTkNFID8gU0hPUlRfQklUUyA6IExPTkdfQklUUztcXG4gICAgICAgIFxcbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3aW5kb3dDb3VudDsgdysrKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMubkZpbHRbd10gPSBzdHJlYW0ucmVhZChiaXRzWzBdKSkge1xcbiAgICAgICAgICAgICAgICB2YXIgY29lZlJlcyA9IHN0cmVhbS5yZWFkKDEpLFxcbiAgICAgICAgICAgICAgICAgICAgbkZpbHRfdyA9IHRoaXMubkZpbHRbd10sXFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGhfdyA9IHRoaXMubGVuZ3RoW3ddLFxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJfdyA9IHRoaXMub3JkZXJbd10sXFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fdyA9IHRoaXMuZGlyZWN0aW9uW3ddLFxcbiAgICAgICAgICAgICAgICAgICAgY29lZl93ID0gdGhpcy5jb2VmW3ddO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmlsdCA9IDA7IGZpbHQgPCBuRmlsdF93OyBmaWx0KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aF93W2ZpbHRdID0gc3RyZWFtLnJlYWQoYml0c1sxXSk7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIGlmICgob3JkZXJfd1tmaWx0XSA9IHN0cmVhbS5yZWFkKGJpdHNbMl0pKSA+IDIwKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVE5TIGZpbHRlciBvdXQgb2YgcmFuZ2U6IFxcXCIgKyBvcmRlcl93W2ZpbHRdKTtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyX3dbZmlsdF0pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25fd1tmaWx0XSA9ICEhc3RyZWFtLnJlYWQoMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZDb21wcmVzcyA9IHN0cmVhbS5yZWFkKDEpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmTGVuID0gY29lZlJlcyArIDMgLSBjb2VmQ29tcHJlc3MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IDIgKiBjb2VmQ29tcHJlc3MgKyBjb2VmUmVzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IFROU19UQUJMRVNbdG1wXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJfd19maWx0ID0gb3JkZXJfd1tmaWx0XSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZl93X2ZpbHQgPSBjb2VmX3dbZmlsdF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJfd19maWx0OyBpKyspXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZfd19maWx0W2ldID0gdGFibGVbc3RyZWFtLnJlYWQoY29lZkxlbildO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBcXG4gICAgVE5TLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oaWNzLCBkYXRhLCBkZWNvZGUpIHtcXG4gICAgICAgIHZhciBtbW0gPSBNYXRoLm1pbih0aGlzLm1heEJhbmRzLCBpY3MubWF4U0ZCKSxcXG4gICAgICAgICAgICBscGMgPSB0aGlzLmxwYyxcXG4gICAgICAgICAgICB0bXAgPSB0aGlzLnRtcCxcXG4gICAgICAgICAgICBpbmZvID0gaWNzLmluZm8sXFxuICAgICAgICAgICAgd2luZG93Q291bnQgPSBpbmZvLndpbmRvd0NvdW50O1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3aW5kb3dDb3VudDsgdysrKSB7XFxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGluZm8uc3diQ291bnQsXFxuICAgICAgICAgICAgICAgIG5GaWx0X3cgPSB0aGlzLm5GaWx0W3ddLFxcbiAgICAgICAgICAgICAgICBsZW5ndGhfdyA9IHRoaXMubGVuZ3RoW3ddLFxcbiAgICAgICAgICAgICAgICBvcmRlcl93ID0gdGhpcy5vcmRlclt3XSxcXG4gICAgICAgICAgICAgICAgY29lZl93ID0gdGhpcy5jb2VmW3ddLFxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25fdyA9IHRoaXMuZGlyZWN0aW9uW3ddO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZvciAodmFyIGZpbHQgPSAwOyBmaWx0IDwgbkZpbHRfdzsgZmlsdCsrKSB7XFxuICAgICAgICAgICAgICAgIHZhciB0b3AgPSBib3R0b20sXFxuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heCgwLCB0bXAgLSBsZW5ndGhfd1tmaWx0XSksXFxuICAgICAgICAgICAgICAgICAgICBvcmRlciA9IG9yZGVyX3dbZmlsdF07XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyID09PSAwKSBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBscGMgY29lZmZpY2llbnRzXFxuICAgICAgICAgICAgICAgIHZhciBhdXRvYyA9IGNvZWZfd1tmaWx0XTtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IC1hdXRvY1tpXTtcXG4gICAgICAgICAgICAgICAgICAgIGxwY1tpXSA9IHI7XFxuICAgIFxcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IChpICsgMSkgPj4gMTsgaiA8IGxlbjsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBscGNbal0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBscGNbaSAtIDEgLSBqXTtcXG4gICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgbHBjW2pdID0gZiArIHIgKiBiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxwY1tpIC0gMSAtIGpdID0gYiArIHIgKiBmO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBpbmZvLnN3Yk9mZnNldHNbTWF0aC5taW4oYm90dG9tLCBtbW0pXSxcXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGluZm8uc3diT2Zmc2V0c1tNYXRoLm1pbih0b3AsIG1tbSldLFxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcXG4gICAgICAgICAgICAgICAgICAgIGluYyA9IDE7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgaWYgKChzaXplID0gZW5kIC0gc3RhcnQpIDw9IDApIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbl93W2ZpbHRdKSB7XFxuICAgICAgICAgICAgICAgICAgICBpbmMgPSAtMTtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kIC0gMTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gdyAqIDEyODtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGlmIChkZWNvZGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyIGZpbHRlclxcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzaXplOyBtKyssIHN0YXJ0ICs9IGluYykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IE1hdGgubWluKG0sIG9yZGVyKTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbc3RhcnRdIC09IGRhdGFbc3RhcnQgLSBpICogaW5jXSAqIGxwY1tpIC0gMV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gbWEgZmlsdGVyXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHNpemU7IG0rKywgc3RhcnQgKz0gaW5jKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wWzBdID0gZGF0YVtzdGFydF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gTWF0aC5taW4obSwgb3JkZXIpOyBpKyspXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbc3RhcnRdICs9IHRtcFtpXSAqIGxwY1tpIC0gMV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9yZGVyOyBpID4gMDsgaS0tKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbaV0gPSB0bXBbaSAtIDFdO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBcXG4gICAgcmV0dXJuIFROUztcXG5cXG59KSgpOy8vaW1wb3J0IFxcXCJ0bnMuanNcXFwiXFxuXFxudmFyIElDU3RyZWFtID0gKGZ1bmN0aW9uKCkge1xcbiAgICBcXG4gICAgLy8gSW5kaXZpZHVhbCBDaGFubmVsIFN0cmVhbVxcbiAgICBmdW5jdGlvbiBJQ1N0cmVhbShjb25maWcpIHtcXG4gICAgICAgIHRoaXMuaW5mbyA9IG5ldyBJQ1NJbmZvKCk7XFxuICAgICAgICB0aGlzLmJhbmRUeXBlcyA9IG5ldyBJbnQzMkFycmF5KE1BWF9TRUNUSU9OUyk7XFxuICAgICAgICB0aGlzLnNlY3RFbmQgPSBuZXcgSW50MzJBcnJheShNQVhfU0VDVElPTlMpO1xcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShjb25maWcuZnJhbWVMZW5ndGgpO1xcbiAgICAgICAgdGhpcy5zY2FsZUZhY3RvcnMgPSBuZXcgRmxvYXQzMkFycmF5KE1BWF9TRUNUSU9OUyk7XFxuICAgICAgICB0aGlzLnJhbmRvbVN0YXRlID0gMHgxRjJFM0Q0QztcXG4gICAgICAgIHRoaXMudG5zID0gbmV3IFROUyhjb25maWcpO1xcbiAgICAgICAgdGhpcy5zcGVjQnVmID0gbmV3IEludDMyQXJyYXkoNCk7XFxuICAgIH1cXG4gICAgICAgICAgXFxuICAgIElDU3RyZWFtLlpFUk9fQlQgPSAwOyAgICAgICAgIC8vIFNjYWxlZmFjdG9ycyBhbmQgc3BlY3RyYWwgZGF0YSBhcmUgYWxsIHplcm8uXFxuICAgIElDU3RyZWFtLkZJUlNUX1BBSVJfQlQgPSA1OyAgIC8vIFRoaXMgYW5kIGxhdGVyIGJhbmQgdHlwZXMgZW5jb2RlIHR3byB2YWx1ZXMgKHJhdGhlciB0aGFuIGZvdXIpIHdpdGggb25lIGNvZGUgd29yZC5cXG4gICAgSUNTdHJlYW0uRVNDX0JUID0gMTE7ICAgICAgICAgLy8gU3BlY3RyYWwgZGF0YSBhcmUgY29kZWQgd2l0aCBhbiBlc2NhcGUgc2VxdWVuY2UuXFxuICAgIElDU3RyZWFtLk5PSVNFX0JUID0gMTM7ICAgICAgIC8vIFNwZWN0cmFsIGRhdGEgYXJlIHNjYWxlZCB3aGl0ZSBub2lzZSBub3QgY29kZWQgaW4gdGhlIGJpdHN0cmVhbS5cXG4gICAgSUNTdHJlYW0uSU5URU5TSVRZX0JUMiA9IDE0OyAgLy8gU2NhbGVmYWN0b3IgZGF0YSBhcmUgaW50ZW5zaXR5IHN0ZXJlbyBwb3NpdGlvbnMuXFxuICAgIElDU3RyZWFtLklOVEVOU0lUWV9CVCA9IDE1OyAgIC8vIFNjYWxlZmFjdG9yIGRhdGEgYXJlIGludGVuc2l0eSBzdGVyZW8gcG9zaXRpb25zLlxcbiAgICBcXG4gICAgSUNTdHJlYW0uT05MWV9MT05HX1NFUVVFTkNFID0gMDtcXG4gICAgSUNTdHJlYW0uTE9OR19TVEFSVF9TRVFVRU5DRSA9IDE7XFxuICAgIElDU3RyZWFtLkVJR0hUX1NIT1JUX1NFUVVFTkNFID0gMjtcXG4gICAgSUNTdHJlYW0uTE9OR19TVE9QX1NFUVVFTkNFID0gMztcXG4gICAgXFxuICAgIGNvbnN0IE1BWF9TRUNUSU9OUyA9IDEyMCxcXG4gICAgICAgICAgTUFYX1dJTkRPV19HUk9VUF9DT1VOVCA9IDg7XFxuICAgIFxcbiAgICBjb25zdCBTRl9ERUxUQSA9IDYwLFxcbiAgICAgICAgICBTRl9PRkZTRVQgPSAyMDA7XFxuICAgIFxcbiAgICBJQ1N0cmVhbS5wcm90b3R5cGUgPSB7XFxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uKHN0cmVhbSwgY29uZmlnLCBjb21tb25XaW5kb3cpIHtcXG4gICAgICAgICAgICB0aGlzLmdsb2JhbEdhaW4gPSBzdHJlYW0ucmVhZCg4KTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBpZiAoIWNvbW1vbldpbmRvdylcXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmRlY29kZShzdHJlYW0sIGNvbmZpZywgY29tbW9uV2luZG93KTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgdGhpcy5kZWNvZGVCYW5kVHlwZXMoc3RyZWFtLCBjb25maWcpO1xcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlU2NhbGVGYWN0b3JzKHN0cmVhbSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgaWYgKHRoaXMucHVsc2VQcmVzZW50ID0gc3RyZWFtLnJlYWQoMSkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mby53aW5kb3dTZXF1ZW5jZSA9PT0gSUNTdHJlYW0uRUlHSFRfU0hPUlRfU0VRVUVOQ0UpXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlB1bHNlIHRvb2wgbm90IGFsbG93ZWQgaW4gZWlnaHQgc2hvcnQgc2VxdWVuY2UuXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVQdWxzZURhdGEoc3RyZWFtKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgaWYgKHRoaXMudG5zUHJlc2VudCA9IHN0cmVhbS5yZWFkKDEpKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudG5zLmRlY29kZShzdHJlYW0sIHRoaXMuaW5mbyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGlmICh0aGlzLmdhaW5QcmVzZW50ID0gc3RyZWFtLnJlYWQoMSkpIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJUT0RPOiBkZWNvZGUgZ2FpbiBjb250cm9sL1NTUlxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICB0aGlzLmRlY29kZVNwZWN0cmFsRGF0YShzdHJlYW0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcbiAgICAgICAgZGVjb2RlQmFuZFR5cGVzOiBmdW5jdGlvbihzdHJlYW0sIGNvbmZpZykge1xcbiAgICAgICAgICAgIHZhciBiaXRzID0gdGhpcy5pbmZvLndpbmRvd1NlcXVlbmNlID09PSBJQ1N0cmVhbS5FSUdIVF9TSE9SVF9TRVFVRU5DRSA/IDMgOiA1LFxcbiAgICAgICAgICAgICAgICBncm91cENvdW50ID0gdGhpcy5pbmZvLmdyb3VwQ291bnQsXFxuICAgICAgICAgICAgICAgIG1heFNGQiA9IHRoaXMuaW5mby5tYXhTRkIsXFxuICAgICAgICAgICAgICAgIGJhbmRUeXBlcyA9IHRoaXMuYmFuZFR5cGVzLFxcbiAgICAgICAgICAgICAgICBzZWN0RW5kID0gdGhpcy5zZWN0RW5kLFxcbiAgICAgICAgICAgICAgICBpZHggPSAwLFxcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSAoMSA8PCBiaXRzKSAtIDE7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBncm91cENvdW50OyBnKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIGsgPSAwO1xcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA8IG1heFNGQikge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGssXFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFuZFR5cGUgPSBzdHJlYW0ucmVhZCg0KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYW5kVHlwZSA9PT0gMTIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJJbnZhbGlkIGJhbmQgdHlwZTogMTJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmNyO1xcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpbmNyID0gc3RyZWFtLnJlYWQoYml0cykpID09PSBlc2NhcGUpXFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kICs9IGluY3I7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICBlbmQgKz0gaW5jcjtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IG1heFNGQilcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlRvbyBtYW55IGJhbmRzIChcXFwiICsgZW5kICsgXFxcIiA+IFxcXCIgKyBtYXhTRkIgKyBcXFwiKVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGsgPCBlbmQ7IGsrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbmRUeXBlc1tpZHhdID0gYmFuZFR5cGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdEVuZFtpZHgrK10gPSBlbmQ7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxuICAgICAgICBkZWNvZGVTY2FsZUZhY3RvcnM6IGZ1bmN0aW9uKHN0cmVhbSkge1xcbiAgICAgICAgICAgIHZhciBncm91cENvdW50ID0gdGhpcy5pbmZvLmdyb3VwQ291bnQsXFxuICAgICAgICAgICAgICAgIG1heFNGQiA9IHRoaXMuaW5mby5tYXhTRkIsXFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IFt0aGlzLmdsb2JhbEdhaW4sIHRoaXMuZ2xvYmFsR2FpbiAtIDkwLCAwXSwgLy8gc3BlY3RydW0sIG5vaXNlLCBpbnRlbnNpdHlcXG4gICAgICAgICAgICAgICAgaWR4ID0gMCxcXG4gICAgICAgICAgICAgICAgbm9pc2VGbGFnID0gdHJ1ZSxcXG4gICAgICAgICAgICAgICAgc2NhbGVGYWN0b3JzID0gdGhpcy5zY2FsZUZhY3RvcnMsXFxuICAgICAgICAgICAgICAgIHNlY3RFbmQgPSB0aGlzLnNlY3RFbmQsXFxuICAgICAgICAgICAgICAgIGJhbmRUeXBlcyA9IHRoaXMuYmFuZFR5cGVzO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGdyb3VwQ291bnQ7IGcrKykge1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heFNGQjspIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBydW5FbmQgPSBzZWN0RW5kW2lkeF07XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYmFuZFR5cGVzW2lkeF0pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIElDU3RyZWFtLlpFUk9fQlQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcnVuRW5kOyBpKyssIGlkeCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZUZhY3RvcnNbaWR4XSA9IDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSUNTdHJlYW0uSU5URU5TSVRZX0JUOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSUNTdHJlYW0uSU5URU5TSVRZX0JUMjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKDsgaSA8IHJ1bkVuZDsgaSsrLCBpZHgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WzJdICs9IEh1ZmZtYW4uZGVjb2RlU2NhbGVGYWN0b3Ioc3RyZWFtKSAtIFNGX0RFTFRBO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IE1hdGgubWluKE1hdGgubWF4KG9mZnNldFsyXSwgLTE1NSksIDEwMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZUZhY3RvcnNbaWR4XSA9IFNDQUxFRkFDVE9SX1RBQkxFWy10bXAgKyBTRl9PRkZTRVRdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIElDU3RyZWFtLk5PSVNFX0JUOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoOyBpIDwgcnVuRW5kOyBpKyssIGlkeCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9pc2VGbGFnKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WzFdICs9IHN0cmVhbS5yZWFkKDkpIC0gMjU2O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vaXNlRmxhZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRbMV0gKz0gSHVmZm1hbi5kZWNvZGVTY2FsZUZhY3RvcihzdHJlYW0pIC0gU0ZfREVMVEE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5taW4oTWF0aC5tYXgob2Zmc2V0WzFdLCAtMTAwKSwgMTU1KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlRmFjdG9yc1tpZHhdID0gLVNDQUxFRkFDVE9SX1RBQkxFW3RtcCArIFNGX09GRlNFVF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcig7IGkgPCBydW5FbmQ7IGkrKywgaWR4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFswXSArPSBIdWZmbWFuLmRlY29kZVNjYWxlRmFjdG9yKHN0cmVhbSkgLSBTRl9ERUxUQTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9mZnNldFswXSA+IDI1NSkgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJTY2FsZWZhY3RvciBvdXQgb2YgcmFuZ2U6IFxcXCIgKyBvZmZzZXRbMF0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVGYWN0b3JzW2lkeF0gPSBTQ0FMRUZBQ1RPUl9UQUJMRVtvZmZzZXRbMF0gLSAxMDAgKyBTRl9PRkZTRVRdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcbiAgICAgICAgZGVjb2RlUHVsc2VEYXRhOiBmdW5jdGlvbihzdHJlYW0pIHtcXG4gICAgICAgICAgICB2YXIgcHVsc2VDb3VudCA9IHN0cmVhbS5yZWFkKDIpICsgMSxcXG4gICAgICAgICAgICAgICAgcHVsc2VTV0IgPSBzdHJlYW0ucmVhZCg2KTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgaWYgKHB1bHNlU1dCID49IHRoaXMuaW5mby5zd2JDb3VudClcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJQdWxzZSBTV0Igb3V0IG9mIHJhbmdlOiBcXFwiICsgcHVsc2VTV0IpO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICBpZiAoIXRoaXMucHVsc2VPZmZzZXQgfHwgdGhpcy5wdWxzZU9mZnNldC5sZW5ndGggIT09IHB1bHNlQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgLy8gb25seSByZWFsbG9jYXRlIGlmIG5lZWRlZFxcbiAgICAgICAgICAgICAgICB0aGlzLnB1bHNlT2Zmc2V0ID0gbmV3IEludDMyQXJyYXkocHVsc2VDb3VudCk7XFxuICAgICAgICAgICAgICAgIHRoaXMucHVsc2VBbXAgPSBuZXcgSW50MzJBcnJheShwdWxzZUNvdW50KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgdGhpcy5wdWxzZU9mZnNldFswXSA9IHRoaXMuaW5mby5zd2JPZmZzZXRzW3B1bHNlU1dCXSArIHN0cmVhbS5yZWFkKDUpO1xcbiAgICAgICAgICAgIHRoaXMucHVsc2VBbXBbMF0gPSBzdHJlYW0ucmVhZCg0KTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBpZiAodGhpcy5wdWxzZU9mZnNldFswXSA+IDEwMjMpXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiUHVsc2Ugb2Zmc2V0IG91dCBvZiByYW5nZTogXFxcIiArIHRoaXMucHVsc2VPZmZzZXRbMF0pO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcHVsc2VDb3VudDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucHVsc2VPZmZzZXRbaV0gPSBzdHJlYW0ucmVhZCg1KSArIHRoaXMucHVsc2VPZmZzZXRbaSAtIDFdO1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdWxzZU9mZnNldFtpXSA+IDEwMjMpXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlB1bHNlIG9mZnNldCBvdXQgb2YgcmFuZ2U6IFxcXCIgKyB0aGlzLnB1bHNlT2Zmc2V0W2ldKTtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICB0aGlzLnB1bHNlQW1wW2ldID0gc3RyZWFtLnJlYWQoNCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcbiAgICAgICAgZGVjb2RlU3BlY3RyYWxEYXRhOiBmdW5jdGlvbihzdHJlYW0pIHtcXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcXG4gICAgICAgICAgICAgICAgaW5mbyA9IHRoaXMuaW5mbyxcXG4gICAgICAgICAgICAgICAgbWF4U0ZCID0gaW5mby5tYXhTRkIsXFxuICAgICAgICAgICAgICAgIHdpbmRvd0dyb3VwcyA9IGluZm8uZ3JvdXBDb3VudCxcXG4gICAgICAgICAgICAgICAgb2Zmc2V0cyA9IGluZm8uc3diT2Zmc2V0cyxcXG4gICAgICAgICAgICAgICAgYmFuZFR5cGVzID0gdGhpcy5iYW5kVHlwZXMsXFxuICAgICAgICAgICAgICAgIHNjYWxlRmFjdG9ycyA9IHRoaXMuc2NhbGVGYWN0b3JzLFxcbiAgICAgICAgICAgICAgICBidWYgPSB0aGlzLnNwZWNCdWY7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHZhciBncm91cE9mZiA9IDAsIGlkeCA9IDA7XFxuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCB3aW5kb3dHcm91cHM7IGcrKykge1xcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBMZW4gPSBpbmZvLmdyb3VwTGVuZ3RoW2ddO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgbWF4U0ZCOyBzZmIrKywgaWR4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBoY2IgPSBiYW5kVHlwZXNbaWR4XSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBncm91cE9mZiArIG9mZnNldHNbc2ZiXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG9mZnNldHNbc2ZiICsgMV0gLSBvZmZzZXRzW3NmYl07XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaGNiID09PSBJQ1N0cmVhbS5aRVJPX0JUIHx8IGhjYiA9PT0gSUNTdHJlYW0uSU5URU5TSVRZX0JUIHx8IGhjYiA9PT0gSUNTdHJlYW0uSU5URU5TSVRZX0JUMikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGdyb3VwID0gMDsgZ3JvdXAgPCBncm91cExlbjsgZ3JvdXArKywgb2ZmICs9IDEyOCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb2ZmOyBpIDwgb2ZmICsgd2lkdGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXSA9IDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhjYiA9PT0gSUNTdHJlYW0uTk9JU0VfQlQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWxsIHdpdGggcmFuZG9tIHZhbHVlc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGdyb3VwID0gMDsgZ3JvdXAgPCBncm91cExlbjsgZ3JvdXArKywgb2ZmICs9IDEyOCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5lcmd5ID0gMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgd2lkdGg7IGsrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5kb21TdGF0ZSAqPSAxNjY0NTI1ICsgMTAxMzkwNDIyMztcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2ZmICsga10gPSB0aGlzLnJhbmRvbVN0YXRlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5lcmd5ICs9IGRhdGFbb2ZmICsga10gKiBkYXRhW29mZiArIGtdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUZhY3RvcnNbaWR4XSAvIE1hdGguc3FydChlbmVyZ3kpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHdpZHRoOyBrKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2ZmICsga10gKj0gc2NhbGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGdyb3VwID0gMDsgZ3JvdXAgPCBncm91cExlbjsgZ3JvdXArKywgb2ZmICs9IDEyOCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gKGhjYiA+PSBJQ1N0cmVhbS5GSVJTVF9QQUlSX0JUKSA/IDIgOiA0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHdpZHRoOyBrICs9IG51bSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSHVmZm1hbi5kZWNvZGVTcGVjdHJhbERhdGEoc3RyZWFtLCBoY2IsIGJ1ZiwgMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludmVyc2UgcXVhbnRpemF0aW9uICYgc2NhbGluZ1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW07IGorKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2ZmICsgayArIGpdID0gKGJ1ZltqXSA+IDApID8gSVFfVEFCTEVbYnVmW2pdXSA6IC1JUV9UQUJMRVstYnVmW2pdXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29mZiArIGsgKyBqXSAqPSBzY2FsZUZhY3RvcnNbaWR4XTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBncm91cE9mZiArPSBncm91cExlbiA8PCA3O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAvLyBhZGQgcHVsc2UgZGF0YSwgaWYgcHJlc2VudFxcbiAgICAgICAgICAgIGlmICh0aGlzLnB1bHNlUHJlc2VudCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RPRE86IGFkZCBwdWxzZSBkYXRhJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIFxcbiAgICAvLyBJbmRpdmlkdWFsIENoYW5uZWwgU3RyZWFtIEluZm9cXG4gICAgZnVuY3Rpb24gSUNTSW5mbygpIHtcXG4gICAgICAgIHRoaXMud2luZG93U2hhcGUgPSBuZXcgSW50MzJBcnJheSgyKTtcXG4gICAgICAgIHRoaXMud2luZG93U2VxdWVuY2UgPSBJQ1N0cmVhbS5PTkxZX0xPTkdfU0VRVUVOQ0U7XFxuICAgICAgICB0aGlzLmdyb3VwTGVuZ3RoID0gbmV3IEludDMyQXJyYXkoTUFYX1dJTkRPV19HUk9VUF9DT1VOVCk7XFxuICAgICAgICB0aGlzLmx0cERhdGExUHJlc2VudCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5sdHBEYXRhMlByZXNlbnQgPSBmYWxzZTtcXG4gICAgfVxcbiAgICBcXG4gICAgSUNTSW5mby5wcm90b3R5cGUgPSB7XFxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uKHN0cmVhbSwgY29uZmlnLCBjb21tb25XaW5kb3cpIHtcXG4gICAgICAgICAgICBzdHJlYW0uYWR2YW5jZSgxKTsgLy8gcmVzZXJ2ZWRcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICB0aGlzLndpbmRvd1NlcXVlbmNlID0gc3RyZWFtLnJlYWQoMik7XFxuICAgICAgICAgICAgdGhpcy53aW5kb3dTaGFwZVswXSA9IHRoaXMud2luZG93U2hhcGVbMV07XFxuICAgICAgICAgICAgdGhpcy53aW5kb3dTaGFwZVsxXSA9IHN0cmVhbS5yZWFkKDEpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBDb3VudCA9IDE7XFxuICAgICAgICAgICAgdGhpcy5ncm91cExlbmd0aFswXSA9IDE7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgaWYgKHRoaXMud2luZG93U2VxdWVuY2UgPT09IElDU3RyZWFtLkVJR0hUX1NIT1JUX1NFUVVFTkNFKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMubWF4U0ZCID0gc3RyZWFtLnJlYWQoNCk7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNzsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnJlYWQoMSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwTGVuZ3RoW3RoaXMuZ3JvdXBDb3VudCAtIDFdKys7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDb3VudCsrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBMZW5ndGhbdGhpcy5ncm91cENvdW50IC0gMV0gPSAxO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvd0NvdW50ID0gODtcXG4gICAgICAgICAgICAgICAgdGhpcy5zd2JPZmZzZXRzID0gU1dCX09GRlNFVF8xMjhbY29uZmlnLnNhbXBsZUluZGV4XTtcXG4gICAgICAgICAgICAgICAgdGhpcy5zd2JDb3VudCA9IFNXQl9TSE9SVF9XSU5ET1dfQ09VTlRbY29uZmlnLnNhbXBsZUluZGV4XTtcXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVkaWN0b3JQcmVzZW50ID0gZmFsc2U7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhTRkIgPSBzdHJlYW0ucmVhZCg2KTtcXG4gICAgICAgICAgICAgICAgdGhpcy53aW5kb3dDb3VudCA9IDE7XFxuICAgICAgICAgICAgICAgIHRoaXMuc3diT2Zmc2V0cyA9IFNXQl9PRkZTRVRfMTAyNFtjb25maWcuc2FtcGxlSW5kZXhdO1xcbiAgICAgICAgICAgICAgICB0aGlzLnN3YkNvdW50ID0gU1dCX0xPTkdfV0lORE9XX0NPVU5UW2NvbmZpZy5zYW1wbGVJbmRleF07XFxuICAgICAgICAgICAgICAgIHRoaXMucHJlZGljdG9yUHJlc2VudCA9ICEhc3RyZWFtLnJlYWQoMSk7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVkaWN0b3JQcmVzZW50KVxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVQcmVkaWN0aW9uKHN0cmVhbSwgY29uZmlnLCBjb21tb25XaW5kb3cpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBcXG4gICAgICAgIGRlY29kZVByZWRpY3Rpb246IGZ1bmN0aW9uKHN0cmVhbSwgY29uZmlnLCBjb21tb25XaW5kb3cpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByZWRpY3Rpb24gbm90IGltcGxlbWVudGVkLicpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHN3aXRjaCAoY29uZmlnLnByb2ZpbGUpIHtcXG4gICAgICAgICAgICAgICAgY2FzZSBBT1RfQUFDX01BSU46XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByZWRpY3Rpb24gbm90IGltcGxlbWVudGVkLicpO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgY2FzZSBBT1RfQUFDX0xUUDpcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTFRQIHByZWRpY3Rpb24gbm90IGltcGxlbWVudGVkLicpO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJvZmlsZSBmb3IgcHJlZGljdGlvbiAnICsgY29uZmlnLnByb2ZpbGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgXFxuICAgIHJldHVybiBJQ1N0cmVhbTtcXG4gICAgXFxufSkoKTsvL2ltcG9ydCBcXFwiaWNzLmpzXFxcIlxcbi8qXFxuICogQUFDLmpzIC0gQWR2YW5jZWQgQXVkaW8gQ29kaW5nIGRlY29kZXIgaW4gSmF2YVNjcmlwdFxcbiAqIENyZWF0ZWQgYnkgRGV2b24gR292ZXR0XFxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBPZmZpY2lhbC5mbSBMYWJzXFxuICpcXG4gKiBBQUMuanMgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCBcXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBcXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgXFxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cXG4gKlxcbiAqIEFBQy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBcXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgXFxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBcXG4gKiBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAqXFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuXFxuICogSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxcbiAqL1xcblxcbi8vaW1wb3J0IFxcXCJpY3MuanNcXFwiXFxuXFxudmFyIENQRUVsZW1lbnQgPSAoZnVuY3Rpb24oKSB7XFxuICAgIFxcbiAgICAvLyBDaGFubmVsIFBhaXIgRWxlbWVudFxcbiAgICBmdW5jdGlvbiBDUEVFbGVtZW50KGNvbmZpZykge1xcbiAgICAgICAgdGhpcy5tc191c2VkID0gW107XFxuICAgICAgICB0aGlzLmxlZnQgPSBuZXcgSUNTdHJlYW0oY29uZmlnKTtcXG4gICAgICAgIHRoaXMucmlnaHQgPSBuZXcgSUNTdHJlYW0oY29uZmlnKTtcXG4gICAgfVxcbiAgICBcXG4gICAgY29uc3QgTUFYX01TX01BU0sgPSAxMjg7XFxuICAgIFxcbiAgICBjb25zdCBNQVNLX1RZUEVfQUxMXzAgPSAwLFxcbiAgICAgICAgICBNQVNLX1RZUEVfVVNFRCA9IDEsXFxuICAgICAgICAgIE1BU0tfVFlQRV9BTExfMSA9IDIsXFxuICAgICAgICAgIE1BU0tfVFlQRV9SRVNFUlZFRCA9IDM7XFxuICAgIFxcbiAgICBDUEVFbGVtZW50LnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHJlYW0sIGNvbmZpZykge1xcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQsXFxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnJpZ2h0LFxcbiAgICAgICAgICAgIG1zX3VzZWQgPSB0aGlzLm1zX3VzZWQ7XFxuICAgICAgICAgICAgXFxuICAgICAgICBpZiAodGhpcy5jb21tb25XaW5kb3cgPSAhIXN0cmVhbS5yZWFkKDEpKSB7XFxuICAgICAgICAgICAgbGVmdC5pbmZvLmRlY29kZShzdHJlYW0sIGNvbmZpZywgdHJ1ZSk7XFxuICAgICAgICAgICAgcmlnaHQuaW5mbyA9IGxlZnQuaW5mbztcXG4gICAgXFxuICAgICAgICAgICAgdmFyIG1hc2sgPSBzdHJlYW0ucmVhZCgyKTtcXG4gICAgICAgICAgICB0aGlzLm1hc2tQcmVzZW50ID0gISFtYXNrO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHN3aXRjaCAobWFzaykge1xcbiAgICAgICAgICAgICAgICBjYXNlIE1BU0tfVFlQRV9VU0VEOlxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxlZnQuaW5mby5ncm91cENvdW50ICogbGVmdC5pbmZvLm1heFNGQjtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtc191c2VkW2ldID0gISFzdHJlYW0ucmVhZCgxKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgY2FzZSBNQVNLX1RZUEVfQUxMXzA6ICAgIFxcbiAgICAgICAgICAgICAgICBjYXNlIE1BU0tfVFlQRV9BTExfMTpcXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSAhIW1hc2s7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1BWF9NU19NQVNLOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtc191c2VkW2ldID0gdmFsO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiUmVzZXJ2ZWQgbXMgbWFzayB0eXBlOiBcXFwiICsgbWFzayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1BWF9NU19NQVNLOyBpKyspXFxuICAgICAgICAgICAgICAgIG1zX3VzZWRbaV0gPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgbGVmdC5kZWNvZGUoc3RyZWFtLCBjb25maWcsIHRoaXMuY29tbW9uV2luZG93KTtcXG4gICAgICAgIHJpZ2h0LmRlY29kZShzdHJlYW0sIGNvbmZpZywgdGhpcy5jb21tb25XaW5kb3cpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgcmV0dXJuIENQRUVsZW1lbnQ7XFxuICAgIFxcbn0pKCk7Ly9pbXBvcnQgXFxcImNwZS5qc1xcXCJcXG4vKlxcbiAqIEFBQy5qcyAtIEFkdmFuY2VkIEF1ZGlvIENvZGluZyBkZWNvZGVyIGluIEphdmFTY3JpcHRcXG4gKiBDcmVhdGVkIGJ5IERldm9uIEdvdmV0dFxcbiAqIENvcHlyaWdodCAoYykgMjAxMiwgT2ZmaWNpYWwuZm0gTGFic1xcbiAqXFxuICogQUFDLmpzIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQgXFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgXFxuICogcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIFxcbiAqIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXFxuICpcXG4gKiBBQUMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVQgXFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIFxcbiAqIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgXFxuICogUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cXG4gKlxcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcXG4gKiBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5LlxcbiAqIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cXG4gKi9cXG5cXG52YXIgQ0NFRWxlbWVudCA9IChmdW5jdGlvbigpIHtcXG4gICAgXFxuICAgIC8vIENoYW5uZWwgQ291cGxpbmcgRWxlbWVudFxcbiAgICBmdW5jdGlvbiBDQ0VFbGVtZW50KGNvbmZpZykge1xcbiAgICAgICAgdGhpcy5pY3MgPSBuZXcgSUNTdHJlYW0oY29uZmlnKTtcXG4gICAgICAgIHRoaXMuY2hhbm5lbFBhaXIgPSBuZXcgQXJyYXkoOCk7XFxuICAgICAgICB0aGlzLmlkU2VsZWN0ID0gbmV3IEludDMyQXJyYXkoOCk7XFxuICAgICAgICB0aGlzLmNoU2VsZWN0ID0gbmV3IEludDMyQXJyYXkoOCk7XFxuICAgICAgICB0aGlzLmdhaW4gPSBuZXcgQXJyYXkoMTYpO1xcbiAgICB9XFxuICAgIFxcbiAgICBDQ0VFbGVtZW50LkJFRk9SRV9UTlMgPSAwO1xcbiAgICBDQ0VFbGVtZW50LkFGVEVSX1ROUyA9IDE7XFxuICAgIENDRUVsZW1lbnQuQUZURVJfSU1EQ1QgPSAyO1xcbiAgICBcXG4gICAgY29uc3QgQ0NFX1NDQUxFID0gbmV3IEZsb2F0MzJBcnJheShbXFxuICAgICAgICAxLjA5MDUwNzczMjY2NTI1NzY1OTIxLFxcbiAgICAgICAgMS4xODkyMDcxMTUwMDI3MjEwNjY3MixcXG4gICAgICAgIDEuNDE0MjEzNTYyMzczMDk1MDQ4ODAxNjg4NyxcXG4gICAgICAgIDIuMFxcbiAgICBdKTtcXG4gICAgXFxuICAgIENDRUVsZW1lbnQucHJvdG90eXBlID0ge1xcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbihzdHJlYW0sIGNvbmZpZykge1xcbiAgICAgICAgICAgIHZhciBjaGFubmVsUGFpciA9IHRoaXMuY2hhbm5lbFBhaXIsXFxuICAgICAgICAgICAgICAgIGlkU2VsZWN0ID0gdGhpcy5pZFNlbGVjdCxcXG4gICAgICAgICAgICAgICAgY2hTZWxlY3QgPSB0aGlzLmNoU2VsZWN0O1xcbiAgICBcXG4gICAgICAgICAgICB0aGlzLmNvdXBsaW5nUG9pbnQgPSAyICogc3RyZWFtLnJlYWQoMSk7XFxuICAgICAgICAgICAgdGhpcy5jb3VwbGVkQ291bnQgPSBzdHJlYW0ucmVhZCgzKTtcXG4gICAgXFxuICAgICAgICAgICAgdmFyIGdhaW5Db3VudCA9IDA7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdGhpcy5jb3VwbGVkQ291bnQ7IGkrKykge1xcbiAgICAgICAgICAgICAgICBnYWluQ291bnQrKztcXG4gICAgICAgICAgICAgICAgY2hhbm5lbFBhaXJbaV0gPSBzdHJlYW0ucmVhZCgxKTtcXG4gICAgICAgICAgICAgICAgaWRTZWxlY3RbaV0gPSBzdHJlYW0ucmVhZCg0KTtcXG4gICAgXFxuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsUGFpcltpXSkge1xcbiAgICAgICAgICAgICAgICAgICAgY2hTZWxlY3RbaV0gPSBzdHJlYW0ucmVhZCgyKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaFNlbGVjdFtpXSA9PT0gMylcXG4gICAgICAgICAgICAgICAgICAgICAgICBnYWluQ291bnQrKztcXG4gICAgXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBjaFNlbGVjdFtpXSA9IDI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgICAgIHRoaXMuY291cGxpbmdQb2ludCArPSBzdHJlYW0ucmVhZCgxKSB8fCAodGhpcy5jb3VwbGluZ1BvaW50ID4+PiAxKTtcXG4gICAgXFxuICAgICAgICAgICAgdmFyIHNpZ24gPSBzdHJlYW0ucmVhZCgxKSxcXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBDQ0VfU0NBTEVbc3RyZWFtLnJlYWQoMildO1xcbiAgICBcXG4gICAgICAgICAgICB0aGlzLmljcy5kZWNvZGUoc3RyZWFtLCBjb25maWcsIGZhbHNlKTtcXG4gICAgXFxuICAgICAgICAgICAgdmFyIGdyb3VwQ291bnQgPSB0aGlzLmljcy5pbmZvLmdyb3VwQ291bnQsXFxuICAgICAgICAgICAgICAgIG1heFNGQiA9IHRoaXMuaWNzLmluZm8ubWF4U0ZCLFxcbiAgICAgICAgICAgICAgICBiYW5kVHlwZXMgPSB0aGlzLmljcy5iYW5kVHlwZXM7XFxuICAgIFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FpbkNvdW50OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IDAsXFxuICAgICAgICAgICAgICAgICAgICBjZ2UgPSAxLFxcbiAgICAgICAgICAgICAgICAgICAgZ2FpbiA9IDAsXFxuICAgICAgICAgICAgICAgICAgICBnYWluQ2FjaGUgPSAxO1xcbiAgICBcXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBjZ2UgPSB0aGlzLmNvdXBsaW5nUG9pbnQgPT09IENDRUVsZW1lbnQuQUZURVJfSU1EQ1QgPyAxIDogc3RyZWFtLnJlYWQoMSk7XFxuICAgICAgICAgICAgICAgICAgICBnYWluID0gY2dlID8gSHVmZm1hbi5kZWNvZGVTY2FsZUZhY3RvcihzdHJlYW0pIC0gNjAgOiAwO1xcbiAgICAgICAgICAgICAgICAgICAgZ2FpbkNhY2hlID0gTWF0aC5wb3coc2NhbGUsIC1nYWluKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICBcXG4gICAgICAgICAgICAgICAgdmFyIGdhaW5faSA9IHRoaXMuZ2FpbltpXSA9IG5ldyBGbG9hdDMyQXJyYXkoMTIwKTtcXG4gICAgXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdXBsaW5nUG9pbnQgPT09IENDRUVsZW1lbnQuQUZURVJfSU1EQ1QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGdhaW5faVswXSA9IGdhaW5DYWNoZTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgZ3JvdXBDb3VudDsgZysrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgbWF4U0ZCOyBzZmIrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFuZFR5cGVzW2lkeF0gIT09IElDU3RyZWFtLlpFUk9fQlQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZ2UgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IEh1ZmZtYW4uZGVjb2RlU2NhbGVGYWN0b3Ioc3RyZWFtKSAtIDYwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICE9PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGdhaW4gKz0gdDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ24pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgLT0gMiAqICh0ICogMHgxKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPj4+PSAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5DYWNoZSA9IE1hdGgucG93KHNjYWxlLCAtdCkgKiBzO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5faVtpZHgrK10gPSBnYWluQ2FjaGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICBcXG4gICAgICAgIGFwcGx5SW5kZXBlbmRlbnRDb3VwbGluZzogZnVuY3Rpb24oaW5kZXgsIGRhdGEpIHtcXG4gICAgICAgICAgICB2YXIgZ2FpbiA9IHRoaXMuZ2FpbltpbmRleF1bMF0sXFxuICAgICAgICAgICAgICAgIGlxRGF0YSA9IHRoaXMuaWNzLmRhdGE7XFxuICAgIFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBkYXRhW2ldICs9IGdhaW4gKiBpcURhdGFbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgXFxuICAgICAgICBhcHBseURlcGVuZGVudENvdXBsaW5nOiBmdW5jdGlvbihpbmRleCwgZGF0YSkge1xcbiAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5pY3MuaW5mbyxcXG4gICAgICAgICAgICAgICAgc3diT2Zmc2V0cyA9IGluZm8uc3diT2Zmc2V0cyxcXG4gICAgICAgICAgICAgICAgZ3JvdXBDb3VudCA9IGluZm8uZ3JvdXBDb3VudCxcXG4gICAgICAgICAgICAgICAgbWF4U0ZCID0gaW5mby5tYXhTRkIsXFxuICAgICAgICAgICAgICAgIGJhbmRUeXBlcyA9IHRoaXMuaWNzLmJhbmRUeXBlcyxcXG4gICAgICAgICAgICAgICAgaXFEYXRhID0gdGhpcy5pY3MuZGF0YTtcXG4gICAgXFxuICAgICAgICAgICAgdmFyIGlkeCA9IDAsXFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IDAsXFxuICAgICAgICAgICAgICAgIGdhaW5zID0gdGhpcy5nYWluW2luZGV4XTtcXG4gICAgXFxuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBncm91cENvdW50OyBnKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGluZm8uZ3JvdXBMZW5ndGhbZ107XFxuICAgIFxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBtYXhTRkI7IHNmYisrLCBpZHgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhbmRUeXBlc1tpZHhdICE9PSBJQ1N0cmVhbS5aRVJPX0JUKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdhaW4gPSBnYWluc1tpZHhdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGdyb3VwID0gMDsgZ3JvdXAgPCBsZW47IGdyb3VwKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IHN3Yk9mZnNldHNbc2ZiXTsgayA8IHN3Yk9mZnNldHNbc3diICsgMV07IGsrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyBncm91cCAqIDEyOCArIGtdICs9IGdhaW4gKiBpcURhdGFbb2Zmc2V0ICsgZ3JvdXAgKiAxMjggKyBrXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICBcXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbiAqIDEyODtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICByZXR1cm4gQ0NFRWxlbWVudDtcXG4gICAgXFxufSkoKTsvL2ltcG9ydCBcXFwiY2NlLmpzXFxcIlxcbi8qXFxuICogQUFDLmpzIC0gQWR2YW5jZWQgQXVkaW8gQ29kaW5nIGRlY29kZXIgaW4gSmF2YVNjcmlwdFxcbiAqIENyZWF0ZWQgYnkgRGV2b24gR292ZXR0XFxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBPZmZpY2lhbC5mbSBMYWJzXFxuICpcXG4gKiBBQUMuanMgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCBcXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBcXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgXFxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cXG4gKlxcbiAqIEFBQy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBcXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgXFxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBcXG4gKiBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAqXFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuXFxuICogSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxcbiAqL1xcblxcbi8qXFxuICogQUFDLmpzIC0gQWR2YW5jZWQgQXVkaW8gQ29kaW5nIGRlY29kZXIgaW4gSmF2YVNjcmlwdFxcbiAqIENyZWF0ZWQgYnkgRGV2b24gR292ZXR0XFxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBPZmZpY2lhbC5mbSBMYWJzXFxuICpcXG4gKiBBQUMuanMgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCBcXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBcXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgXFxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cXG4gKlxcbiAqIEFBQy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBcXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgXFxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBcXG4gKiBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAqXFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuXFxuICogSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxcbiAqL1xcblxcbi8qXFxuICogQUFDLmpzIC0gQWR2YW5jZWQgQXVkaW8gQ29kaW5nIGRlY29kZXIgaW4gSmF2YVNjcmlwdFxcbiAqIENyZWF0ZWQgYnkgRGV2b24gR292ZXR0XFxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBPZmZpY2lhbC5mbSBMYWJzXFxuICpcXG4gKiBBQUMuanMgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCBcXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBcXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgXFxuICogTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cXG4gKlxcbiAqIEFBQy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBcXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgXFxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBcXG4gKiBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAqXFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnkuXFxuICogSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxcbiAqL1xcblxcbmNvbnN0IE1EQ1RfVEFCTEVfMjA0OCA9IFtcXG4gICAgWzAuMDMxMjQ5OTk3NzAyMDU0LCAwLjAwMDAxMTk4NDIyNDYxMl0sXFxuICAgIFswLjAzMTI0OTgxMzg2NjUzMSwgMC4wMDAxMDc4NTc4MTAwMDRdLFxcbiAgICBbMC4wMzEyNDkzMzU4OTU4NTgsIDAuMDAwMjAzNzMwMzgwMTk4XSxcXG4gICAgWzAuMDMxMjQ4NTYzNzk0NTM1LCAwLjAwMDI5OTYwMTAzMjgwNF0sXFxuICAgIFswLjAzMTI0NzQ5NzU2OTgyOSwgMC4wMDAzOTU0Njg4NjU0NTFdLFxcbiAgICBbMC4wMzEyNDYxMzcyMzE3NzUsIDAuMDAwNDkxMzMyOTc1Nzk0XSxcXG4gICAgWzAuMDMxMjQ0NDgyNzkzMTc3LCAwLjAwMDU4NzE5MjQ2MTUyNV0sXFxuICAgIFswLjAzMTI0MjUzNDI2OTYwOCwgMC4wMDA2ODMwNDY0MjAzNzZdLFxcbiAgICBbMC4wMzEyNDAyOTE2Nzk0MDcsIDAuMDAwNzc4ODkzOTUwMTM0XSxcXG4gICAgWzAuMDMxMjM3NzU1MDQzNjg0LCAwLjAwMDg3NDczNDE0ODY0NV0sXFxuICAgIFswLjAzMTIzNDkyNDM4NjMxMywgMC4wMDA5NzA1NjYxMTM4MjZdLFxcbiAgICBbMC4wMzEyMzE3OTk3MzM5MzgsIDAuMDAxMDY2Mzg4OTQzNjY5XSxcXG4gICAgWzAuMDMxMjI4MzgxMTE1OTcwLCAwLjAwMTE2MjIwMTczNjI1M10sXFxuICAgIFswLjAzMTIyNDY2ODU2NDU4NSwgMC4wMDEyNTgwMDM1ODk3NTFdLFxcbiAgICBbMC4wMzEyMjA2NjIxMTQ3MjgsIDAuMDAxMzUzNzkzNjAyNDQxXSxcXG4gICAgWzAuMDMxMjE2MzYxODA0MTA4LCAwLjAwMTQ0OTU3MDg3MjcxMF0sXFxuICAgIFswLjAzMTIxMTc2NzY3MzIwMywgMC4wMDE1NDUzMzQ0OTkwNjVdLFxcbiAgICBbMC4wMzEyMDY4Nzk3NjUyNTMsIDAuMDAxNjQxMDgzNTgwMTQ0XSxcXG4gICAgWzAuMDMxMjAxNjk4MTI2MjY2LCAwLjAwMTczNjgxNzIxNDcxOV0sXFxuICAgIFswLjAzMTE5NjIyMjgwNTAxNCwgMC4wMDE4MzI1MzQ1MDE3MDldLFxcbiAgICBbMC4wMzExOTA0NTM4NTMwMzEsIDAuMDAxOTI4MjM0NTQwMTg2XSxcXG4gICAgWzAuMDMxMTg0MzkxMzI0NjE3LCAwLjAwMjAyMzkxNjQyOTM4Nl0sXFxuICAgIFswLjAzMTE3ODAzNTI3NjgzNiwgMC4wMDIxMTk1NzkyNjg3MTNdLFxcbiAgICBbMC4wMzExNzEzODU3Njk1MTMsIDAuMDAyMjE1MjIyMTU3NzUzXSxcXG4gICAgWzAuMDMxMTY0NDQyODY1MjM2LCAwLjAwMjMxMDg0NDE5NjI3OF0sXFxuICAgIFswLjAzMTE1NzIwNjYyOTM1MywgMC4wMDI0MDY0NDQ0ODQyNThdLFxcbiAgICBbMC4wMzExNDk2NzcxMjk5NzUsIDAuMDAyNTAyMDIyMTIxODY1XSxcXG4gICAgWzAuMDMxMTQxODU0NDM3OTczLCAwLjAwMjU5NzU3NjIwOTQ4OF0sXFxuICAgIFswLjAzMTEzMzczODYyNjk3NywgMC4wMDI2OTMxMDU4NDc3MzRdLFxcbiAgICBbMC4wMzExMjUzMjk3NzMzNzUsIDAuMDAyNzg4NjEwMTM3NDQyXSxcXG4gICAgWzAuMDMxMTE2NjI3OTU2MzE2LCAwLjAwMjg4NDA4ODE3OTY4OV0sXFxuICAgIFswLjAzMTEwNzYzMzI1NzcwMywgMC4wMDI5Nzk1MzkwNzU4MDFdLFxcbiAgICBbMC4wMzEwOTgzNDU3NjIyMDAsIDAuMDAzMDc0OTYxOTI3MzU1XSxcXG4gICAgWzAuMDMxMDg4NzY1NTU3MjIyLCAwLjAwMzE3MDM1NTgzNjE5N10sXFxuICAgIFswLjAzMTA3ODg5MjczMjk0MiwgMC4wMDMyNjU3MTk5MDQ0NDJdLFxcbiAgICBbMC4wMzEwNjg3MjczODIyODgsIDAuMDAzMzYxMDUzMjM0NDg4XSxcXG4gICAgWzAuMDMxMDU4MjY5NjAwOTM5LCAwLjAwMzQ1NjM1NDkyOTAyMV0sXFxuICAgIFswLjAzMTA0NzUxOTQ4NzMyOSwgMC4wMDM1NTE2MjQwOTEwMjRdLFxcbiAgICBbMC4wMzEwMzY0NzcxNDI2NDAsIDAuMDAzNjQ2ODU5ODIzNzkwXSxcXG4gICAgWzAuMDMxMDI1MTQyNjcwODA5LCAwLjAwMzc0MjA2MTIzMDkyMV0sXFxuICAgIFswLjAzMTAxMzUxNjE3ODUxOSwgMC4wMDM4MzcyMjc0MTYzNDddLFxcbiAgICBbMC4wMzEwMDE1OTc3NzUyMDMsIDAuMDAzOTMyMzU3NDg0MzI4XSxcXG4gICAgWzAuMDMwOTg5Mzg3NTczMDQyLCAwLjAwNDAyNzQ1MDUzOTQ2Ml0sXFxuICAgIFswLjAzMDk3Njg4NTY4Njk2MywgMC4wMDQxMjI1MDU2ODY2OTddLFxcbiAgICBbMC4wMzA5NjQwOTIyMzQ2MzgsIDAuMDA0MjE3NTIyMDMxMzQwXSxcXG4gICAgWzAuMDMwOTUxMDA3MzM2NDg1LCAwLjAwNDMxMjQ5ODY3OTA1OF0sXFxuICAgIFswLjAzMDkzNzYzMTExNTY2MywgMC4wMDQ0MDc0MzQ3MzU4OTddLFxcbiAgICBbMC4wMzA5MjM5NjM2OTgwNzQsIDAuMDA0NTAyMzI5MzA4MjgxXSxcXG4gICAgWzAuMDMwOTEwMDA1MjEyMzYyLCAwLjAwNDU5NzE4MTUwMzAyN10sXFxuICAgIFswLjAzMDg5NTc1NTc4OTkwOCwgMC4wMDQ2OTE5OTA0MjczNTBdLFxcbiAgICBbMC4wMzA4ODEyMTU1NjQ4MzUsIDAuMDA0Nzg2NzU1MTg4ODcyXSxcXG4gICAgWzAuMDMwODY2Mzg0Njc0MDAwLCAwLjAwNDg4MTQ3NDg5NTYzMl0sXFxuICAgIFswLjAzMDg1MTI2MzI1Njk5NiwgMC4wMDQ5NzYxNDg2NTYwOTBdLFxcbiAgICBbMC4wMzA4MzU4NTE0NTYxNTQsIDAuMDA1MDcwNzc1NTc5MTQyXSxcXG4gICAgWzAuMDMwODIwMTQ5NDE2NTMzLCAwLjAwNTE2NTM1NDc3NDEyNF0sXFxuICAgIFswLjAzMDgwNDE1NzI4NTkyOSwgMC4wMDUyNTk4ODUzNTA4MTldLFxcbiAgICBbMC4wMzA3ODc4NzUyMTQ4NjQsIDAuMDA1MzU0MzY2NDE5NDY5XSxcXG4gICAgWzAuMDMwNzcxMzAzMzU2NTkzLCAwLjAwNTQ0ODc5NzA5MDc4NF0sXFxuICAgIFswLjAzMDc1NDQ0MTg2NzA5NSwgMC4wMDU1NDMxNzY0NzU5NDZdLFxcbiAgICBbMC4wMzA3MzcyOTA5MDUwNzcsIDAuMDA1NjM3NTAzNjg2NjE5XSxcXG4gICAgWzAuMDMwNzE5ODUwNjMxOTcyLCAwLjAwNTczMTc3NzgzNDk2MV0sXFxuICAgIFswLjAzMDcwMjEyMTIxMTkzMiwgMC4wMDU4MjU5OTgwMzM2MjZdLFxcbiAgICBbMC4wMzA2ODQxMDI4MTE4MzUsIDAuMDA1OTIwMTYzMzk1NzgwXSxcXG4gICAgWzAuMDMwNjY1Nzk1NjAxMjc2LCAwLjAwNjAxNDI3MzAzNTEwMV0sXFxuICAgIFswLjAzMDY0NzE5OTc1MjU3MCwgMC4wMDYxMDgzMjYwNjU3OTNdLFxcbiAgICBbMC4wMzA2MjgzMTU0NDA3NDgsIDAuMDA2MjAyMzIxNjAyNTk0XSxcXG4gICAgWzAuMDMwNjA5MTQyODQzNTU3LCAwLjAwNjI5NjI1ODc2MDc4Ml0sXFxuICAgIFswLjAzMDU4OTY4MjE0MTQ1NSwgMC4wMDYzOTAxMzY2NTYxODVdLFxcbiAgICBbMC4wMzA1Njk5MzM1MTc2MTYsIDAuMDA2NDgzOTU0NDA1MTg4XSxcXG4gICAgWzAuMDMwNTQ5ODk3MTU3OTE5LCAwLjAwNjU3NzcxMTEyNDc0M10sXFxuICAgIFswLjAzMDUyOTU3MzI1MDk1NiwgMC4wMDY2NzE0MDU5MzIzNzVdLFxcbiAgICBbMC4wMzA1MDg5NjE5ODgwMjIsIDAuMDA2NzY1MDM3OTQ2MTk0XSxcXG4gICAgWzAuMDMwNDg4MDYzNTYzMTE4LCAwLjAwNjg1ODYwNjI4NDkwMF0sXFxuICAgIFswLjAzMDQ2Njg3ODE3Mjk0OSwgMC4wMDY5NTIxMTAwNjc3OTFdLFxcbiAgICBbMC4wMzA0NDU0MDYwMTY5MTksIDAuMDA3MDQ1NTQ4NDE0Nzc0XSxcXG4gICAgWzAuMDMwNDIzNjQ3Mjk3MTMzLCAwLjAwNzEzODkyMDQ0NjM3Ml0sXFxuICAgIFswLjAzMDQwMTYwMjIxODM5MiwgMC4wMDcyMzIyMjUyODM3MzNdLFxcbiAgICBbMC4wMzAzNzkyNzA5ODgxOTIsIDAuMDA3MzI1NDYyMDQ4NjM0XSxcXG4gICAgWzAuMDMwMzU2NjUzODE2NzI0LCAwLjAwNzQxODYyOTg2MzQ5N10sXFxuICAgIFswLjAzMDMzMzc1MDkxNjg2OSwgMC4wMDc1MTE3Mjc4NTEzOTBdLFxcbiAgICBbMC4wMzAzMTA1NjI1MDQxOTgsIDAuMDA3NjA0NzU1MTM2MDQwXSxcXG4gICAgWzAuMDMwMjg3MDg4Nzk2OTY4LCAwLjAwNzY5NzcxMDg0MTgzOF0sXFxuICAgIFswLjAzMDI2MzMzMDAxNjEyNCwgMC4wMDc3OTA1OTQwOTM4NTFdLFxcbiAgICBbMC4wMzAyMzkyODYzODUyOTMsIDAuMDA3ODgzNDA0MDE3ODI0XSxcXG4gICAgWzAuMDMwMjE0OTU4MTMwNzgxLCAwLjAwNzk3NjEzOTc0MDE5N10sXFxuICAgIFswLjAzMDE5MDM0NTQ4MTU3NiwgMC4wMDgwNjg4MDAzODgxMDRdLFxcbiAgICBbMC4wMzAxNjU0NDg2NjkzNDIsIDAuMDA4MTYxMzg1MDg5MzkwXSxcXG4gICAgWzAuMDMwMTQwMjY3OTI4NDE2LCAwLjAwODI1Mzg5Mjk3MjYxMF0sXFxuICAgIFswLjAzMDExNDgwMzQ5NTgwOSwgMC4wMDgzNDYzMjMxNjcwNDddLFxcbiAgICBbMC4wMzAwODkwNTU2MTEyMDMsIDAuMDA4NDM4Njc0ODAyNzExXSxcXG4gICAgWzAuMDMwMDYzMDI0NTE2OTQ3LCAwLjAwODUzMDk0NzAxMDM1NF0sXFxuICAgIFswLjAzMDAzNjcxMDQ1ODA1NCwgMC4wMDg2MjMxMzg5MjE0NzVdLFxcbiAgICBbMC4wMzAwMTAxMTM2ODIyMDIsIDAuMDA4NzE1MjQ5NjY4MzI4XSxcXG4gICAgWzAuMDI5OTgzMjM0NDM5NzMyLCAwLjAwODgwNzI3ODM4MzkzMl0sXFxuICAgIFswLjAyOTk1NjA3Mjk4MzY0MCwgMC4wMDg4OTkyMjQyMDIwNzhdLFxcbiAgICBbMC4wMjk5Mjg2Mjk1Njk1ODAsIDAuMDA4OTkxMDg2MjU3MzM2XSxcXG4gICAgWzAuMDI5OTAwOTA0NDU1ODYwLCAwLjAwOTA4Mjg2MzY4NTA2N10sXFxuICAgIFswLjAyOTg3Mjg5NzkwMzQ0MSwgMC4wMDkxNzQ1NTU2MjE0MjVdLFxcbiAgICBbMC4wMjk4NDQ2MTAxNzU5MjksIDAuMDA5MjY2MTYxMjAzMzcxXSxcXG4gICAgWzAuMDI5ODE2MDQxNTM5NTc5LCAwLjAwOTM1NzY3OTU2ODY3OV0sXFxuICAgIFswLjAyOTc4NzE5MjI2MzI5MiwgMC4wMDk0NDkxMDk4NTU5NDRdLFxcbiAgICBbMC4wMjk3NTgwNjI2MTg2MDYsIDAuMDA5NTQwNDUxMjA0NTg3XSxcXG4gICAgWzAuMDI5NzI4NjUyODc5NzAyLCAwLjAwOTYzMTcwMjc1NDg3MV0sXFxuICAgIFswLjAyOTY5ODk2MzMyMzM5NSwgMC4wMDk3MjI4NjM2NDc5MDBdLFxcbiAgICBbMC4wMjk2Njg5OTQyMjkxMzQsIDAuMDA5ODEzOTMzMDI1NjMzXSxcXG4gICAgWzAuMDI5NjM4NzQ1ODc5MDAwLCAwLjAwOTkwNDkxMDAzMDg5MV0sXFxuICAgIFswLjAyOTYwODIxODU1NzcwMiwgMC4wMDk5OTU3OTM4MDczNjNdLFxcbiAgICBbMC4wMjk1Nzc0MTI1NTI1NzUsIDAuMDEwMDg2NTgzNDk5NjE4XSxcXG4gICAgWzAuMDI5NTQ2MzI4MTUzNTc3LCAwLjAxMDE3NzI3ODI1MzEwN10sXFxuICAgIFswLjAyOTUxNDk2NTY1MzI4NSwgMC4wMTAyNjc4NzcyMTQxNzddLFxcbiAgICBbMC4wMjk0ODMzMjUzNDY4OTYsIDAuMDEwMzU4Mzc5NTMwMDc2XSxcXG4gICAgWzAuMDI5NDUxNDA3NTMyMjIwLCAwLjAxMDQ0ODc4NDM0ODk2Ml0sXFxuICAgIFswLjAyOTQxOTIxMjUwOTY3OSwgMC4wMTA1MzkwOTA4MTk5MTFdLFxcbiAgICBbMC4wMjkzODY3NDA1ODIzMDcsIDAuMDEwNjI5Mjk4MDkyOTIzXSxcXG4gICAgWzAuMDI5MzUzOTkyMDU1NzQwLCAwLjAxMDcxOTQwNTMxODkzM10sXFxuICAgIFswLjAyOTMyMDk2NzIzODIyMCwgMC4wMTA4MDk0MTE2NDk4MThdLFxcbiAgICBbMC4wMjkyODc2NjY0NDA1OTAsIDAuMDEwODk5MzE2MjM4NDAzXSxcXG4gICAgWzAuMDI5MjU0MDg5OTc2MjkwLCAwLjAxMDk4OTExODIzODQ3NF0sXFxuICAgIFswLjAyOTIyMDIzODE2MTM1MywgMC4wMTEwNzg4MTY4MDQ3NzhdLFxcbiAgICBbMC4wMjkxODYxMTEzMTQ0MDYsIDAuMDExMTY4NDExMDkzMDM5XSxcXG4gICAgWzAuMDI5MTUxNzA5NzU2NjY0LCAwLjAxMTI1NzkwMDI1OTk2MV0sXFxuICAgIFswLjAyOTExNzAzMzgxMTkyNywgMC4wMTEzNDcyODM0NjMyMzldLFxcbiAgICBbMC4wMjkwODIwODM4MDY1NzksIDAuMDExNDM2NTU5ODYxNTYzXSxcXG4gICAgWzAuMDI5MDQ2ODYwMDY5NTgyLCAwLjAxMTUyNTcyODYxNDYzMF0sXFxuICAgIFswLjAyOTAxMTM2MjkzMjQ3NiwgMC4wMTE2MTQ3ODg4ODMxNTBdLFxcbiAgICBbMC4wMjg5NzU1OTI3MjkzNzMsIDAuMDExNzAzNzM5ODI4ODUzXSxcXG4gICAgWzAuMDI4OTM5NTQ5Nzk2OTU3LCAwLjAxMTc5MjU4MDYxNDUwMF0sXFxuICAgIFswLjAyODkwMzIzNDQ3NDQ3NSwgMC4wMTE4ODEzMTA0MDM4ODZdLFxcbiAgICBbMC4wMjg4NjY2NDcxMDM3NDQsIDAuMDExOTY5OTI4MzYxODU1XSxcXG4gICAgWzAuMDI4ODI5Nzg4MDI5MTM1LCAwLjAxMjA1ODQzMzY1NDI5OV0sXFxuICAgIFswLjAyODc5MjY1NzU5NzU4MywgMC4wMTIxNDY4MjU0NDgxNzJdLFxcbiAgICBbMC4wMjg3NTUyNTYxNTg1NzEsIDAuMDEyMjM1MTAyOTExNDk5XSxcXG4gICAgWzAuMDI4NzE3NTg0MDY0MTM3LCAwLjAxMjMyMzI2NTIxMzM3N10sXFxuICAgIFswLjAyODY3OTY0MTY2ODg2NCwgMC4wMTI0MTEzMTE1MjM5OTBdLFxcbiAgICBbMC4wMjg2NDE0MjkzMjk4ODIsIDAuMDEyNDk5MjQxMDE0NjEyXSxcXG4gICAgWzAuMDI4NjAyOTQ3NDA2ODU5LCAwLjAxMjU4NzA1Mjg1NzYxOF0sXFxuICAgIFswLjAyODU2NDE5NjI2MjAwMSwgMC4wMTI2NzQ3NDYyMjY0ODhdLFxcbiAgICBbMC4wMjg1MjUxNzYyNjAwNTAsIDAuMDEyNzYyMzIwMjk1ODE5XSxcXG4gICAgWzAuMDI4NDg1ODg3NzY4Mjc2LCAwLjAxMjg0OTc3NDI0MTMzMV0sXFxuICAgIFswLjAyODQ0NjMzMTE1NjQ3OCwgMC4wMTI5MzcxMDcyMzk4NzVdLFxcbiAgICBbMC4wMjg0MDY1MDY3OTY5NzYsIDAuMDEzMDI0MzE4NDY5NDM3XSxcXG4gICAgWzAuMDI4MzY2NDE1MDY0NjE1LCAwLjAxMzExMTQwNzEwOTE1NV0sXFxuICAgIFswLjAyODMyNjA1NjMzNjc1MSwgMC4wMTMxOTgzNzIzMzkzMTVdLFxcbiAgICBbMC4wMjgyODU0MzA5OTMyNTgsIDAuMDEzMjg1MjEzMzQxMzY4XSxcXG4gICAgWzAuMDI4MjQ0NTM5NDE2NTE1LCAwLjAxMzM3MTkyOTI5NzkzM10sXFxuICAgIFswLjAyODIwMzM4MTk5MTQxMSwgMC4wMTM0NTg1MTkzOTI4MDddLFxcbiAgICBbMC4wMjgxNjE5NTkxMDUzMzQsIDAuMDEzNTQ0OTgyODEwOTcxXSxcXG4gICAgWzAuMDI4MTIwMjcxMTQ4MTcyLCAwLjAxMzYzMTMxODczODU5OF0sXFxuICAgIFswLjAyODA3ODMxODUxMjMwOSwgMC4wMTM3MTc1MjYzNjMwNjJdLFxcbiAgICBbMC4wMjgwMzYxMDE1OTI2MTksIDAuMDEzODAzNjA0ODcyOTQzXSxcXG4gICAgWzAuMDI3OTkzNjIwNzg2NDYzLCAwLjAxMzg4OTU1MzQ1ODAzOV0sXFxuICAgIFswLjAyNzk1MDg3NjQ5MzY4NywgMC4wMTM5NzUzNzEzMDkzNjddLFxcbiAgICBbMC4wMjc5MDc4NjkxMTY2MTYsIDAuMDE0MDYxMDU3NjE5MTc4XSxcXG4gICAgWzAuMDI3ODY0NTk5MDYwMDUyLCAwLjAxNDE0NjYxMTU4MDk1OV0sXFxuICAgIFswLjAyNzgyMTA2NjczMTI3MCwgMC4wMTQyMzIwMzIzODk0NDVdLFxcbiAgICBbMC4wMjc3NzcyNzI1NDAwMTIsIDAuMDE0MzE3MzE5MjQwNjIyXSxcXG4gICAgWzAuMDI3NzMzMjE2ODk4NDg3LCAwLjAxNDQwMjQ3MTMzMTczN10sXFxuICAgIFswLjAyNzY4ODkwMDIyMTM2MSwgMC4wMTQ0ODc0ODc4NjEzMDddLFxcbiAgICBbMC4wMjc2NDQzMjI5MjU3NjIsIDAuMDE0NTcyMzY4MDI5MTIzXSxcXG4gICAgWzAuMDI3NTk5NDg1NDMxMjY2LCAwLjAxNDY1NzExMTAzNjI2Ml0sXFxuICAgIFswLjAyNzU1NDM4ODE1OTkwMywgMC4wMTQ3NDE3MTYwODUwOTBdLFxcbiAgICBbMC4wMjc1MDkwMzE1MzYxNDQsIDAuMDE0ODI2MTgyMzc5MjcxXSxcXG4gICAgWzAuMDI3NDYzNDE1OTg2OTA0LCAwLjAxNDkxMDUwOTEyMzc3OF0sXFxuICAgIFswLjAyNzQxNzU0MTk0MTUzMywgMC4wMTQ5OTQ2OTU1MjQ4OTRdLFxcbiAgICBbMC4wMjczNzE0MDk4MzE4MTYsIDAuMDE1MDc4NzQwNzkwMjI1XSxcXG4gICAgWzAuMDI3MzI1MDIwMDkxOTY1LCAwLjAxNTE2MjY0NDEyODcwNF0sXFxuICAgIFswLjAyNzI3ODM3MzE1ODYxOCwgMC4wMTUyNDY0MDQ3NTA2MDNdLFxcbiAgICBbMC4wMjcyMzE0Njk0NzA4MzMsIDAuMDE1MzMwMDIxODY3NTM0XSxcXG4gICAgWzAuMDI3MTg0MzA5NDcwMDg4LCAwLjAxNTQxMzQ5NDY5MjQ2MF0sXFxuICAgIFswLjAyNzEzNjg5MzYwMDI2OCwgMC4wMTU0OTY4MjI0Mzk3MDRdLFxcbiAgICBbMC4wMjcwODkyMjIzMDc2NzEsIDAuMDE1NTgwMDA0MzI0OTU0XSxcXG4gICAgWzAuMDI3MDQxMjk2MDQwOTk3LCAwLjAxNTY2MzAzOTU2NTI2OV0sXFxuICAgIFswLjAyNjk5MzExNTI1MTM0NSwgMC4wMTU3NDU5MjczNzkwOTFdLFxcbiAgICBbMC4wMjY5NDQ2ODAzOTIyMTMsIDAuMDE1ODI4NjY2OTg2MjQ3XSxcXG4gICAgWzAuMDI2ODk1OTkxOTE5NDg3LCAwLjAxNTkxMTI1NzYwNzk2MV0sXFxuICAgIFswLjAyNjg0NzA1MDI5MTQ0MiwgMC4wMTU5OTM2OTg0NjY4NTldLFxcbiAgICBbMC4wMjY3OTc4NTU5Njg3MzQsIDAuMDE2MDc1OTg4Nzg2OTc2XSxcXG4gICAgWzAuMDI2NzQ4NDA5NDE0NDAxLCAwLjAxNjE1ODEyNzc5Mzc2M10sXFxuICAgIFswLjAyNjY5ODcxMTA5Mzg1MSwgMC4wMTYyNDAxMTQ3MTQwOTldLFxcbiAgICBbMC4wMjY2NDg3NjE0NzQ4NjQsIDAuMDE2MzIxOTQ4Nzc2Mjg5XSxcXG4gICAgWzAuMDI2NTk4NTYxMDI3NTg1LCAwLjAxNjQwMzYyOTIxMDA4Ml0sXFxuICAgIFswLjAyNjU0ODExMDIyNDUxOSwgMC4wMTY0ODUxNTUyNDY2NjldLFxcbiAgICBbMC4wMjY0OTc0MDk1NDA1MzAsIDAuMDE2NTY2NTI2MTE4Njk2XSxcXG4gICAgWzAuMDI2NDQ2NDU5NDUyODMwLCAwLjAxNjY0Nzc0MTA2MDI3MV0sXFxuICAgIFswLjAyNjM5NTI2MDQ0MDk4MiwgMC4wMTY3Mjg3OTkzMDY5NjZdLFxcbiAgICBbMC4wMjYzNDM4MTI5ODY4OTAsIDAuMDE2ODA5NzAwMDk1ODMxXSxcXG4gICAgWzAuMDI2MjkyMTE3NTc0Nzk3LCAwLjAxNjg5MDQ0MjY2NTM5N10sXFxuICAgIFswLjAyNjI0MDE3NDY5MTI4MCwgMC4wMTY5NzEwMjYyNTU2ODNdLFxcbiAgICBbMC4wMjYxODc5ODQ4MjUyNDYsIDAuMDE3MDUxNDUwMTA4MjA4XSxcXG4gICAgWzAuMDI2MTM1NTQ4NDY3OTI0LCAwLjAxNzEzMTcxMzQ2NTk5MF0sXFxuICAgIFswLjAyNjA4Mjg2NjExMjg2NywgMC4wMTcyMTE4MTU1NzM1NjBdLFxcbiAgICBbMC4wMjYwMjk5MzgyNTU5NDEsIDAuMDE3MjkxNzU1Njc2OTY3XSxcXG4gICAgWzAuMDI1OTc2NzY1Mzk1MzIyLCAwLjAxNzM3MTUzMzAyMzc4NF0sXFxuICAgIFswLjAyNTkyMzM0ODAzMTQ5NCwgMC4wMTc0NTExNDY4NjMxMTZdLFxcbiAgICBbMC4wMjU4Njk2ODY2NjcyNDIsIDAuMDE3NTMwNTk2NDQ1NjA3XSxcXG4gICAgWzAuMDI1ODE1NzgxODA3NjQ2LCAwLjAxNzYwOTg4MTAyMzQ0OV0sXFxuICAgIFswLjAyNTc2MTYzMzk2MDA4MCwgMC4wMTc2ODg5OTk4NTAzODNdLFxcbiAgICBbMC4wMjU3MDcyNDM2MzQyMDQsIDAuMDE3NzY3OTUyMTgxNzE1XSxcXG4gICAgWzAuMDI1NjUyNjExMzQxOTYwLCAwLjAxNzg0NjczNzI3NDMxM10sXFxuICAgIFswLjAyNTU5NzczNzU5NzU2OCwgMC4wMTc5MjUzNTQzODY2MjNdLFxcbiAgICBbMC4wMjU1NDI2MjI5MTc1MjIsIDAuMDE4MDAzODAyNzc4NjcxXSxcXG4gICAgWzAuMDI1NDg3MjY3ODIwNTgxLCAwLjAxODA4MjA4MTcxMjA3MV0sXFxuICAgIFswLjAyNTQzMTY3MjgyNzc2OCwgMC4wMTgxNjAxOTA0NTAwMzFdLFxcbiAgICBbMC4wMjUzNzU4Mzg0NjIzNjUsIDAuMDE4MjM4MTI4MjU3MzYyXSxcXG4gICAgWzAuMDI1MzE5NzY1MjQ5OTA2LCAwLjAxODMxNTg5NDQwMDQ4NF0sXFxuICAgIFswLjAyNTI2MzQ1MzcxODE3MywgMC4wMTgzOTM0ODgxNDc0MzJdLFxcbiAgICBbMC4wMjUyMDY5MDQzOTcxOTMsIDAuMDE4NDcwOTA4NzY3ODY1XSxcXG4gICAgWzAuMDI1MTUwMTE3ODE5MjI4LCAwLjAxODU0ODE1NTUzMzA3MF0sXFxuICAgIFswLjAyNTA5MzA5NDUxODc3NiwgMC4wMTg2MjUyMjc3MTU5NzFdLFxcbiAgICBbMC4wMjUwMzU4MzUwMzI1NjIsIDAuMDE4NzAyMTI0NTkxMTM1XSxcXG4gICAgWzAuMDI0OTc4MzM5ODk5NTM0LCAwLjAxODc3ODg0NTQzNDc4MF0sXFxuICAgIFswLjAyNDkyMDYwOTY2MDg1OCwgMC4wMTg4NTUzODk1MjQ3ODBdLFxcbiAgICBbMC4wMjQ4NjI2NDQ4NTk5MTIsIDAuMDE4OTMxNzU2MTQwNjcyXSxcXG4gICAgWzAuMDI0ODA0NDQ2MDQyMjg0LCAwLjAxOTAwNzk0NDU2MzY2Nl0sXFxuICAgIFswLjAyNDc0NjAxMzc1NTc2NCwgMC4wMTkwODM5NTQwNzY2NDZdLFxcbiAgICBbMC4wMjQ2ODczNDg1NTAzMzcsIDAuMDE5MTU5NzgzOTY0MTgzXSxcXG4gICAgWzAuMDI0NjI4NDUwOTc4MTg0LCAwLjAxOTIzNTQzMzUxMjUzNl0sXFxuICAgIFswLjAyNDU2OTMyMTU5MzY3MCwgMC4wMTkzMTA5MDIwMDk2NjNdLFxcbiAgICBbMC4wMjQ1MDk5NjA5NTMzNDUsIDAuMDE5Mzg2MTg4NzQ1MjI1XSxcXG4gICAgWzAuMDI0NDUwMzY5NjE1OTMyLCAwLjAxOTQ2MTI5MzAxMDU5Nl0sXFxuICAgIFswLjAyNDM5MDU0ODE0MjMyOSwgMC4wMTk1MzYyMTQwOTg4NjZdLFxcbiAgICBbMC4wMjQzMzA0OTcwOTU1OTgsIDAuMDE5NjEwOTUxMzA0ODQ4XSxcXG4gICAgWzAuMDI0MjcwMjE3MDQwOTYxLCAwLjAxOTY4NTUwMzkyNTA4N10sXFxuICAgIFswLjAyNDIwOTcwODU0NTc5OSwgMC4wMTk3NTk4NzEyNTc4NjddLFxcbiAgICBbMC4wMjQxNDg5NzIxNzk2MzksIDAuMDE5ODM0MDUyNjAzMjEyXSxcXG4gICAgWzAuMDI0MDg4MDA4NTE0MTU3LCAwLjAxOTkwODA0NzI2MjkwMV0sXFxuICAgIFswLjAyNDAyNjgxODEyMzE2NCwgMC4wMTk5ODE4NTQ1NDA0NjddLFxcbiAgICBbMC4wMjM5NjU0MDE1ODI2MDksIDAuMDIwMDU1NDczNzQxMjA4XSxcXG4gICAgWzAuMDIzOTAzNzU5NDcwNTY3LCAwLjAyMDEyODkwNDE3MjE5Ml0sXFxuICAgIFswLjAyMzg0MTg5MjM2NzIzNiwgMC4wMjAyMDIxNDUxNDIyNjRdLFxcbiAgICBbMC4wMjM3Nzk4MDA4NTQ5MzUsIDAuMDIwMjc1MTk1OTYyMDUyXSxcXG4gICAgWzAuMDIzNzE3NDg1NTE4MDkyLCAwLjAyMDM0ODA1NTk0Mzk3NF0sXFxuICAgIFswLjAyMzY1NDk0Njk0MzI0MiwgMC4wMjA0MjA3MjQ0MDIyNDRdLFxcbiAgICBbMC4wMjM1OTIxODU3MTkwMjMsIDAuMDIwNDkzMjAwNjUyODc4XSxcXG4gICAgWzAuMDIzNTI5MjAyNDM2MTY3LCAwLjAyMDU2NTQ4NDAxMzcwM10sXFxuICAgIFswLjAyMzQ2NTk5NzY4NzQ5NiwgMC4wMjA2Mzc1NzM4MDQzNjFdLFxcbiAgICBbMC4wMjM0MDI1NzIwNjc5MTgsIDAuMDIwNzA5NDY5MzQ2MzE0XSxcXG4gICAgWzAuMDIzMzM4OTI2MTc0NDE5LCAwLjAyMDc4MTE2OTk2Mjg1NF0sXFxuICAgIFswLjAyMzI3NTA2MDYwNjA1OCwgMC4wMjA4NTI2NzQ5NzkxMDhdLFxcbiAgICBbMC4wMjMyMTA5NzU5NjM5NjMsIDAuMDIwOTIzOTgzNzIyMDQ0XSxcXG4gICAgWzAuMDIzMTQ2NjcyODUxMzIyLCAwLjAyMDk5NTA5NTUyMDQ3NV0sXFxuICAgIFswLjAyMzA4MjE1MTg3MzM4MCwgMC4wMjEwNjYwMDk3MDUwNzJdLFxcbiAgICBbMC4wMjMwMTc0MTM2Mzc0MzUsIDAuMDIxMTM2NzI1NjA4MzYzXSxcXG4gICAgWzAuMDIyOTUyNDU4NzUyODI2LCAwLjAyMTIwNzI0MjU2NDc0Ml0sXFxuICAgIFswLjAyMjg4NzI4NzgzMDkzNCwgMC4wMjEyNzc1NTk5MTA0NzhdLFxcbiAgICBbMC4wMjI4MjE5MDE0ODUxNzMsIDAuMDIxMzQ3Njc2OTgzNzE2XSxcXG4gICAgWzAuMDIyNzU2MzAwMzMwOTgzLCAwLjAyMTQxNzU5MzEyNDQ4OF0sXFxuICAgIFswLjAyMjY5MDQ4NDk4NTgyNywgMC4wMjE0ODczMDc2NzQ3MTddLFxcbiAgICBbMC4wMjI2MjQ0NTYwNjkxODUsIDAuMDIxNTU2ODE5OTc4MjIzXSxcXG4gICAgWzAuMDIyNTU4MjE0MjAyNTQ3LCAwLjAyMTYyNjEyOTM4MDcyOV0sXFxuICAgIFswLjAyMjQ5MTc2MDAwOTQwNSwgMC4wMjE2OTUyMzUyMjk4NjldLFxcbiAgICBbMC4wMjI0MjUwOTQxMTUyNTIsIDAuMDIxNzY0MTM2ODc1MTkyXSxcXG4gICAgWzAuMDIyMzU4MjE3MTQ3NTcyLCAwLjAyMTgzMjgzMzY2ODE3MV0sXFxuICAgIFswLjAyMjI5MTEyOTczNTgzOCwgMC4wMjE5MDEzMjQ5NjIyMDRdLFxcbiAgICBbMC4wMjIyMjM4MzI1MTE1MDEsIDAuMDIxOTY5NjEwMTEyNjI1XSxcXG4gICAgWzAuMDIyMTU2MzI2MTA3OTg4LCAwLjAyMjAzNzY4ODQ3NjcwOV0sXFxuICAgIFswLjAyMjA4ODYxMTE2MDY5NiwgMC4wMjIxMDU1NTk0MTM2NzZdLFxcbiAgICBbMC4wMjIwMjA2ODgzMDY5ODMsIDAuMDIyMTczMjIyMjg0Njk5XSxcXG4gICAgWzAuMDIxOTUyNTU4MTg2MTY2LCAwLjAyMjI0MDY3NjQ1MjkwOV0sXFxuICAgIFswLjAyMTg4NDIyMTQzOTUxMCwgMC4wMjIzMDc5MjEyODM0MDNdLFxcbiAgICBbMC4wMjE4MTU2Nzg3MTAyMjgsIDAuMDIyMzc0OTU2MTQzMjQ1XSxcXG4gICAgWzAuMDIxNzQ2OTMwNjQzNDY5LCAwLjAyMjQ0MTc4MDQwMTQ3OF0sXFxuICAgIFswLjAyMTY3Nzk3Nzg4NjMxNiwgMC4wMjI1MDgzOTM0MjkxMjddLFxcbiAgICBbMC4wMjE2MDg4MjEwODc3ODAsIDAuMDIyNTc0Nzk0NTk5MjA2XSxcXG4gICAgWzAuMDIxNTM5NDYwODk4NzkwLCAwLjAyMjY0MDk4MzI4NjcxOV0sXFxuICAgIFswLjAyMTQ2OTg5Nzk3MjE5MCwgMC4wMjI3MDY5NTg4Njg2NzZdLFxcbiAgICBbMC4wMjE0MDAxMzI5NjI3MzUsIDAuMDIyNzcyNzIwNzI0MDg3XSxcXG4gICAgWzAuMDIxMzMwMTY2NTI3MDc3LCAwLjAyMjgzODI2ODIzMzk3OV0sXFxuICAgIFswLjAyMTI1OTk5OTMyMzc2OSwgMC4wMjI5MDM2MDA3ODEzOTFdLFxcbiAgICBbMC4wMjExODk2MzIwMTMyNTAsIDAuMDIyOTY4NzE3NzUxMzkxXSxcXG4gICAgWzAuMDIxMTE5MDY1MjU3ODQ1LCAwLjAyMzAzMzYxODUzMTA3MV0sXFxuICAgIFswLjAyMTA0ODI5OTcyMTc1NCwgMC4wMjMwOTgzMDI1MDk1NjFdLFxcbiAgICBbMC4wMjA5NzczMzYwNzEwNTAsIDAuMDIzMTYyNzY5MDc4MDMxXSxcXG4gICAgWzAuMDIwOTA2MTc0OTczNjcwLCAwLjAyMzIyNzAxNzYyOTY5OF0sXFxuICAgIFswLjAyMDgzNDgxNzA5OTQwOSwgMC4wMjMyOTEwNDc1NTk4MjhdLFxcbiAgICBbMC4wMjA3NjMyNjMxMTk5MTUsIDAuMDIzMzU0ODU4MjY1NzQ4XSxcXG4gICAgWzAuMDIwNjkxNTEzNzA4NjgwLCAwLjAyMzQxODQ0OTE0Njg0OF0sXFxuICAgIFswLjAyMDYxOTU2OTU0MTAzOCwgMC4wMjM0ODE4MTk2MDQ1ODVdLFxcbiAgICBbMC4wMjA1NDc0MzEyOTQxNTUsIDAuMDIzNTQ0OTY5MDQyNDk0XSxcXG4gICAgWzAuMDIwNDc1MDk5NjQ3MDIzLCAwLjAyMzYwNzg5Njg2NjE4Nl0sXFxuICAgIFswLjAyMDQwMjU3NTI4MDQ1NSwgMC4wMjM2NzA2MDI0ODMzNjNdLFxcbiAgICBbMC4wMjAzMjk4NTg4NzcwNzgsIDAuMDIzNzMzMDg1MzAzODEzXSxcXG4gICAgWzAuMDIwMjU2OTUxMTIxMzI3LCAwLjAyMzc5NTM0NDczOTQyN10sXFxuICAgIFswLjAyMDE4Mzg1MjY5OTQzNywgMC4wMjM4NTczODAyMDQxOTNdLFxcbiAgICBbMC4wMjAxMTA1NjQyOTk0MzksIDAuMDIzOTE5MTkxMTE0MjExXSxcXG4gICAgWzAuMDIwMDM3MDg2NjExMTUwLCAwLjAyMzk4MDc3Njg4NzY5Ml0sXFxuICAgIFswLjAxOTk2MzQyMDMyNjE3MSwgMC4wMjQwNDIxMzY5NDQ5NjhdLFxcbiAgICBbMC4wMTk4ODk1NjYxMzc4NzcsIDAuMDI0MTAzMjcwNzA4NDk1XSxcXG4gICAgWzAuMDE5ODE1NTI0NzQxNDEyLCAwLjAyNDE2NDE3NzYwMjg1OV0sXFxuICAgIFswLjAxOTc0MTI5NjgzMzY4MSwgMC4wMjQyMjQ4NTcwNTQ3NzldLFxcbiAgICBbMC4wMTk2NjY4ODMxMTMzNDYsIDAuMDI0Mjg1MzA4NDkzMTIwXSxcXG4gICAgWzAuMDE5NTkyMjg0MjgwODE3LCAwLjAyNDM0NTUzMTM0ODg4OF0sXFxuICAgIFswLjAxOTUxNzUwMTAzODI0NiwgMC4wMjQ0MDU1MjUwNTUyNDJdLFxcbiAgICBbMC4wMTk0NDI1MzQwODk1MjMsIDAuMDI0NDY1Mjg5MDQ3NTAwXSxcXG4gICAgWzAuMDE5MzY3Mzg0MTQwMjY0LCAwLjAyNDUyNDgyMjc2MzE0MV0sXFxuICAgIFswLjAxOTI5MjA1MTg5NzgwOSwgMC4wMjQ1ODQxMjU2NDE4MDldLFxcbiAgICBbMC4wMTkyMTY1MzgwNzEyMTUsIDAuMDI0NjQzMTk3MTI1MzIzXSxcXG4gICAgWzAuMDE5MTQwODQzMzcxMjQ2LCAwLjAyNDcwMjAzNjY1NzY4MV0sXFxuICAgIFswLjAxOTA2NDk2ODUxMDM2OSwgMC4wMjQ3NjA2NDM2ODUwNjNdLFxcbiAgICBbMC4wMTg5ODg5MTQyMDI3NDgsIDAuMDI0ODE5MDE3NjU1ODM2XSxcXG4gICAgWzAuMDE4OTEyNjgxMTY0MjM0LCAwLjAyNDg3NzE1ODAyMDU2Ml0sXFxuICAgIFswLjAxODgzNjI3MDExMjM2MywgMC4wMjQ5MzUwNjQyMzIwMDNdLFxcbiAgICBbMC4wMTg3NTk2ODE3NjYzNDMsIDAuMDI0OTkyNzM1NzQ1MTIzXSxcXG4gICAgWzAuMDE4NjgyOTE2ODQ3MDU0LCAwLjAyNTA1MDE3MjAxNzA5NV0sXFxuICAgIFswLjAxODYwNTk3NjA3NzAzNywgMC4wMjUxMDczNzI1MDczMDhdLFxcbiAgICBbMC4wMTg1Mjg4NjAxODA0ODYsIDAuMDI1MTY0MzM2Njc3MzY5XSxcXG4gICAgWzAuMDE4NDUxNTY5ODgzMjQ3LCAwLjAyNTIyMTA2Mzk5MTExMF0sXFxuICAgIFswLjAxODM3NDEwNTkxMjgwNSwgMC4wMjUyNzc1NTM5MTQ1OTFdLFxcbiAgICBbMC4wMTgyOTY0Njg5OTgyODAsIDAuMDI1MzMzODA1OTE2MTA3XSxcXG4gICAgWzAuMDE4MjE4NjU5ODcwNDIxLCAwLjAyNTM4OTgxOTQ2NjE5NF0sXFxuICAgIFswLjAxODE0MDY3OTI2MTU5NiwgMC4wMjU0NDU1OTQwMzc2MzBdLFxcbiAgICBbMC4wMTgwNjI1Mjc5MDU3OTAsIDAuMDI1NTAxMTI5MTA1NDQ1XSxcXG4gICAgWzAuMDE3OTg0MjA2NTM4NTkyLCAwLjAyNTU1NjQyNDE0NjkyMF0sXFxuICAgIFswLjAxNzkwNTcxNTg5NzE5MiwgMC4wMjU2MTE0Nzg2NDE1OThdLFxcbiAgICBbMC4wMTc4MjcwNTY3MjAzNzUsIDAuMDI1NjY2MjkyMDcxMjg1XSxcXG4gICAgWzAuMDE3NzQ4MjI5NzQ4NTExLCAwLjAyNTcyMDg2MzkyMDA1Nl0sXFxuICAgIFswLjAxNzY2OTIzNTcyMzU1MCwgMC4wMjU3NzUxOTM2NzQyNjBdLFxcbiAgICBbMC4wMTc1OTAwNzUzODkwMTIsIDAuMDI1ODI5MjgwODIyNTI1XSxcXG4gICAgWzAuMDE3NTEwNzQ5NDg5OTg2LCAwLjAyNTg4MzEyNDg1NTc2Ml0sXFxuICAgIFswLjAxNzQzMTI1ODc3MzExNiwgMC4wMjU5MzY3MjUyNjcxNzBdLFxcbiAgICBbMC4wMTczNTE2MDM5ODY2MDAsIDAuMDI1OTkwMDgxNTUyMjQyXSxcXG4gICAgWzAuMDE3MjcxNzg1ODgwMTgwLCAwLjAyNjA0MzE5MzIwODc2OF0sXFxuICAgIFswLjAxNzE5MTgwNTIwNTEzMiwgMC4wMjYwOTYwNTk3MzY4NDFdLFxcbiAgICBbMC4wMTcxMTE2NjI3MTQyNjcsIDAuMDI2MTQ4NjgwNjM4ODYxXSxcXG4gICAgWzAuMDE3MDMxMzU5MTYxOTE1LCAwLjAyNjIwMTA1NTQxOTU0MV0sXFxuICAgIFswLjAxNjk1MDg5NTMwMzkyNCwgMC4wMjYyNTMxODM1ODU5MDhdLFxcbiAgICBbMC4wMTY4NzAyNzE4OTc2NTEsIDAuMDI2MzA1MDY0NjQ3MzEzXSxcXG4gICAgWzAuMDE2Nzg5NDg5NzAxOTU0LCAwLjAyNjM1NjY5ODExNTQzMV0sXFxuICAgIFswLjAxNjcwODU0OTQ3NzE4NiwgMC4wMjY0MDgwODM1MDQyNjldLFxcbiAgICBbMC4wMTY2Mjc0NTE5ODUxODcsIDAuMDI2NDU5MjIwMzMwMTY3XSxcXG4gICAgWzAuMDE2NTQ2MTk3OTg5Mjc3LCAwLjAyNjUxMDEwODExMTgwNl0sXFxuICAgIFswLjAxNjQ2NDc4ODI1NDI1MCwgMC4wMjY1NjA3NDYzNzAyMTJdLFxcbiAgICBbMC4wMTYzODMyMjM1NDYzNjUsIDAuMDI2NjExMTM0NjI4NzU3XSxcXG4gICAgWzAuMDE2MzAxNTA0NjMzMzQxLCAwLjAyNjY2MTI3MjQxMzE2OF0sXFxuICAgIFswLjAxNjIxOTYzMjI4NDM0NiwgMC4wMjY3MTExNTkyNTE1MzBdLFxcbiAgICBbMC4wMTYxMzc2MDcyNjk5OTYsIDAuMDI2NzYwNzk0Njc0Mjg4XSxcXG4gICAgWzAuMDE2MDU1NDMwMzYyMzQwLCAwLjAyNjgxMDE3ODIxNDI1NF0sXFxuICAgIFswLjAxNTk3MzEwMjMzNDg1OCwgMC4wMjY4NTkzMDk0MDY2MTNdLFxcbiAgICBbMC4wMTU4OTA2MjM5NjI0NTQsIDAuMDI2OTA4MTg3Nzg4OTIyXSxcXG4gICAgWzAuMDE1ODA3OTk2MDIxNDQ2LCAwLjAyNjk1NjgxMjkwMTExOV0sXFxuICAgIFswLjAxNTcyNTIxOTI4OTU1OCwgMC4wMjcwMDUxODQyODU1MjddLFxcbiAgICBbMC4wMTU2NDIyOTQ1NDU5MTgsIDAuMDI3MDUzMzAxNDg2ODU2XSxcXG4gICAgWzAuMDE1NTU5MjIyNTcxMDQ0LCAwLjAyNzEwMTE2NDA1MjIwOF0sXFxuICAgIFswLjAxNTQ3NjAwNDE0Njg0MiwgMC4wMjcxNDg3NzE1MzEwODNdLFxcbiAgICBbMC4wMTUzOTI2NDAwNTY1OTQsIDAuMDI3MTk2MTIzNDc1MzgwXSxcXG4gICAgWzAuMDE1MzA5MTMxMDg0OTU2LCAwLjAyNzI0MzIxOTQzOTQwNl0sXFxuICAgIFswLjAxNTIyNTQ3ODAxNzk0NiwgMC4wMjcyOTAwNTg5Nzk4NzVdLFxcbiAgICBbMC4wMTUxNDE2ODE2NDI5MzgsIDAuMDI3MzM2NjQxNjU1OTE1XSxcXG4gICAgWzAuMDE1MDU3NzQyNzQ4NjU2LCAwLjAyNzM4Mjk2NzAyOTA3M10sXFxuICAgIFswLjAxNDk3MzY2MjEyNTE2NCwgMC4wMjc0MjkwMzQ2NjMzMTddLFxcbiAgICBbMC4wMTQ4ODk0NDA1NjM4NjIsIDAuMDI3NDc0ODQ0MTI1MDQwXSxcXG4gICAgWzAuMDE0ODA1MDc4ODU3NDc0LCAwLjAyNzUyMDM5NDk4MzA2Nl0sXFxuICAgIFswLjAxNDcyMDU3NzgwMDA0NiwgMC4wMjc1NjU2ODY4MDg2NTRdLFxcbiAgICBbMC4wMTQ2MzU5MzgxODY5MzQsIDAuMDI3NjEwNzE5MTc1NDk5XSxcXG4gICAgWzAuMDE0NTUxMTYwODE0Nzk3LCAwLjAyNzY1NTQ5MTY1OTc0MF0sXFxuICAgIFswLjAxNDQ2NjI0NjQ4MTU5MiwgMC4wMjc3MDAwMDM4Mzk5NjBdLFxcbiAgICBbMC4wMTQzODExOTU5ODY1NjcsIDAuMDI3NzQ0MjU1Mjk3MTk1XSxcXG4gICAgWzAuMDE0Mjk2MDEwMTMwMjQ3LCAwLjAyNzc4ODI0NTYxNDkzM10sXFxuICAgIFswLjAxNDIxMDY4OTcxNDQzNiwgMC4wMjc4MzE5NzQzNzkxMjBdLFxcbiAgICBbMC4wMTQxMjUyMzU1NDIyMDEsIDAuMDI3ODc1NDQxMTc4MTY1XSxcXG4gICAgWzAuMDE0MDM5NjQ4NDE3ODcwLCAwLjAyNzkxODY0NTYwMjk0MV0sXFxuICAgIFswLjAxMzk1MzkyOTE0NzAyMCwgMC4wMjc5NjE1ODcyNDY3OTJdLFxcbiAgICBbMC4wMTM4NjgwNzg1MzY0NzYsIDAuMDI4MDA0MjY1NzA1NTM0XSxcXG4gICAgWzAuMDEzNzgyMDk3Mzk0Mjk0LCAwLjAyODA0NjY4MDU3NzQ2Ml0sXFxuICAgIFswLjAxMzY5NTk4NjUyOTc2MywgMC4wMjgwODg4MzE0NjMzNTFdLFxcbiAgICBbMC4wMTM2MDk3NDY3NTMzOTAsIDAuMDI4MTMwNzE3OTY2NDYxXSxcXG4gICAgWzAuMDEzNTIzMzc4ODc2ODk4LCAwLjAyODE3MjMzOTY5MjU0MF0sXFxuICAgIFswLjAxMzQzNjg4MzcxMzIxNCwgMC4wMjgyMTM2OTYyNDk4MjhdLFxcbiAgICBbMC4wMTMzNTAyNjIwNzY0NjIsIDAuMDI4MjU0Nzg3MjQ5MDYyXSxcXG4gICAgWzAuMDEzMjYzNTE0NzgxOTYwLCAwLjAyODI5NTYxMjMwMzQ3OF0sXFxuICAgIFswLjAxMzE3NjY0MjY0NjIwNSwgMC4wMjgzMzYxNzEwMjg4MTRdLFxcbiAgICBbMC4wMTMwODk2NDY0ODY4NzEsIDAuMDI4Mzc2NDYzMDQzMzE3XSxcXG4gICAgWzAuMDEzMDAyNTI3MTIyNzk5LCAwLjAyODQxNjQ4Nzk2Nzc0M10sXFxuICAgIFswLjAxMjkxNTI4NTM3Mzk5MCwgMC4wMjg0NTYyNDU0MjUzNjFdLFxcbiAgICBbMC4wMTI4Mjc5MjIwNjE1OTcsIDAuMDI4NDk1NzM1MDQxOTYwXSxcXG4gICAgWzAuMDEyNzQwNDM4MDA3OTE1LCAwLjAyODUzNDk1NjQ0NTg0OV0sXFxuICAgIFswLjAxMjY1MjgzNDAzNjM3OSwgMC4wMjg1NzM5MDkyNjc4NTldLFxcbiAgICBbMC4wMTI1NjUxMTA5NzE1NTAsIDAuMDI4NjEyNTkzMTQxMzU0XSxcXG4gICAgWzAuMDEyNDc3MjY5NjM5MTExLCAwLjAyODY1MTAwNzcwMjIyNF0sXFxuICAgIFswLjAxMjM4OTMxMDg2NTg1OCwgMC4wMjg2ODkxNTI1ODg4OTldLFxcbiAgICBbMC4wMTIzMDEyMzU0Nzk2OTMsIDAuMDI4NzI3MDI3NDQyMzQzXSxcXG4gICAgWzAuMDEyMjEzMDQ0MzA5NjE1LCAwLjAyODc2NDYzMTkwNjA2NV0sXFxuICAgIFswLjAxMjEyNDczODE4NTcxMiwgMC4wMjg4MDE5NjU2MjYxMTVdLFxcbiAgICBbMC4wMTIwMzYzMTc5MzkxNTYsIDAuMDI4ODM5MDI4MjUxMDk3XSxcXG4gICAgWzAuMDExOTQ3Nzg0NDAyMTkxLCAwLjAyODg3NTgxOTQzMjE2MV0sXFxuICAgIFswLjAxMTg1OTEzODQwODEzMCwgMC4wMjg5MTIzMzg4MjMwMTVdLFxcbiAgICBbMC4wMTE3NzAzODA3OTEzNDEsIDAuMDI4OTQ4NTg2MDc5OTI1XSxcXG4gICAgWzAuMDExNjgxNTEyMzg3MjQ1LCAwLjAyODk4NDU2MDg2MTcxOF0sXFxuICAgIFswLjAxMTU5MjUzNDAzMjMwNiwgMC4wMjkwMjAyNjI4Mjk3ODVdLFxcbiAgICBbMC4wMTE1MDM0NDY1NjQwMjIsIDAuMDI5MDU1NjkxNjQ4MDg3XSxcXG4gICAgWzAuMDExNDE0MjUwODIwOTE4LCAwLjAyOTA5MDg0Njk4MzE1Ml0sXFxuICAgIFswLjAxMTMyNDk0NzY0MjUzNywgMC4wMjkxMjU3Mjg1MDQwODddLFxcbiAgICBbMC4wMTEyMzU1Mzc4Njk0MzcsIDAuMDI5MTYwMzM1ODgyNTczXSxcXG4gICAgWzAuMDExMTQ2MDIyMzQzMTc1LCAwLjAyOTE5NDY2ODc5Mjg3MV0sXFxuICAgIFswLjAxMTA1NjQwMTkwNjMwNSwgMC4wMjkyMjg3MjY5MTE4MjhdLFxcbiAgICBbMC4wMTA5NjY2Nzc0MDIzNzEsIDAuMDI5MjYyNTA5OTE4ODc2XSxcXG4gICAgWzAuMDEwODc2ODQ5Njc1ODkxLCAwLjAyOTI5NjAxNzQ5NjAzNl0sXFxuICAgIFswLjAxMDc4NjkxOTU3MjM2MSwgMC4wMjkzMjkyNDkzMjc5MjJdLFxcbiAgICBbMC4wMTA2OTY4ODc5MzgyMzUsIDAuMDI5MzYyMjA1MTAxNzQzXSxcXG4gICAgWzAuMDEwNjA2NzU1NjIwOTI2LCAwLjAyOTM5NDg4NDUwNzMwOF0sXFxuICAgIFswLjAxMDUxNjUyMzQ2ODc5MywgMC4wMjk0MjcyODcyMzcwMjRdLFxcbiAgICBbMC4wMTA0MjYxOTIzMzExMzcsIDAuMDI5NDU5NDEyOTg1OTA2XSxcXG4gICAgWzAuMDEwMzM1NzYzMDU4MTg3LCAwLjAyOTQ5MTI2MTQ1MTU3M10sXFxuICAgIFswLjAxMDI0NTIzNjUwMTA5OSwgMC4wMjk1MjI4MzIzMzQyNTVdLFxcbiAgICBbMC4wMTAxNTQ2MTM1MTE5NDMsIDAuMDI5NTU0MTI1MzM2Nzk2XSxcXG4gICAgWzAuMDEwMDYzODk0OTQzNjk4LCAwLjAyOTU4NTE0MDE2NDY1NF0sXFxuICAgIFswLjAwOTk3MzA4MTY1MDI0MCwgMC4wMjk2MTU4NzY1MjU5MDVdLFxcbiAgICBbMC4wMDk4ODIxNzQ0ODYzNDAsIDAuMDI5NjQ2MzM0MTMxMjQ3XSxcXG4gICAgWzAuMDA5NzkxMTc0MzA3NjUwLCAwLjAyOTY3NjUxMjY5NDAwMV0sXFxuICAgIFswLjAwOTcwMDA4MTk3MDY5OSwgMC4wMjk3MDY0MTE5MzAxMTZdLFxcbiAgICBbMC4wMDk2MDg4OTgzMzI4ODEsIDAuMDI5NzM2MDMxNTU4MTY4XSxcXG4gICAgWzAuMDA5NTE3NjI0MjUyNDUzLCAwLjAyOTc2NTM3MTI5OTM2Nl0sXFxuICAgIFswLjAwOTQyNjI2MDU4ODUyMSwgMC4wMjk3OTQ0MzA4Nzc1NTNdLFxcbiAgICBbMC4wMDkzMzQ4MDgyMDEwMzQsIDAuMDI5ODIzMjEwMDE5MjEwXSxcXG4gICAgWzAuMDA5MjQzMjY3OTUwNzc4LCAwLjAyOTg1MTcwODQ1MzQ1Nl0sXFxuICAgIFswLjAwOTE1MTY0MDY5OTM2MywgMC4wMjk4Nzk5MjU5MTIwNTNdLFxcbiAgICBbMC4wMDkwNTk5MjczMDkyMjAsIDAuMDI5OTA3ODYyMTI5NDA4XSxcXG4gICAgWzAuMDA4OTY4MTI4NjQzNTkxLCAwLjAyOTkzNTUxNjg0MjU3M10sXFxuICAgIFswLjAwODg3NjI0NTU2NjUyMCwgMC4wMjk5NjI4ODk3OTEyNTRdLFxcbiAgICBbMC4wMDg3ODQyNzg5NDI4NDUsIDAuMDI5OTg5OTgwNzE3ODA1XSxcXG4gICAgWzAuMDA4NjkyMjI5NjM4MTkxLCAwLjAzMDAxNjc4OTM2NzIzNV0sXFxuICAgIFswLjAwODYwMDA5ODUxODk2MSwgMC4wMzAwNDMzMTU0ODcyMTJdLFxcbiAgICBbMC4wMDg1MDc4ODY0NTIzMjksIDAuMDMwMDY5NTU4ODI4MDYyXSxcXG4gICAgWzAuMDA4NDE1NTk0MzA2MjMwLCAwLjAzMDA5NTUxOTE0Mjc3Ml0sXFxuICAgIFswLjAwODMyMzIyMjk0OTM1MSwgMC4wMzAxMjExOTYxODY5OTRdLFxcbiAgICBbMC4wMDgyMzA3NzMyNTExMjksIDAuMDMwMTQ2NTg5NzE5MDQ2XSxcXG4gICAgWzAuMDA4MTM4MjQ2MDgxNzMzLCAwLjAzMDE3MTY5OTQ5OTkxNV0sXFxuICAgIFswLjAwODA0NTY0MjMxMjA2NywgMC4wMzAxOTY1MjUyOTMyNTddLFxcbiAgICBbMC4wMDc5NTI5NjI4MTM3NTAsIDAuMDMwMjIxMDY2ODY1NDAyXSxcXG4gICAgWzAuMDA3ODYwMjA4NDU5MTE5LCAwLjAzMDI0NTMyMzk4NTM1N10sXFxuICAgIFswLjAwNzc2NzM4MDEyMTIxMiwgMC4wMzAyNjkyOTY0MjQ4MDNdLFxcbiAgICBbMC4wMDc2NzQ0Nzg2NzM3NjYsIDAuMDMwMjkyOTgzOTU4MTAzXSxcXG4gICAgWzAuMDA3NTgxNTA0OTkxMjAzLCAwLjAzMDMxNjM4NjM2MjMwMl0sXFxuICAgIFswLjAwNzQ4ODQ1OTk0ODYyOCwgMC4wMzAzMzk1MDM0MTcxMjZdLFxcbiAgICBbMC4wMDczOTUzNDQ0MjE4MTYsIDAuMDMwMzYyMzM0OTA0OTg5XSxcXG4gICAgWzAuMDA3MzAyMTU5Mjg3MjA2LCAwLjAzMDM4NDg4MDYxMDk5M10sXFxuICAgIFswLjAwNzIwODkwNTQyMTg5MSwgMC4wMzA0MDcxNDAzMjI5MjhdLFxcbiAgICBbMC4wMDcxMTU1ODM3MDM2MTMsIDAuMDMwNDI5MTEzODMxMjc4XSxcXG4gICAgWzAuMDA3MDIyMTk1MDEwNzUyLCAwLjAzMDQ1MDgwMDkyOTIyMF0sXFxuICAgIFswLjAwNjkyODc0MDIyMjMxNiwgMC4wMzA0NzIyMDE0MTI2MjZdLFxcbiAgICBbMC4wMDY4MzUyMjAyMTc5MzksIDAuMDMwNDkzMzE1MDgwMDY4XSxcXG4gICAgWzAuMDA2NzQxNjM1ODc3ODY2LCAwLjAzMDUxNDE0MTczMjgxNF0sXFxuICAgIFswLjAwNjY0Nzk4ODA4Mjk0OCwgMC4wMzA1MzQ2ODExNzQ4MzhdLFxcbiAgICBbMC4wMDY1NTQyNzc3MTQ2MzUsIDAuMDMwNTU0OTMzMjEyODEzXSxcXG4gICAgWzAuMDA2NDYwNTA1NjU0OTY0LCAwLjAzMDU3NDg5NzY1NjExOV0sXFxuICAgIFswLjAwNjM2NjY3Mjc4NjU1MywgMC4wMzA1OTQ1NzQzMTY4NDVdLFxcbiAgICBbMC4wMDYyNzI3Nzk5OTI1OTMsIDAuMDMwNjEzOTYzMDA5Nzg2XSxcXG4gICAgWzAuMDA2MTc4ODI4MTU2ODM5LCAwLjAzMDYzMzA2MzU1MjQ0N10sXFxuICAgIFswLjAwNjA4NDgxODE2MzYwMSwgMC4wMzA2NTE4NzU3NjUwNDhdLFxcbiAgICBbMC4wMDU5OTA3NTA4OTc3MzcsIDAuMDMwNjcwMzk5NDcwNTIwXSxcXG4gICAgWzAuMDA1ODk2NjI3MjQ0NjQ0LCAwLjAzMDY4ODYzNDQ5NDUxMl0sXFxuICAgIFswLjAwNTgwMjQ0ODA5MDI1MCwgMC4wMzA3MDY1ODA2NjUzODhdLFxcbiAgICBbMC4wMDU3MDgyMTQzMjEwMDQsIDAuMDMwNzI0MjM3ODE0MjMyXSxcXG4gICAgWzAuMDA1NjEzOTI2ODIzODcxLCAwLjAzMDc0MTYwNTc3NDg0OV0sXFxuICAgIFswLjAwNTUxOTU4NjQ4NjMyMSwgMC4wMzA3NTg2ODQzODM3NjRdLFxcbiAgICBbMC4wMDU0MjUxOTQxOTYzMjEsIDAuMDMwNzc1NDczNDgwMjI4XSxcXG4gICAgWzAuMDA1MzMwNzUwODQyMzI3LCAwLjAzMDc5MTk3MjkwNjIxNF0sXFxuICAgIFswLjAwNTIzNjI1NzMxMzI3NiwgMC4wMzA4MDgxODI1MDY0MjVdLFxcbiAgICBbMC4wMDUxNDE3MTQ0OTg1NzYsIDAuMDMwODI0MTAyMTI4Mjg4XSxcXG4gICAgWzAuMDA1MDQ3MTIzMjg4MTAyLCAwLjAzMDgzOTczMTYyMTk2M10sXFxuICAgIFswLjAwNDk1MjQ4NDU3MjE4MSwgMC4wMzA4NTUwNzA4NDAzMzldLFxcbiAgICBbMC4wMDQ4NTc3OTkyNDE1ODksIDAuMDMwODcwMTE5NjM5MDM2XSxcXG4gICAgWzAuMDA0NzYzMDY4MTg3NTQxLCAwLjAzMDg4NDg3Nzg3NjQxMV0sXFxuICAgIFswLjAwNDY2ODI5MjMwMTY4MSwgMC4wMzA4OTkzNDU0MTM1NTNdLFxcbiAgICBbMC4wMDQ1NzM0NzI0NzYwNzUsIDAuMDMwOTEzNTIyMTE0Mjg4XSxcXG4gICAgWzAuMDA0NDc4NjA5NjAzMjA1LCAwLjAzMDkyNzQwNzg0NTE4MF0sXFxuICAgIFswLjAwNDM4MzcwNDU3NTk1NiwgMC4wMzA5NDEwMDI0NzU1MzBdLFxcbiAgICBbMC4wMDQyODg3NTgyODc2MTAsIDAuMDMwOTU0MzA1ODc3MzgxXSxcXG4gICAgWzAuMDA0MTkzNzcxNjMxODM3LCAwLjAzMDk2NzMxNzkyNTUxNl0sXFxuICAgIFswLjAwNDA5ODc0NTUwMjY4OSwgMC4wMzA5ODAwMzg0OTc0NjFdLFxcbiAgICBbMC4wMDQwMDM2ODA3OTQ1ODcsIDAuMDMwOTkyNDY3NDczNDg2XSxcXG4gICAgWzAuMDAzOTA4NTc4NDAyMzE2LCAwLjAzMTAwNDYwNDczNjYwMl0sXFxuICAgIFswLjAwMzgxMzQzOTIyMTAxNywgMC4wMzEwMTY0NTAxNzI1NzFdLFxcbiAgICBbMC4wMDM3MTgyNjQxNDYxNzYsIDAuMDMxMDI4MDAzNjY5ODk5XSxcXG4gICAgWzAuMDAzNjIzMDU0MDczNjE2LCAwLjAzMTAzOTI2NTExOTgzOV0sXFxuICAgIFswLjAwMzUyNzgwOTg5OTQ5MiwgMC4wMzEwNTAyMzQ0MTYzOTRdLFxcbiAgICBbMC4wMDM0MzI1MzI1MjAyNzgsIDAuMDMxMDYwOTExNDU2MzE4XSxcXG4gICAgWzAuMDAzMzM3MjIyODMyNzYwLCAwLjAzMTA3MTI5NjEzOTExNF0sXFxuICAgIFswLjAwMzI0MTg4MTczNDAyOSwgMC4wMzEwODEzODgzNjcwMzddLFxcbiAgICBbMC4wMDMxNDY1MTAxMjE0NzQsIDAuMDMxMDkxMTg4MDQ1MDk1XSxcXG4gICAgWzAuMDAzMDUxMTA4ODkyNzY2LCAwLjAzMTEwMDY5NTA4MTA1MV0sXFxuICAgIFswLjAwMjk1NTY3ODk0NTg2MCwgMC4wMzExMDk5MDkzODU0MTldLFxcbiAgICBbMC4wMDI4NjAyMjExNzg5NzgsIDAuMDMxMTE4ODMwODcxNDczXSxcXG4gICAgWzAuMDAyNzY0NzM2NDkwNjA0LCAwLjAzMTEyNzQ1OTQ1NTIzOV0sXFxuICAgIFswLjAwMjY2OTIyNTc3OTQ3OCwgMC4wMzExMzU3OTUwNTU1MDFdLFxcbiAgICBbMC4wMDI1NzM2ODk5NDQ1ODMsIDAuMDMxMTQzODM3NTkzODAzXSxcXG4gICAgWzAuMDAyNDc4MTI5ODg1MTM3LCAwLjAzMTE1MTU4Njk5NDQ0NF0sXFxuICAgIFswLjAwMjM4MjU0NjUwMDU4OSwgMC4wMzExNTkwNDMxODQ0ODRdLFxcbiAgICBbMC4wMDIyODY5NDA2OTA2MDYsIDAuMDMxMTY2MjA2MDkzNzQzXSxcXG4gICAgWzAuMDAyMTkxMzEzMzU1MDY3LCAwLjAzMTE3MzA3NTY1NDgwMF0sXFxuICAgIFswLjAwMjA5NTY2NTM5NDA1MSwgMC4wMzExNzk2NTE4MDI5OThdLFxcbiAgICBbMC4wMDE5OTk5OTc3MDc4MzUsIDAuMDMxMTg1OTM0NDc2NDM4XSxcXG4gICAgWzAuMDAxOTA0MzExMTk2ODc4LCAwLjAzMTE5MTkyMzYxNTk4NV0sXFxuICAgIFswLjAwMTgwODYwNjc2MTgyMCwgMC4wMzExOTc2MTkxNjUyNjhdLFxcbiAgICBbMC4wMDE3MTI4ODUzMDM0NjUsIDAuMDMxMjAzMDIxMDcwNjc4XSxcXG4gICAgWzAuMDAxNjE3MTQ3NzIyNzgyLCAwLjAzMTIwODEyOTI4MTM3MF0sXFxuICAgIFswLjAwMTUyMTM5NDkyMDg4OSwgMC4wMzEyMTI5NDM3NDkyNjRdLFxcbiAgICBbMC4wMDE0MjU2Mjc3OTkwNDcsIDAuMDMxMjE3NDY0NDI5MDQzXSxcXG4gICAgWzAuMDAxMzI5ODQ3MjU4NjUzLCAwLjAzMTIyMTY5MTI3ODE1OV0sXFxuICAgIFswLjAwMTIzNDA1NDIwMTIzMSwgMC4wMzEyMjU2MjQyNTY4MjVdLFxcbiAgICBbMC4wMDExMzgyNDk1Mjg0MjAsIDAuMDMxMjI5MjYzMzI4MDI0XSxcXG4gICAgWzAuMDAxMDQyNDM0MTQxOTcxLCAwLjAzMTIzMjYwODQ1NzUwMl0sXFxuICAgIFswLjAwMDk0NjYwODk0MzczNiwgMC4wMzEyMzU2NTk2MTM3NzVdLFxcbiAgICBbMC4wMDA4NTA3NzQ4MzU2NTYsIDAuMDMxMjM4NDE2NzY4MTI0XSxcXG4gICAgWzAuMDAwNzU0OTMyNzE5NzU5LCAwLjAzMTI0MDg3OTg5NDU5N10sXFxuICAgIFswLjAwMDY1OTA4MzQ5ODE0OSwgMC4wMzEyNDMwNDg5NzAwMTBdLFxcbiAgICBbMC4wMDA1NjMyMjgwNzI5OTMsIDAuMDMxMjQ0OTIzOTczOTQ4XSxcXG4gICAgWzAuMDAwNDY3MzY3MzQ2NTIwLCAwLjAzMTI0NjUwNDg4ODc2Ml0sXFxuICAgIFswLjAwMDM3MTUwMjIyMTAwOCwgMC4wMzEyNDc3OTE2OTk1NzFdLFxcbiAgICBbMC4wMDAyNzU2MzM1OTg3NzUsIDAuMDMxMjQ4Nzg0Mzk0MjY0XSxcXG4gICAgWzAuMDAwMTc5NzYyMzgyMTc0LCAwLjAzMTI0OTQ4Mjk2MzQ5OF0sXFxuICAgIFswLjAwMDA4Mzg4OTQ3MzU4MSwgMC4wMzEyNDk4ODc0MDA2OTddXFxuXTtcXG5cXG5jb25zdCBNRENUX1RBQkxFXzI1NiA9IFtcXG4gICAgWzAuMDg4Mzg3OTMxNjc1OTIzLCAwLjAwMDI3MTE3MTYyODkzNV0sXFxuICAgIFswLjA4ODM1NDY1NTk5ODUwNywgMC4wMDI0NDAyMzgzODcwMzddLFxcbiAgICBbMC4wODgyNjgxNTg3ODAxMTAsIDAuMDA0NjA3ODM1MjM2NzgwXSxcXG4gICAgWzAuMDg4MTI4NDkyMTIzNDIzLCAwLjAwNjc3MjY1NjQ5ODg3NV0sXFxuICAgIFswLjA4NzkzNTc0MDE1ODQxOCwgMC4wMDg5MzMzOTgxNjU5NDJdLFxcbiAgICBbMC4wODc2OTAwMTg5OTE2NzAsIDAuMDExMDg4NzU4Njg3OTk0XSxcXG4gICAgWzAuMDg3MzkxNDc2NjM2NDIzLCAwLjAxMzIzNzQzOTc1NjQ0OF0sXFxuICAgIFswLjA4NzA0MDI5MjkyMzQyNywgMC4wMTUzNzgxNDcwODYxNzJdLFxcbiAgICBbMC4wODY2MzY2NzkzOTI2MjEsIDAuMDE3NTA5NTkxMTk1MTE4XSxcXG4gICAgWzAuMDg2MTgwODc5MTY1NzAzLCAwLjAxOTYzMDQ4ODE4MTA1M10sXFxuICAgIFswLjA4NTY3MzE2Njc5OTY4NiwgMC4wMjE3Mzk1NjA0OTQ5NDBdLFxcbiAgICBbMC4wODUxMTM4NDgxMjE1MTUsIDAuMDIzODM1NTM3NzEwNDc5XSxcXG4gICAgWzAuMDg0NTAzMjYwMDQzODQ3LCAwLjAyNTkxNzE1NzI4OTM2OV0sXFxuICAgIFswLjA4Mzg0MTc3MDM2MjExMCwgMC4wMjc5ODMxNjUzNDE4MTNdLFxcbiAgICBbMC4wODMxMjk3Nzc1MzI5NTIsIDAuMDMwMDMyMzE3MzgxODEzXSxcXG4gICAgWzAuMDgyMzY3NzEwNDM0MjMwLCAwLjAzMjA2MzM3OTA3NjgwM10sXFxuICAgIFswLjA4MTU1NjAyODEwNjY3MSwgMC4wMzQwNzUxMjY5OTExNjRdLFxcbiAgICBbMC4wODA2OTUyMTk0NzczNTYsIDAuMDM2MDY2MzQ5MzIzMTc3XSxcXG4gICAgWzAuMDc5Nzg1ODAzMDY1MjE2LCAwLjAzODAzNTg0NjYzNDk2NV0sXFxuICAgIFswLjA3ODgyODMyNjY2ODY5MywgMC4wMzk5ODI0MzI1NzQ5OTJdLFxcbiAgICBbMC4wNzc4MjMzNjcwMzU3NjYsIDAuMDQxOTA0OTM0NTkyNjc1XSxcXG4gICAgWzAuMDc2NzcxNTI5NTE2NTQwLCAwLjA0MzgwMjE5NDY0NDY4Nl0sXFxuICAgIFswLjA3NTY3MzQ0NzY5ODYwNiwgMC4wNDU2NzMwNjk4OTI1MTNdLFxcbiAgICBbMC4wNzQ1Mjk3ODMwMjUzOTAsIDAuMDQ3NTE2NDMzMzkwODYzXSxcXG4gICAgWzAuMDczMzQxMjI0Mzk3NzI4LCAwLjA0OTMzMTE3NDc2NjQ5MV0sXFxuICAgIFswLjA3MjEwODQ4Nzc1ODg5NCwgMC4wNTExMTYyMDA4ODcwNTJdLFxcbiAgICBbMC4wNzA4MzIzMTU2NjMzNDMsIDAuMDUyODcwNDM2NTE5NTU3XSxcXG4gICAgWzAuMDY5NTEzNDc2ODI5NDI5LCAwLjA1NDU5MjgyNDk3ODA1NV0sXFxuICAgIFswLjA2ODE1Mjc2NTY3NjM0OCwgMC4wNTYyODIzMjg3NjAxNDNdLFxcbiAgICBbMC4wNjY3NTEwMDE4NDU2MjAsIDAuMDU3OTM3OTMwMTcxOTE4XSxcXG4gICAgWzAuMDY1MzA5MDI5NzA3MzYxLCAwLjA1OTU1ODYzMTk0MDk5Nl0sXFxuICAgIFswLjA2MzgyNzcxNzg1MTY2OCwgMC4wNjExNDM0NTc4MTcyMzRdLFxcbiAgICBbMC4wNjIzMDc5NTg1NjU0MTMsIDAuMDYyNjkxNDUzMTYwNzg0XSxcXG4gICAgWzAuMDYwNzUwNjY3Mjk0NzYzLCAwLjA2NDIwMTY4NTUxNzEzNF0sXFxuICAgIFswLjA1OTE1Njc4MjA5Mzc0OSwgMC4wNjU2NzMyNDUxNzg3ODRdLFxcbiAgICBbMC4wNTc1MjcyNjMwNTkyMTYsIDAuMDY3MTA1MjQ1NzMzMjIwXSxcXG4gICAgWzAuMDU1ODYzMDkxNzUyNDk5LCAwLjA2ODQ5NjgyNDU5Njg1Ml0sXFxuICAgIFswLjA1NDE2NTI3MDYwODE2NSwgMC4wNjk4NDcxNDM1MzQ2MDldLFxcbiAgICBbMC4wNTI0MzQ4MjIzMzAxODgsIDAuMDcxMTU1Mzg5MTY0ODUzXSxcXG4gICAgWzAuMDUwNjcyNzg5Mjc1OTAzLCAwLjA3MjQyMDc3MzQ0OTMzNl0sXFxuICAgIFswLjA0ODg4MDIzMjgyODEzNSwgMC4wNzM2NDI1MzQxNjc4NzldLFxcbiAgICBbMC4wNDcwNTgyMzI3NTU4NjIsIDAuMDc0ODE5OTM1Mzc3NTEyXSxcXG4gICAgWzAuMDQ1MjA3ODg2NTYzNzk3LCAwLjA3NTk1MjI2Nzg1NTc3MV0sXFxuICAgIFswLjA0MzMzMDMwODgzMTI5OCwgMC4wNzcwMzg4NDk1Mjc5MTJdLFxcbiAgICBbMC4wNDE0MjY2MzA1NDA5ODQsIDAuMDc4MDc5MDI1ODc3NzY2XSxcXG4gICAgWzAuMDM5NDk3OTk4Mzk3NDczLCAwLjA3OTA3MjE3MDM0MTk5NF0sXFxuICAgIFswLjAzNzU0NTU3NDEzNjY1MywgMC4wODAwMTc2ODQ2ODc1MDZdLFxcbiAgICBbMC4wMzU1NzA1MzM4MjU4OTIsIDAuMDgwOTE0OTk5MzcxODE3XSxcXG4gICAgWzAuMDMzNTc0MDY3MTU1NjIyLCAwLjA4MTc2MzU3Mzg4NjExMl0sXFxuICAgIFswLjAzMTU1NzM3NjcyMjcxNCwgMC4wODI1NjI4OTcwODA4MzZdLFxcbiAgICBbMC4wMjk1MjE2NzczMDYwNzQsIDAuMDgzMzEyNDg3NDczNTg0XSxcXG4gICAgWzAuMDI3NDY4MTk1MTM0OTExLCAwLjA4NDAxMTg5MzUzOTEzMl0sXFxuICAgIFswLjAyNTM5ODE2NzE1MDEwMSwgMC4wODQ2NjA2OTM5ODE0MTldLFxcbiAgICBbMC4wMjMzMTI4NDAyNTkwOTgsIDAuMDg1MjU4NDk3OTg3MzIwXSxcXG4gICAgWzAuMDIxMjEzNDcwNTg0ODQ3LCAwLjA4NTgwNDk0NTQ2MjA1M10sXFxuICAgIFswLjAxOTEwMTMyMjcwOTEzOCwgMC4wODYyOTk3MDcyNDYwOTNdLFxcbiAgICBbMC4wMTY5Nzc2Njg5MTA4NzMsIDAuMDg2NzQyNDg1MzEzNDQyXSxcXG4gICAgWzAuMDE0ODQzNzg4Mzk5NjkyLCAwLjA4NzEzMzAxMjk1MTE0OV0sXFxuICAgIFswLjAxMjcwMDk2NjU0NTQyNSwgMC4wODc0NzEwNTQ5MTk5NjhdLFxcbiAgICBbMC4wMTA1NTA0OTQxMDM4MzAsIDAuMDg3NzU2NDA3NTk2MDU2XSxcXG4gICAgWzAuMDA4MzkzNjY2NDM5MDk2LCAwLjA4Nzk4ODg5OTA5MzYzMV0sXFxuICAgIFswLjAwNjIzMTc4Mjc0MzU1OCwgMC4wODgxNjgzODkzNjg1MTBdLFxcbiAgICBbMC4wMDQwNjYxNDUyNTUxMTYsIDAuMDg4Mjk0NzcwMzAyNDYxXSxcXG4gICAgWzAuMDAxODk4MDU4NDcyODE2LCAwLjA4ODM2Nzk2NTc2ODMzNl1cXG5dOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxuY29uc3QgTURDVF9UQUJMRV8xOTIwID0gWyAgICAgICAgICAgICBcXG4gICAgWzAuMDMyMjc0ODU4NTE4MDk3LCAwLjAwMDAxMzIwMjQwNDE3Nl0sXFxuICAgIFswLjAzMjI3NDY0MjQ5NDUwNSwgMC4wMDAxMTg4MjEzNzI0ODNdLFxcbiAgICBbMC4wMzIyNzQwODA4MzU0MjEsIDAuMDAwMjI0NDM5MDY4MzA4XSxcXG4gICAgWzAuMDMyMjczMTczNTQ2ODYwLCAwLjAwMDMzMDA1NDM2MDU3Ml0sXFxuICAgIFswLjAzMjI3MTkyMDYzODUzOCwgMC4wMDA0MzU2NjYxMTgyMThdLFxcbiAgICBbMC4wMzIyNzAzMjIxMjM4NzMsIDAuMDAwNTQxMjczMjEwMjMxXSxcXG4gICAgWzAuMDMyMjY4Mzc4MDE5OTg0LCAwLjAwMDY0Njg3NDUwNTY0Ml0sXFxuICAgIFswLjAzMjI2NjA4ODM0NzY5MSwgMC4wMDA3NTI0Njg4NzM1NDZdLFxcbiAgICBbMC4wMzIyNjM0NTMxMzE1MTQsIDAuMDAwODU4MDU1MTgzMTE0XSxcXG4gICAgWzAuMDMyMjYwNDcyMzk5Njc0LCAwLjAwMDk2MzYzMjMwMzYwMF0sXFxuICAgIFswLjAzMjI1NzE0NjE4NDA5MiwgMC4wMDEwNjkxOTkxMDQzNThdLFxcbiAgICBbMC4wMzIyNTM0NzQ1MjAzOTAsIDAuMDAxMTc0NzU0NDU0ODUzXSxcXG4gICAgWzAuMDMyMjQ5NDU3NDQ3ODg4LCAwLjAwMTI4MDI5NzIyNDY3MV0sXFxuICAgIFswLjAzMjI0NTA5NTAwOTYwNiwgMC4wMDEzODU4MjYyODM1MzVdLFxcbiAgICBbMC4wMzIyNDAzODcyNTIyNjIsIDAuMDAxNDkxMzQwNTAxMzEzXSxcXG4gICAgWzAuMDMyMjM1MzM0MjI2MjcyLCAwLjAwMTU5NjgzODc0ODAzMV0sXFxuICAgIFswLjAzMjIyOTkzNTk4NTc1MCwgMC4wMDE3MDIzMTk4OTM4OTBdLFxcbiAgICBbMC4wMzIyMjQxOTI1ODg1MDcsIDAuMDAxODA3NzgyODA5MjcxXSxcXG4gICAgWzAuMDMyMjE4MTA0MDk2MDUwLCAwLjAwMTkxMzIyNjM2NDc0OV0sXFxuICAgIFswLjAzMjIxMTY3MDU3MzU4MiwgMC4wMDIwMTg2NDk0MzExMTFdLFxcbiAgICBbMC4wMzIyMDQ4OTIwOTAwMDAsIDAuMDAyMTI0MDUwODc5MzU5XSxcXG4gICAgWzAuMDMyMTk3NzY4NzE3ODk4LCAwLjAwMjIyOTQyOTU4MDcyOF0sXFxuICAgIFswLjAzMjE5MDMwMDUzMzU2MCwgMC4wMDIzMzQ3ODQ0MDY2OThdLFxcbiAgICBbMC4wMzIxODI0ODc2MTY5NjUsIDAuMDAyNDQwMTE0MjI5MDAzXSxcXG4gICAgWzAuMDMyMTc0MzMwMDUxNzgyLCAwLjAwMjU0NTQxNzkxOTY0NF0sXFxuICAgIFswLjAzMjE2NTgyNzkyNTM3NCwgMC4wMDI2NTA2OTQzNTA5MDVdLFxcbiAgICBbMC4wMzIxNTY5ODEzMjg3OTAsIDAuMDAyNzU1OTQyMzk1MzU4XSxcXG4gICAgWzAuMDMyMTQ3NzkwMzU2NzcxLCAwLjAwMjg2MTE2MDkyNTg4M10sXFxuICAgIFswLjAzMjEzODI1NTEwNzc0NCwgMC4wMDI5NjYzNDg4MTU2NzJdLFxcbiAgICBbMC4wMzIxMjgzNzU2ODM4MjUsIDAuMDAzMDcxNTA0OTM4MjUwXSxcXG4gICAgWzAuMDMyMTE4MTUyMTkwODE0LCAwLjAwMzE3NjYyODE2NzQ3Nl0sXFxuICAgIFswLjAzMjEwNzU4NDczODE5NiwgMC4wMDMyODE3MTczNzc1NjhdLFxcbiAgICBbMC4wMzIwOTY2NzM0MzkxNDEsIDAuMDAzMzg2NzcxNDQzMTAyXSxcXG4gICAgWzAuMDMyMDg1NDE4NDEwNTAwLCAwLjAwMzQ5MTc4OTIzOTAzNl0sXFxuICAgIFswLjAzMjA3MzgxOTc3MjgwNCwgMC4wMDM1OTY3Njk2NDA3MTFdLFxcbiAgICBbMC4wMzIwNjE4Nzc2NTAyNjcsIDAuMDAzNzAxNzExNTIzODc0XSxcXG4gICAgWzAuMDMyMDQ5NTkyMTcwNzc4LCAwLjAwMzgwNjYxMzc2NDY4MF0sXFxuICAgIFswLjAzMjAzNjk2MzQ2NTkwNiwgMC4wMDM5MTE0NzUyMzk3MTFdLFxcbiAgICBbMC4wMzIwMjM5OTE2NzA4OTMsIDAuMDA0MDE2Mjk0ODI1OTg1XSxcXG4gICAgWzAuMDMyMDEwNjc2OTI0NjU3LCAwLjAwNDEyMTA3MTQwMDk2N10sXFxuICAgIFswLjAzMTk5NzAxOTM2OTc4OSwgMC4wMDQyMjU4MDM4NDI1ODZdLFxcbiAgICBbMC4wMzE5ODMwMTkxNTI1NDksIDAuMDA0MzMwNDkxMDI5MjQxXSxcXG4gICAgWzAuMDMxOTY4Njc2NDIyODY5LCAwLjAwNDQzNTEzMTgzOTgxNl0sXFxuICAgIFswLjAzMTk1Mzk5MTMzNDM0OCwgMC4wMDQ1Mzk3MjUxNTM2OTJdLFxcbiAgICBbMC4wMzE5Mzg5NjQwNDQyNTIsIDAuMDA0NjQ0MjY5ODUwNzU4XSxcXG4gICAgWzAuMDMxOTIzNTk0NzEzNTEwLCAwLjAwNDc0ODc2NDgxMTQyNl0sXFxuICAgIFswLjAzMTkwNzg4MzUwNjcxNiwgMC4wMDQ4NTMyMDg5MTY2MzhdLFxcbiAgICBbMC4wMzE4OTE4MzA1OTIxMjQsIDAuMDA0OTU3NjAxMDQ3ODgxXSxcXG4gICAgWzAuMDMxODc1NDM2MTQxNjQ4LCAwLjAwNTA2MTk0MDA4NzIwMF0sXFxuICAgIFswLjAzMTg1ODcwMDMzMDg1OSwgMC4wMDUxNjYyMjQ5MTcyMDhdLFxcbiAgICBbMC4wMzE4NDE2MjMzMzg5ODUsIDAuMDA1MjcwNDU0NDIxMDk3XSxcXG4gICAgWzAuMDMxODI0MjA1MzQ4OTA3LCAwLjAwNTM3NDYyNzQ4MjY1M10sXFxuICAgIFswLjAzMTgwNjQ0NjU0NzE1NiwgMC4wMDU0Nzg3NDI5ODYyNjddLFxcbiAgICBbMC4wMzE3ODgzNDcxMjM5MTYsIDAuMDA1NTgyNzk5ODE2OTQ1XSxcXG4gICAgWzAuMDMxNzY5OTA3MjczMDE3LCAwLjAwNTY4Njc5Njg2MDMyM10sXFxuICAgIFswLjAzMTc1MTEyNzE5MTkzNSwgMC4wMDU3OTA3MzMwMDI2NzRdLFxcbiAgICBbMC4wMzE3MzIwMDcwODE3ODksIDAuMDA1ODk0NjA3MTMwOTI4XSxcXG4gICAgWzAuMDMxNzEyNTQ3MTQ3MzQwLCAwLjAwNTk5ODQxODEzMjY3NV0sXFxuICAgIFswLjAzMTY5Mjc0NzU5Njk4OSwgMC4wMDYxMDIxNjQ4OTYxODJdLFxcbiAgICBbMC4wMzE2NzI2MDg2NDI3NzMsIDAuMDA2MjA1ODQ2MzEwNDA2XSxcXG4gICAgWzAuMDMxNjUyMTMwNTAwMzY0LCAwLjAwNjMwOTQ2MTI2NTAwMl0sXFxuICAgIFswLjAzMTYzMTMxMzM4OTA2NywgMC4wMDY0MTMwMDg2NTAzMzddLFxcbiAgICBbMC4wMzE2MTAxNTc1MzE4MTYsIDAuMDA2NTE2NDg3MzU3NTAxXSxcXG4gICAgWzAuMDMxNTg4NjYzMTU1MTcyLCAwLjAwNjYxOTg5NjI3ODMyMV0sXFxuICAgIFswLjAzMTU2NjgzMDQ4OTMyNSwgMC4wMDY3MjMyMzQzMDUzNzBdLFxcbiAgICBbMC4wMzE1NDQ2NTk3NjgwODMsIDAuMDA2ODI2NTAwMzMxOTgxXSxcXG4gICAgWzAuMDMxNTIyMTUxMjI4ODc4LCAwLjAwNjkyOTY5MzI1MjI1OF0sXFxuICAgIFswLjAzMTQ5OTMwNTExMjc1OCwgMC4wMDcwMzI4MTE5NjEwODhdLFxcbiAgICBbMC4wMzE0NzYxMjE2NjQzODcsIDAuMDA3MTM1ODU1MzU0MTUxXSxcXG4gICAgWzAuMDMxNDUyNjAxMTMyMDQwLCAwLjAwNzIzODgyMjMyNzkzN10sXFxuICAgIFswLjAzMTQyODc0Mzc2NzYwNCwgMC4wMDczNDE3MTE3Nzk3NTFdLFxcbiAgICBbMC4wMzE0MDQ1NDk4MjY1NzIsIDAuMDA3NDQ0NTIyNjA3NzMwXSxcXG4gICAgWzAuMDMxMzgwMDE5NTY4MDQyLCAwLjAwNzU0NzI1MzcxMDg1M10sXFxuICAgIFswLjAzMTM1NTE1MzI1NDcxMiwgMC4wMDc2NDk5MDM5ODg5NTJdLFxcbiAgICBbMC4wMzEzMjk5NTExNTI4ODIsIDAuMDA3NzUyNDcyMzQyNzI1XSxcXG4gICAgWzAuMDMxMzA0NDEzNTMyNDQ1LCAwLjAwNzg1NDk1NzY3Mzc0OF0sXFxuICAgIFswLjAzMTI3ODU0MDY2Njg4OCwgMC4wMDc5NTczNTg4ODQ0ODRdLFxcbiAgICBbMC4wMzEyNTIzMzI4MzMyOTAsIDAuMDA4MDU5Njc0ODc4MzAwXSxcXG4gICAgWzAuMDMxMjI1NzkwMzEyMzE2LCAwLjAwODE2MTkwNDU1OTQ3M10sXFxuICAgIFswLjAzMTE5ODkxMzM4ODIxNCwgMC4wMDgyNjQwNDY4MzMyMDVdLFxcbiAgICBbMC4wMzExNzE3MDIzNDg4MTQsIDAuMDA4MzY2MTAwNjA1NjM2XSxcXG4gICAgWzAuMDMxMTQ0MTU3NDg1NTI1LCAwLjAwODQ2ODA2NDc4Mzg0OV0sXFxuICAgIFswLjAzMTExNjI3OTA5MzMzMSwgMC4wMDg1Njk5MzgyNzU4OTNdLFxcbiAgICBbMC4wMzEwODgwNjc0NzA3ODYsIDAuMDA4NjcxNzE5OTkwNzgyXSxcXG4gICAgWzAuMDMxMDU5NTIyOTIwMDE0LCAwLjAwODc3MzQwODgzODUxN10sXFxuICAgIFswLjAzMTAzMDY0NTc0NjcwNSwgMC4wMDg4NzUwMDM3MzAwOTJdLFxcbiAgICBbMC4wMzEwMDE0MzYyNjAxMTAsIDAuMDA4OTc2NTAzNTc3NTA3XSxcXG4gICAgWzAuMDMwOTcxODk0NzczMDM5LCAwLjAwOTA3NzkwNzI5Mzc4MF0sXFxuICAgIFswLjAzMDk0MjAyMTYwMTg1NywgMC4wMDkxNzkyMTM3OTI5NTldLFxcbiAgICBbMC4wMzA5MTE4MTcwNjY0ODMsIDAuMDA5MjgwNDIxOTkwMTMzXSxcXG4gICAgWzAuMDMwODgxMjgxNDkwMzgyLCAwLjAwOTM4MTUzMDgwMTQ0NF0sXFxuICAgIFswLjAzMDg1MDQxNTIwMDU2NiwgMC4wMDk0ODI1MzkxNDQwOTddLFxcbiAgICBbMC4wMzA4MTkyMTg1Mjc1ODksIDAuMDA5NTgzNDQ1OTM2MzczXSxcXG4gICAgWzAuMDMwNzg3NjkxODA1NTQxLCAwLjAwOTY4NDI1MDA5NzY0M10sXFxuICAgIFswLjAzMDc1NTgzNTM3MjA0OCwgMC4wMDk3ODQ5NTA1NDgzNzVdLFxcbiAgICBbMC4wMzA3MjM2NDk1NjgyNjgsIDAuMDA5ODg1NTQ2MjEwMTQ3XSxcXG4gICAgWzAuMDMwNjkxMTM0NzM4ODgzLCAwLjAwOTk4NjAzNjAwNTY2MV0sXFxuICAgIFswLjAzMDY1ODI5MTIzMjEwMywgMC4wMTAwODY0MTg4NTg3NTNdLFxcbiAgICBbMC4wMzA2MjUxMTkzOTk2NTUsIDAuMDEwMTg2NjkzNjk0NDAyXSxcXG4gICAgWzAuMDMwNTkxNjE5NTk2NzgxLCAwLjAxMDI4Njg1OTQzODc0NV0sXFxuICAgIFswLjAzMDU1Nzc5MjE4MjIzOSwgMC4wMTAzODY5MTUwMTkwODhdLFxcbiAgICBbMC4wMzA1MjM2Mzc1MTgyOTIsIDAuMDEwNDg2ODU5MzYzOTE2XSxcXG4gICAgWzAuMDMwNDg5MTU1OTcwNzEwLCAwLjAxMDU4NjY5MTQwMjkwNl0sXFxuICAgIFswLjAzMDQ1NDM0NzkwODc2MywgMC4wMTA2ODY0MTAwNjY5MzZdLFxcbiAgICBbMC4wMzA0MTkyMTM3MDUyMTYsIDAuMDEwNzg2MDE0Mjg4MDk5XSxcXG4gICAgWzAuMDMwMzgzNzUzNzM2MzI5LCAwLjAxMDg4NTUwMjk5OTcxNF0sXFxuICAgIFswLjAzMDM0Nzk2ODM4MTg0OSwgMC4wMTA5ODQ4NzUxMzYzMzhdLFxcbiAgICBbMC4wMzAzMTE4NTgwMjUwMTAsIDAuMDExMDg0MTI5NjMzNzc1XSxcXG4gICAgWzAuMDMwMjc1NDIzMDUyNTIzLCAwLjAxMTE4MzI2NTQyOTA4OF0sXFxuICAgIFswLjAzMDIzODY2Mzg1NDU3OSwgMC4wMTEyODIyODE0NjA2MTJdLFxcbiAgICBbMC4wMzAyMDE1ODA4MjQ4MzgsIDAuMDExMzgxMTc2NjY3OTY3XSxcXG4gICAgWzAuMDMwMTY0MTc0MzYwNDMwLCAwLjAxMTQ3OTk0OTk5MjA2Ml0sXFxuICAgIFswLjAzMDEyNjQ0NDg2MTk0OCwgMC4wMTE1Nzg2MDAzNzUxMTddLFxcbiAgICBbMC4wMzAwODgzOTI3MzM0NDYsIDAuMDExNjc3MTI2NzYwNjYzXSxcXG4gICAgWzAuMDMwMDUwMDE4MzgyNDMwLCAwLjAxMTc3NTUyODA5MzU2M10sXFxuICAgIFswLjAzMDAxMTMyMjIxOTg1OSwgMC4wMTE4NzM4MDMzMjAwMThdLFxcbiAgICBbMC4wMjk5NzIzMDQ2NjAxMzgsIDAuMDExOTcxOTUxMzg3NTc4XSxcXG4gICAgWzAuMDI5OTMyOTY2MTIxMTE0LCAwLjAxMjA2OTk3MTI0NTE1N10sXFxuICAgIFswLjAyOTg5MzMwNzAyNDA3MCwgMC4wMTIxNjc4NjE4NDMwNDFdLFxcbiAgICBbMC4wMjk4NTMzMjc3OTM3MjQsIDAuMDEyMjY1NjIyMTMyOTAxXSxcXG4gICAgWzAuMDI5ODEzMDI4ODU4MjIyLCAwLjAxMjM2MzI1MTA2NzgwMV0sXFxuICAgIFswLjAyOTc3MjQxMDY0OTEzMiwgMC4wMTI0NjA3NDc2MDIyMTVdLFxcbiAgICBbMC4wMjk3MzE0NzM2MDE0NDMsIDAuMDEyNTU4MTEwNjkyMDMzXSxcXG4gICAgWzAuMDI5NjkwMjE4MTUzNTU4LCAwLjAxMjY1NTMzOTI5NDU3NV0sXFxuICAgIFswLjAyOTY0ODY0NDc0NzI4OSwgMC4wMTI3NTI0MzIzNjg2MDBdLFxcbiAgICBbMC4wMjk2MDY3NTM4Mjc4NTUsIDAuMDEyODQ5Mzg4ODc0MzIwXSxcXG4gICAgWzAuMDI5NTY0NTQ1ODQzODcyLCAwLjAxMjk0NjIwNzc3MzQwN10sXFxuICAgIFswLjAyOTUyMjAyMTI0NzM1NiwgMC4wMTMwNDI4ODgwMjkwMTFdLFxcbiAgICBbMC4wMjk0NzkxODA0OTM3MTAsIDAuMDEzMTM5NDI4NjA1NzYyXSxcXG4gICAgWzAuMDI5NDM2MDI0MDQxNzI1LCAwLjAxMzIzNTgyODQ2OTc4OV0sXFxuICAgIFswLjAyOTM5MjU1MjM1MzU3MCwgMC4wMTMzMzIwODY1ODg3MjddLFxcbiAgICBbMC4wMjkzNDg3NjU4OTQ3OTQsIDAuMDEzNDI4MjAxOTMxNzI4XSxcXG4gICAgWzAuMDI5MzA0NjY1MTM0MzEzLCAwLjAxMzUyNDE3MzQ2OTQ3NV0sXFxuICAgIFswLjAyOTI2MDI1MDU0NDQxMiwgMC4wMTM2MjAwMDAxNzQxODldLFxcbiAgICBbMC4wMjkyMTU1MjI2MDA3MzUsIDAuMDEzNzE1NjgxMDE5NjQzXSxcXG4gICAgWzAuMDI5MTcwNDgxNzgyMjgzLCAwLjAxMzgxMTIxNDk4MTE3M10sXFxuICAgIFswLjAyOTEyNTEyODU3MTQwNiwgMC4wMTM5MDY2MDEwMzU2ODZdLFxcbiAgICBbMC4wMjkwNzk0NjM0NTM4MDEsIDAuMDE0MDAxODM4MTYxNjc0XSxcXG4gICAgWzAuMDI5MDMzNDg2OTE4NTA1LCAwLjAxNDA5NjkyNTMzOTIyNV0sXFxuICAgIFswLjAyODk4NzE5OTQ1Nzg4OSwgMC4wMTQxOTE4NjE1NTAwMzFdLFxcbiAgICBbMC4wMjg5NDA2MDE1Njc2NTUsIDAuMDE0Mjg2NjQ1Nzc3NDAxXSxcXG4gICAgWzAuMDI4ODkzNjkzNzQ2ODI5LCAwLjAxNDM4MTI3NzAwNjI3M10sXFxuICAgIFswLjAyODg0NjQ3NjQ5Nzc1NSwgMC4wMTQ0NzU3NTQyMjMyMjFdLFxcbiAgICBbMC4wMjg3OTg5NTAzMjYwOTQsIDAuMDE0NTcwMDc2NDE2NDcyXSxcXG4gICAgWzAuMDI4NzUxMTE1NzQwODExLCAwLjAxNDY2NDI0MjU3NTkxMF0sXFxuICAgIFswLjAyODcwMjk3MzI1NDE3OCwgMC4wMTQ3NTgyNTE2OTMwOTFdLFxcbiAgICBbMC4wMjg2NTQ1MjMzODE3NjAsIDAuMDE0ODUyMTAyNzYxMjUzXSxcXG4gICAgWzAuMDI4NjA1NzY2NjQyNDE4LCAwLjAxNDk0NTc5NDc3NTMyNl0sXFxuICAgIFswLjAyODU1NjcwMzU1ODI5NywgMC4wMTUwMzkzMjY3MzE5NDVdLFxcbiAgICBbMC4wMjg1MDczMzQ2NTQ4MjMsIDAuMDE1MTMyNjk3NjI5NDU3XSxcXG4gICAgWzAuMDI4NDU3NjYwNDYwNjk4LCAwLjAxNTIyNTkwNjQ2NzkzNV0sXFxuICAgIFswLjAyODQwNzY4MTUwNzg5MSwgMC4wMTUzMTg5NTIyNDkxODddLFxcbiAgICBbMC4wMjgzNTczOTgzMzE2MzksIDAuMDE1NDExODMzOTc2NzY4XSxcXG4gICAgWzAuMDI4MzA2ODExNDcwNDMyLCAwLjAxNTUwNDU1MDY1NTk4OF0sXFxuICAgIFswLjAyODI1NTkyMTQ2NjAxNiwgMC4wMTU1OTcxMDEyOTM5MjddLFxcbiAgICBbMC4wMjgyMDQ3Mjg4NjMzODEsIDAuMDE1Njg5NDg0ODk5NDQyXSxcXG4gICAgWzAuMDI4MTUzMjM0MjEwNzYwLCAwLjAxNTc4MTcwMDQ4MzE3OV0sXFxuICAgIFswLjAyODEwMTQzODA1OTYxOSwgMC4wMTU4NzM3NDcwNTc1ODJdLFxcbiAgICBbMC4wMjgwNDkzNDA5NjQ2NTIsIDAuMDE1OTY1NjIzNjM2OTA3XSxcXG4gICAgWzAuMDI3OTk2OTQzNDgzNzc5LCAwLjAxNjA1NzMyOTIzNzIyOV0sXFxuICAgIFswLjAyNzk0NDI0NjE3ODEzMywgMC4wMTYxNDg4NjI4NzY0NTZdLFxcbiAgICBbMC4wMjc4OTEyNDk2MTIwNjEsIDAuMDE2MjQwMjIzNTc0MzM1XSxcXG4gICAgWzAuMDI3ODM3OTU0MzUzMTEzLCAwLjAxNjMzMTQxMDM1MjQ2N10sXFxuICAgIFswLjAyNzc4NDM2MDk3MjAzOSwgMC4wMTY0MjI0MjIyMzQzMTVdLFxcbiAgICBbMC4wMjc3MzA0NzAwNDI3ODAsIDAuMDE2NTEzMjU4MjQ1MjE0XSxcXG4gICAgWzAuMDI3Njc2MjgyMTQyNDY2LCAwLjAxNjYwMzkxNzQxMjM4NF0sXFxuICAgIFswLjAyNzYyMTc5Nzg1MTQwNSwgMC4wMTY2OTQzOTg3NjQ5MzhdLFxcbiAgICBbMC4wMjc1NjcwMTc3NTMwODAsIDAuMDE2Nzg0NzAxMzMzODk0XSxcXG4gICAgWzAuMDI3NTExOTQyNDM0MTQzLCAwLjAxNjg3NDgyNDE1MjE4M10sXFxuICAgIFswLjAyNzQ1NjU3MjQ4NDQwNCwgMC4wMTY5NjQ3NjYyNTQ2NjJdLFxcbiAgICBbMC4wMjc0MDA5MDg0OTY4MzMsIDAuMDE3MDU0NTI2Njc4MTI0XSxcXG4gICAgWzAuMDI3MzQ0OTUxMDY3NTQ2LCAwLjAxNzE0NDEwNDQ2MTMwN10sXFxuICAgIFswLjAyNzI4ODcwMDc5NTgwMSwgMC4wMTcyMzM0OTg2NDQ5MDRdLFxcbiAgICBbMC4wMjcyMzIxNTgyODM5OTQsIDAuMDE3MzIyNzA4MjcxNTc3XSxcXG4gICAgWzAuMDI3MTc1MzI0MTM3NjUxLCAwLjAxNzQxMTczMjM4NTk2MF0sXFxuICAgIFswLjAyNzExODE5ODk2NTQxOCwgMC4wMTc1MDA1NzAwMzQ2NzhdLFxcbiAgICBbMC4wMjcwNjA3ODMzNzkwNjAsIDAuMDE3NTg5MjIwMjY2MzUxXSxcXG4gICAgWzAuMDI3MDAzMDc3OTkzNDU0LCAwLjAxNzY3NzY4MjEzMTYwN10sXFxuICAgIFswLjAyNjk0NTA4MzQyNjU3NiwgMC4wMTc3NjU5NTQ2ODMwODhdLFxcbiAgICBbMC4wMjY4ODY4MDAyOTk1MDIsIDAuMDE3ODU0MDM2OTc1NDY4XSxcXG4gICAgWzAuMDI2ODI4MjI5MjM2Mzk3LCAwLjAxNzk0MTkyODA2NTQ1Nl0sXFxuICAgIFswLjAyNjc2OTM3MDg2NDUxMSwgMC4wMTgwMjk2MjcwMTE4MDhdLFxcbiAgICBbMC4wMjY3MTAyMjU4MTQxNzAsIDAuMDE4MTE3MTMyODc1MzQwXSxcXG4gICAgWzAuMDI2NjUwNzk0NzE4NzY4LCAwLjAxODIwNDQ0NDcxODkzNF0sXFxuICAgIFswLjAyNjU5MTA3ODIxNDc2NywgMC4wMTgyOTE1NjE2MDc1NTFdLFxcbiAgICBbMC4wMjY1MzEwNzY5NDE2ODAsIDAuMDE4Mzc4NDgyNjA4MjM4XSxcXG4gICAgWzAuMDI2NDcwNzkxNTQyMDc1LCAwLjAxODQ2NTIwNjc5MDE0Ml0sXFxuICAgIFswLjAyNjQxMDIyMjY2MTU1OCwgMC4wMTg1NTE3MzMyMjQ1MTVdLFxcbiAgICBbMC4wMjYzNDkzNzA5NDg3NzUsIDAuMDE4NjM4MDYwOTg0NzMwXSxcXG4gICAgWzAuMDI2Mjg4MjM3MDU1Mzk4LCAwLjAxODcyNDE4OTE0NjI4Nl0sXFxuICAgIFswLjAyNjIyNjgyMTYzNjEyMSwgMC4wMTg4MTAxMTY3ODY4MTldLFxcbiAgICBbMC4wMjYxNjUxMjUzNDg2NTYsIDAuMDE4ODk1ODQyOTg2MTEyXSxcXG4gICAgWzAuMDI2MTAzMTQ4ODUzNzE4LCAwLjAxODk4MTM2NjgyNjEwOV0sXFxuICAgIFswLjAyNjA0MDg5MjgxNTAyOCwgMC4wMTkwNjY2ODczOTA5MTZdLFxcbiAgICBbMC4wMjU5NzgzNTc4OTkyOTYsIDAuMDE5MTUxODAzNzY2ODE5XSxcXG4gICAgWzAuMDI1OTE1NTQ0Nzc2MjIzLCAwLjAxOTIzNjcxNTA0MjI5MF0sXFxuICAgIFswLjAyNTg1MjQ1NDExODQ4NSwgMC4wMTkzMjE0MjAzMDc5OThdLFxcbiAgICBbMC4wMjU3ODkwODY2MDE3MzMsIDAuMDE5NDA1OTE4NjU2ODE3XSxcXG4gICAgWzAuMDI1NzI1NDQyOTA0NTgyLCAwLjAxOTQ5MDIwOTE4MzgzN10sXFxuICAgIFswLjAyNTY2MTUyMzcwODYwNiwgMC4wMTk1NzQyOTA5ODYzNzZdLFxcbiAgICBbMC4wMjU1OTczMjk2OTgzMjcsIDAuMDE5NjU4MTYzMTYzOTg0XSxcXG4gICAgWzAuMDI1NTMyODYxNTYxMjExLCAwLjAxOTc0MTgyNDgxODQ1OF0sXFxuICAgIFswLjAyNTQ2ODExOTk4NzY2MiwgMC4wMTk4MjUyNzUwNTM4NDhdLFxcbiAgICBbMC4wMjU0MDMxMDU2NzEwMDgsIDAuMDE5OTA4NTEyOTc2NDcwXSxcXG4gICAgWzAuMDI1MzM3ODE5MzA3NTAxLCAwLjAxOTk5MTUzNzY5NDkxM10sXFxuICAgIFswLjAyNTI3MjI2MTU5NjMwNSwgMC4wMjAwNzQzNDgzMjAwNDddLFxcbiAgICBbMC4wMjUyMDY0MzMyMzk0OTEsIDAuMDIwMTU2OTQzOTY1MDM5XSxcXG4gICAgWzAuMDI1MTQwMzM0OTQyMDI4LCAwLjAyMDIzOTMyMzc0NTM1NV0sXFxuICAgIFswLjAyNTA3Mzk2NzQxMTc3NiwgMC4wMjAzMjE0ODY3Nzg3NzRdLFxcbiAgICBbMC4wMjUwMDczMzEzNTk0NzYsIDAuMDIwNDAzNDMyMTg1Mzk1XSxcXG4gICAgWzAuMDI0OTQwNDI3NDk4NzQ4LCAwLjAyMDQ4NTE1OTA4NzY1MF0sXFxuICAgIFswLjAyNDg3MzI1NjU0NjA3OSwgMC4wMjA1NjY2NjY2MTAzMDldLFxcbiAgICBbMC4wMjQ4MDU4MTkyMjA4MTYsIDAuMDIwNjQ3OTUzODgwNDkxXSxcXG4gICAgWzAuMDI0NzM4MTE2MjQ1MTU3LCAwLjAyMDcyOTAyMDAyNzY3Nl0sXFxuICAgIFswLjAyNDY3MDE0ODM0NDE0NywgMC4wMjA4MDk4NjQxODM3MDldLFxcbiAgICBbMC4wMjQ2MDE5MTYyNDU2NjksIDAuMDIwODkwNDg1NDgyODE2XSxcXG4gICAgWzAuMDI0NTMzNDIwNjgwNDMzLCAwLjAyMDk3MDg4MzA2MTYwN10sXFxuICAgIFswLjAyNDQ2NDY2MjM4MTk3MSwgMC4wMjEwNTEwNTYwNTkwODddLFxcbiAgICBbMC4wMjQzOTU2NDIwODY2MzAsIDAuMDIxMTMxMDAzNjE2NjcwXSxcXG4gICAgWzAuMDI0MzI2MzYwNTMzNTYxLCAwLjAyMTIxMDcyNDg3ODE4MV0sXFxuICAgIFswLjAyNDI1NjgxODQ2NDcxNSwgMC4wMjEyOTAyMTg5ODk4NjhdLFxcbiAgICBbMC4wMjQxODcwMTY2MjQ4MzAsIDAuMDIxMzY5NDg1MTAwNDE1XSxcXG4gICAgWzAuMDI0MTE2OTU1NzYxNDMwLCAwLjAyMTQ0ODUyMjM2MDk0NF0sXFxuICAgIFswLjAyNDA0NjYzNjYyNDgwOCwgMC4wMjE1MjczMjk5MjUwMzBdLFxcbiAgICBbMC4wMjM5NzYwNTk5NjgwMjcsIDAuMDIxNjA1OTA2OTQ4NzA4XSxcXG4gICAgWzAuMDIzOTA1MjI2NTQ2OTA2LCAwLjAyMTY4NDI1MjU5MDQ4MF0sXFxuICAgIFswLjAyMzgzNDEzNzEyMDAxNCwgMC4wMjE3NjIzNjYwMTEzMjhdLFxcbiAgICBbMC4wMjM3NjI3OTI0NDg2NjIsIDAuMDIxODQwMjQ2Mzc0NzIwXSxcXG4gICAgWzAuMDIzNjkxMTkzMjk2ODkzLCAwLjAyMTkxNzg5Mjg0NjYyMF0sXFxuICAgIFswLjAyMzYxOTM0MDQzMTQ3OCwgMC4wMjE5OTUzMDQ1OTU0OTVdLFxcbiAgICBbMC4wMjM1NDcyMzQ2MjE5MDIsIDAuMDIyMDcyNDgwNzkyMzMwXSxcXG4gICAgWzAuMDIzNDc0ODc2NjQwMzYxLCAwLjAyMjE0OTQyMDYxMDYyOF0sXFxuICAgIFswLjAyMzQwMjI2NzI2MTc1MSwgMC4wMjIyMjYxMjMyMjY0MjZdLFxcbiAgICBbMC4wMjMzMjk0MDcyNjM2NTksIDAuMDIyMzAyNTg3ODE4MzAwXSxcXG4gICAgWzAuMDIzMjU2Mjk3NDI2MzU5LCAwLjAyMjM3ODgxMzU2NzM3N10sXFxuICAgIFswLjAyMzE4MjkzODUzMjc5NywgMC4wMjI0NTQ3OTk2NTczMzldLFxcbiAgICBbMC4wMjMxMDkzMzEzNjg1ODgsIDAuMDIyNTMwNTQ1Mjc0NDM3XSxcXG4gICAgWzAuMDIzMDM1NDc2NzIyMDA2LCAwLjAyMjYwNjA0OTYwNzQ5Nl0sXFxuICAgIFswLjAyMjk2MTM3NTM4Mzk3NSwgMC4wMjI2ODEzMTE4NDc5MjZdLFxcbiAgICBbMC4wMjI4ODcwMjgxNDgwNjEsIDAuMDIyNzU2MzMxMTg5NzI3XSxcXG4gICAgWzAuMDIyODEyNDM1ODEwNDYyLCAwLjAyMjgzMTEwNjgyOTUwNF0sXFxuICAgIFswLjAyMjczNzU5OTE3MDAwMywgMC4wMjI5MDU2Mzc5NjY0NjldLFxcbiAgICBbMC4wMjI2NjI1MTkwMjgxMjUsIDAuMDIyOTc5OTIzODAyNDUzXSxcXG4gICAgWzAuMDIyNTg3MTk2MTg4ODc0LCAwLjAyMzA1Mzk2MzU0MTkxNV0sXFxuICAgIFswLjAyMjUxMTYzMTQ1ODg5OSwgMC4wMjMxMjc3NTYzOTE5NTBdLFxcbiAgICBbMC4wMjI0MzU4MjU2NDc0MzcsIDAuMDIzMjAxMzAxNTYyMjk0XSxcXG4gICAgWzAuMDIyMzU5Nzc5NTY2MzA2LCAwLjAyMzI3NDU5ODI2NTMzOF0sXFxuICAgIFswLjAyMjI4MzQ5NDAyOTkwMCwgMC4wMjMzNDc2NDU3MTYxMzNdLFxcbiAgICBbMC4wMjIyMDY5Njk4NTUxNzYsIDAuMDIzNDIwNDQzMTMyNDAwXSxcXG4gICAgWzAuMDIyMTMwMjA3ODYxNjQ1LCAwLjAyMzQ5Mjk4OTczNDUzN10sXFxuICAgIFswLjAyMjA1MzIwODg3MTM2NywgMC4wMjM1NjUyODQ3NDU2MjhdLFxcbiAgICBbMC4wMjE5NzU5NzM3MDg5NDAsIDAuMDIzNjM3MzI3MzkxNDUxXSxcXG4gICAgWzAuMDIxODk4NTAzMjAxNDg5LCAwLjAyMzcwOTExNjkwMDQ4OF0sXFxuICAgIFswLjAyMTgyMDc5ODE3ODY2MywgMC4wMjM3ODA2NTI1MDM5MzFdLFxcbiAgICBbMC4wMjE3NDI4NTk0NzI2MTgsIDAuMDIzODUxOTMzNDM1NjkxXSxcXG4gICAgWzAuMDIxNjY0Njg3OTE4MDE3LCAwLjAyMzkyMjk1ODkzMjQwNl0sXFxuICAgIFswLjAyMTU4NjI4NDM1MjAxMywgMC4wMjM5OTM3MjgyMzM0NTFdLFxcbiAgICBbMC4wMjE1MDc2NDk2MTQyNDcsIDAuMDI0MDY0MjQwNTgwOTQyXSxcXG4gICAgWzAuMDIxNDI4Nzg0NTQ2ODMyLCAwLjAyNDEzNDQ5NTIxOTc1MF0sXFxuICAgIFswLjAyMTM0OTY4OTk5NDM1MCwgMC4wMjQyMDQ0OTEzOTc1MDRdLFxcbiAgICBbMC4wMjEyNzAzNjY4MDM4NDAsIDAuMDI0Mjc0MjI4MzY0NjAwXSxcXG4gICAgWzAuMDIxMTkwODE1ODI0NzkxLCAwLjAyNDM0MzcwNTM3NDIxM10sXFxuICAgIFswLjAyMTExMTAzNzkwOTEyOCwgMC4wMjQ0MTI5MjE2ODIyOThdLFxcbiAgICBbMC4wMjEwMzEwMzM5MTEyMTAsIDAuMDI0NDgxODc2NTQ3NjA1XSxcXG4gICAgWzAuMDIwOTUwODA0Njg3ODE1LCAwLjAyNDU1MDU2OTIzMTY4M10sXFxuICAgIFswLjAyMDg3MDM1MTA5ODEzNCwgMC4wMjQ2MTg5OTg5OTg4ODldLFxcbiAgICBbMC4wMjA3ODk2NzQwMDM3NTksIDAuMDI0Njg3MTY1MTE2Mzk0XSxcXG4gICAgWzAuMDIwNzA4Nzc0MjY4Njc4LCAwLjAyNDc1NTA2Njg1NDE5NF0sXFxuICAgIFswLjAyMDYyNzY1Mjc1OTI2MiwgMC4wMjQ4MjI3MDM0ODUxMTZdLFxcbiAgICBbMC4wMjA1NDYzMTAzNDQyNTcsIDAuMDI0ODkwMDc0Mjg0ODI2XSxcXG4gICAgWzAuMDIwNDY0NzQ3ODk0Nzc1LCAwLjAyNDk1NzE3ODUzMTgzN10sXFxuICAgIFswLjAyMDM4Mjk2NjI4NDI4NCwgMC4wMjUwMjQwMTU1MDc1MTZdLFxcbiAgICBbMC4wMjAzMDA5NjYzODg2MDAsIDAuMDI1MDkwNTg0NDk2MDkzXSxcXG4gICAgWzAuMDIwMjE4NzQ5MDg1ODc2LCAwLjAyNTE1Njg4NDc4NDY2OF0sXFxuICAgIFswLjAyMDEzNjMxNTI1NjU5MiwgMC4wMjUyMjI5MTU2NjMyMThdLFxcbiAgICBbMC4wMjAwNTM2NjU3ODM1NDksIDAuMDI1Mjg4Njc2NDI0NjA1XSxcXG4gICAgWzAuMDE5OTcwODAxNTUxODU3LCAwLjAyNTM1NDE2NjM2NDU4NF0sXFxuICAgIFswLjAxOTg4NzcyMzQ0ODkyNSwgMC4wMjU0MTkzODQ3ODE4MTFdLFxcbiAgICBbMC4wMTk4MDQ0MzIzNjQ0NTIsIDAuMDI1NDg0MzMwOTc3ODQ4XSxcXG4gICAgWzAuMDE5NzIwOTI5MTkwNDE5LCAwLjAyNTU0OTAwNDI1NzE3NV0sXFxuICAgIFswLjAxOTYzNzIxNDgyMTA3OCwgMC4wMjU2MTM0MDM5MjcxOTJdLFxcbiAgICBbMC4wMTk1NTMyOTAxNTI5NDMsIDAuMDI1Njc3NTI5Mjk4MjMwXSxcXG4gICAgWzAuMDE5NDY5MTU2MDg0Nzc5LCAwLjAyNTc0MTM3OTY4MzU1OV0sXFxuICAgIFswLjAxOTM4NDgxMzUxNzU5NSwgMC4wMjU4MDQ5NTQzOTkzOTJdLFxcbiAgICBbMC4wMTkzMDAyNjMzNTQ2MzIsIDAuMDI1ODY4MjUyNzY0ODk1XSxcXG4gICAgWzAuMDE5MjE1NTA2NTAxMzU0LCAwLjAyNTkzMTI3NDEwMjE5M10sXFxuICAgIFswLjAxOTEzMDU0Mzg2NTQzOSwgMC4wMjU5OTQwMTc3MzYzNzldLFxcbiAgICBbMC4wMTkwNDUzNzYzNTY3NjksIDAuMDI2MDU2NDgyOTk1NTE4XSxcXG4gICAgWzAuMDE4OTYwMDA0ODg3NDE5LCAwLjAyNjExODY2OTIxMDY1N10sXFxuICAgIFswLjAxODg3NDQzMDM3MTY0OCwgMC4wMjYxODA1NzU3MTU4MzNdLFxcbiAgICBbMC4wMTg3ODg2NTM3MjU4OTIsIDAuMDI2MjQyMjAxODQ4MDc2XSxcXG4gICAgWzAuMDE4NzAyNjc1ODY4NzUwLCAwLjAyNjMwMzU0Njk0NzQyMV0sXFxuICAgIFswLjAxODYxNjQ5NzcyMDk3NCwgMC4wMjYzNjQ2MTAzNTY5MDldLFxcbiAgICBbMC4wMTg1MzAxMjAyMDU0NjQsIDAuMDI2NDI1MzkxNDIyNjAyXSxcXG4gICAgWzAuMDE4NDQzNTQ0MjQ3MjU0LCAwLjAyNjQ4NTg4OTQ5MzU4M10sXFxuICAgIFswLjAxODM1Njc3MDc3MzUwMiwgMC4wMjY1NDYxMDM5MjE5NjVdLFxcbiAgICBbMC4wMTgyNjk4MDA3MTM0ODMsIDAuMDI2NjA2MDM0MDYyOTAyXSxcXG4gICAgWzAuMDE4MTgyNjM0OTk4NTc2LCAwLjAyNjY2NTY3OTI3NDU4OV0sXFxuICAgIFswLjAxODA5NTI3NDU2MjI1NiwgMC4wMjY3MjUwMzg5MTgyNzRdLFxcbiAgICBbMC4wMTgwMDc3MjAzNDAwODMsIDAuMDI2Nzg0MTEyMzU4MjYzXSxcXG4gICAgWzAuMDE3OTE5OTczMjY5NjkyLCAwLjAyNjg0Mjg5ODk2MTkyNl0sXFxuICAgIFswLjAxNzgzMjAzNDI5MDc4NSwgMC4wMjY5MDEzOTgwOTk3MDddLFxcbiAgICBbMC4wMTc3NDM5MDQzNDUxMTYsIDAuMDI2OTU5NjA5MTQ1MTI3XSxcXG4gICAgWzAuMDE3NjU1NTg0Mzc2NDg4LCAwLjAyNzAxNzUzMTQ3NDc5Ml0sXFxuICAgIFswLjAxNzU2NzA3NTMzMDczNCwgMC4wMjcwNzUxNjQ0Njg0MDFdLFxcbiAgICBbMC4wMTc0NzgzNzgxNTU3MTgsIDAuMDI3MTMyNTA3NTA4NzUwXSxcXG4gICAgWzAuMDE3Mzg5NDkzODAxMzEzLCAwLjAyNzE4OTU1OTk4MTc0Ml0sXFxuICAgIFswLjAxNzMwMDQyMzIxOTQwMSwgMC4wMjcyNDYzMjEyNzYzOTFdLFxcbiAgICBbMC4wMTcyMTExNjczNjM4NTQsIDAuMDI3MzAyNzkwNzg0ODI4XSxcXG4gICAgWzAuMDE3MTIxNzI3MTkwNTMzLCAwLjAyNzM1ODk2NzkwMjMxMF0sXFxuICAgIFswLjAxNzAzMjEwMzY1NzI2OSwgMC4wMjc0MTQ4NTIwMjcyMjZdLFxcbiAgICBbMC4wMTY5NDIyOTc3MjM4NTgsIDAuMDI3NDcwNDQyNTYxMTAyXSxcXG4gICAgWzAuMDE2ODUyMzEwMzUyMDUwLCAwLjAyNzUyNTczODkwODYwOF0sXFxuICAgIFswLjAxNjc2MjE0MjUwNTUzNywgMC4wMjc1ODA3NDA0Nzc1NjRdLFxcbiAgICBbMC4wMTY2NzE3OTUxNDk5NDQsIDAuMDI3NjM1NDQ2Njc4OTQ4XSxcXG4gICAgWzAuMDE2NTgxMjY5MjUyODE5LCAwLjAyNzY4OTg1NjkyNjkwMF0sXFxuICAgIFswLjAxNjQ5MDU2NTc4MzYyMiwgMC4wMjc3NDM5NzA2Mzg3MzBdLFxcbiAgICBbMC4wMTYzOTk2ODU3MTM3MTQsIDAuMDI3Nzk3Nzg3MjM0OTI0XSxcXG4gICAgWzAuMDE2MzA4NjMwMDE2MzQ3LCAwLjAyNzg1MTMwNjEzOTE0OV0sXFxuICAgIFswLjAxNjIxNzM5OTY2NjY1NSwgMC4wMjc5MDQ1MjY3NzgyNjBdLFxcbiAgICBbMC4wMTYxMjU5OTU2NDE2NDEsIDAuMDI3OTU3NDQ4NTgyMzA5XSxcXG4gICAgWzAuMDE2MDM0NDE4OTIwMTcwLCAwLjAyODAxMDA3MDk4NDU0NF0sXFxuICAgIFswLjAxNTk0MjY3MDQ4Mjk1NCwgMC4wMjgwNjIzOTM0MjE0MjFdLFxcbiAgICBbMC4wMTU4NTA3NTEzMTI1NDUsIDAuMDI4MTE0NDE1MzMyNjEwXSxcXG4gICAgWzAuMDE1NzU4NjYyMzkzMzI0LCAwLjAyODE2NjEzNjE2MDk5OF0sXFxuICAgIFswLjAxNTY2NjQwNDcxMTQ4OSwgMC4wMjgyMTc1NTUzNTI2OTddLFxcbiAgICBbMC4wMTU1NzM5NzkyNTUwNDYsIDAuMDI4MjY4NjcyMzU3MDQ3XSxcXG4gICAgWzAuMDE1NDgxMzg3MDEzNzk3LCAwLjAyODMxOTQ4NjYyNjYyN10sXFxuICAgIFswLjAxNTM4ODYyODk3OTMzMSwgMC4wMjgzNjk5OTc2MTcyNTddLFxcbiAgICBbMC4wMTUyOTU3MDYxNDUwMTIsIDAuMDI4NDIwMjA0Nzg4MDA0XSxcXG4gICAgWzAuMDE1MjAyNjE5NTA1OTY4LCAwLjAyODQ3MDEwNzYwMTE5MV0sXFxuICAgIFswLjAxNTEwOTM3MDA1OTA4NCwgMC4wMjg1MTk3MDU1MjIzOTldLFxcbiAgICBbMC4wMTUwMTU5NTg4MDI5ODQsIDAuMDI4NTY4OTk4MDIwNDcyXSxcXG4gICAgWzAuMDE0OTIyMzg2NzM4MDMwLCAwLjAyODYxNzk4NDU2NzUyOV0sXFxuICAgIFswLjAxNDgyODY1NDg2NjMwMiwgMC4wMjg2NjY2NjQ2Mzg5NjNdLFxcbiAgICBbMC4wMTQ3MzQ3NjQxOTE1OTMsIDAuMDI4NzE1MDM3NzEzNDQ5XSxcXG4gICAgWzAuMDE0NjQwNzE1NzE5Mzk4LCAwLjAyODc2MzEwMzI3Mjk1MV0sXFxuICAgIFswLjAxNDU0NjUxMDQ1NjkwMCwgMC4wMjg4MTA4NjA4MDI3MjRdLFxcbiAgICBbMC4wMTQ0NTIxNDk0MTI5NjIsIDAuMDI4ODU4MzA5NzkxMzI1XSxcXG4gICAgWzAuMDE0MzU3NjMzNTk4MTE0LCAwLjAyODkwNTQ0OTczMDYxM10sXFxuICAgIFswLjAxNDI2Mjk2NDAyNDU0NSwgMC4wMjg5NTIyODAxMTU3NTZdLFxcbiAgICBbMC4wMTQxNjgxNDE3MDYwOTAsIDAuMDI4OTk4ODAwNDQ1MjQwXSxcXG4gICAgWzAuMDE0MDczMTY3NjU4MjIwLCAwLjAyOTA0NTAxMDIyMDg2OF0sXFxuICAgIFswLjAxMzk3ODA0Mjg5ODAzMCwgMC4wMjkwOTA5MDg5NDc3NzFdLFxcbiAgICBbMC4wMTM4ODI3Njg0NDQyMzEsIDAuMDI5MTM2NDk2MTM0NDExXSxcXG4gICAgWzAuMDEzNzg3MzQ1MzE3MTM2LCAwLjAyOTE4MTc3MTI5MjU4NV0sXFxuICAgIFswLjAxMzY5MTc3NDUzODY0OCwgMC4wMjkyMjY3MzM5Mzc0MzNdLFxcbiAgICBbMC4wMTM1OTYwNTcxMzIyNTUsIDAuMDI5MjcxMzgzNTg3NDQxXSxcXG4gICAgWzAuMDEzNTAwMTk0MTIzMDE0LCAwLjAyOTMxNTcxOTc2NDQ0N10sXFxuICAgIFswLjAxMzQwNDE4NjUzNzUzOSwgMC4wMjkzNTk3NDE5OTM2NDddLFxcbiAgICBbMC4wMTMzMDgwMzU0MDM5OTUsIDAuMDI5NDAzNDQ5ODAzNTk4XSxcXG4gICAgWzAuMDEzMjExNzQxNzUyMDg0LCAwLjAyOTQ0Njg0MjcyNjIyM10sXFxuICAgIFswLjAxMzExNTMwNjYxMzAzMiwgMC4wMjk0ODk5MjAyOTY4MjBdLFxcbiAgICBbMC4wMTMwMTg3MzEwMTk1ODQsIDAuMDI5NTMyNjgyMDU0MDYzXSxcXG4gICAgWzAuMDEyOTIyMDE2MDA1OTg1LCAwLjAyOTU3NTEyNzU0MDAwOF0sXFxuICAgIFswLjAxMjgyNTE2MjYwNzk3NywgMC4wMjk2MTcyNTYzMDAwOTddLFxcbiAgICBbMC4wMTI3MjgxNzE4NjI3ODEsIDAuMDI5NjU5MDY3ODgzMTY1XSxcXG4gICAgWzAuMDEyNjMxMDQ0ODA5MDg5LCAwLjAyOTcwMDU2MTg0MTQ0NF0sXFxuICAgIFswLjAxMjUzMzc4MjQ4NzA1NiwgMC4wMjk3NDE3Mzc3MzA1NjddLFxcbiAgICBbMC4wMTI0MzYzODU5MzgyODEsIDAuMDI5NzgyNTk1MTA5NTczXSxcXG4gICAgWzAuMDEyMzM4ODU2MjA1ODA1LCAwLjAyOTgyMzEzMzU0MDkxM10sXFxuICAgIFswLjAxMjI0MTE5NDMzNDA5MSwgMC4wMjk4NjMzNTI1OTA0NTJdLFxcbiAgICBbMC4wMTIxNDM0MDEzNjkwMjEsIDAuMDI5OTAzMjUxODI3NDc3XSxcXG4gICAgWzAuMDEyMDQ1NDc4MzU3ODc4LCAwLjAyOTk0MjgzMDgyNDY5OV0sXFxuICAgIFswLjAxMTk0NzQyNjM0OTMzOSwgMC4wMjk5ODIwODkxNTgyNTldLFxcbiAgICBbMC4wMTE4NDkyNDYzOTM0NjIsIDAuMDMwMDIxMDI2NDA3NzMxXSxcXG4gICAgWzAuMDExNzUwOTM5NTQxNjc2LCAwLjAzMDA1OTY0MjE1NjEyOV0sXFxuICAgIFswLjAxMTY1MjUwNjg0Njc2OCwgMC4wMzAwOTc5MzU5ODk5MDldLFxcbiAgICBbMC4wMTE1NTM5NDkzNjI4NzQsIDAuMDMwMTM1OTA3NDk4OTc2XSxcXG4gICAgWzAuMDExNDU1MjY4MTQ1NDY0LCAwLjAzMDE3MzU1NjI3NjY4NF0sXFxuICAgIFswLjAxMTM1NjQ2NDI1MTMzNSwgMC4wMzAyMTA4ODE5MTk4NDVdLFxcbiAgICBbMC4wMTEyNTc1Mzg3Mzg1OTgsIDAuMDMwMjQ3ODg0MDI4NzMyXSxcXG4gICAgWzAuMDExMTU4NDkyNjY2NjY1LCAwLjAzMDI4NDU2MjIwNzA4M10sXFxuICAgIFswLjAxMTA1OTMyNzA5NjI0MCwgMC4wMzAzMjA5MTYwNjIxMDJdLFxcbiAgICBbMC4wMTA5NjAwNDMwODkzMDcsIDAuMDMwMzU2OTQ1MjA0NDcwXSxcXG4gICAgWzAuMDEwODYwNjQxNzA5MTE4LCAwLjAzMDM5MjY0OTI0ODM0M10sXFxuICAgIFswLjAxMDc2MTEyNDAyMDE4MiwgMC4wMzA0MjgwMjc4MTEzNjFdLFxcbiAgICBbMC4wMTA2NjE0OTEwODgyNTMsIDAuMDMwNDYzMDgwNTE0NjQ2XSxcXG4gICAgWzAuMDEwNTYxNzQzOTgwMzE5LCAwLjAzMDQ5NzgwNjk4MjgxMl0sXFxuICAgIFswLjAxMDQ2MTg4Mzc2NDU5MywgMC4wMzA1MzIyMDY4NDM5NjhdLFxcbiAgICBbMC4wMTAzNjE5MTE1MTA0OTYsIDAuMDMwNTY2Mjc5NzI5NzE3XSxcXG4gICAgWzAuMDEwMjYxODI4Mjg4NjUyLCAwLjAzMDYwMDAyNTI3NTE2N10sXFxuICAgIFswLjAxMDE2MTYzNTE3MDg3MiwgMC4wMzA2MzM0NDMxMTg5MzFdLFxcbiAgICBbMC4wMTAwNjEzMzMyMzAxNDIsIDAuMDMwNjY2NTMyOTAzMTI5XSxcXG4gICAgWzAuMDA5OTYwOTIzNTQwNjE3LCAwLjAzMDY5OTI5NDI3MzM5N10sXFxuICAgIFswLjAwOTg2MDQwNzE3NzYwMywgMC4wMzA3MzE3MjY4Nzg4ODhdLFxcbiAgICBbMC4wMDk3NTk3ODUyMTc1NTAsIDAuMDMwNzYzODMwMzcyMjczXSxcXG4gICAgWzAuMDA5NjU5MDU4NzM4MDM4LCAwLjAzMDc5NTYwNDQwOTc1MF0sXFxuICAgIFswLjAwOTU1ODIyODgxNzc2NywgMC4wMzA4MjcwNDg2NTEwNDVdLFxcbiAgICBbMC4wMDk0NTcyOTY1MzY1NDUsIDAuMDMwODU4MTYyNzU5NDE1XSxcXG4gICAgWzAuMDA5MzU2MjYyOTc1Mjc1LCAwLjAzMDg4ODk0NjQwMTY1M10sXFxuICAgIFswLjAwOTI1NTEyOTIxNTk0NSwgMC4wMzA5MTkzOTkyNDgwOTFdLFxcbiAgICBbMC4wMDkxNTM4OTYzNDE2MTYsIDAuMDMwOTQ5NTIwOTcyNjAzXSxcXG4gICAgWzAuMDA5MDUyNTY1NDM2NDEyLCAwLjAzMDk3OTMxMTI1MjYxMV0sXFxuICAgIFswLjAwODk1MTEzNzU4NTUwNSwgMC4wMzEwMDg3Njk3NjkwODRdLFxcbiAgICBbMC4wMDg4NDk2MTM4NzUxMDUsIDAuMDMxMDM3ODk2MjA2NTQ0XSxcXG4gICAgWzAuMDA4NzQ3OTk1MzkyNDUxLCAwLjAzMTA2NjY5MDI1MzA3Ml0sXFxuICAgIFswLjAwODY0NjI4MzIyNTc5NCwgMC4wMzEwOTUxNTE2MDAzMDZdLFxcbiAgICBbMC4wMDg1NDQ0Nzg0NjQzOTAsIDAuMDMxMTIzMjc5OTQzNDQ4XSxcXG4gICAgWzAuMDA4NDQyNTgyMTk4NDg2LCAwLjAzMTE1MTA3NDk4MTI2Nl0sXFxuICAgIFswLjAwODM0MDU5NTUxOTMxMCwgMC4wMzExNzg1MzY0MTYwOThdLFxcbiAgICBbMC4wMDgyMzg1MTk1MTkwNTcsIDAuMDMxMjA1NjYzOTUzODUzXSxcXG4gICAgWzAuMDA4MTM2MzU1MjkwODc4LCAwLjAzMTIzMjQ1NzMwNDAxN10sXFxuICAgIFswLjAwODAzNDEwMzkyODg3MSwgMC4wMzEyNTg5MTYxNzk2NTZdLFxcbiAgICBbMC4wMDc5MzE3NjY1MjgwNjUsIDAuMDMxMjg1MDQwMjk3NDE2XSxcXG4gICAgWzAuMDA3ODI5MzQ0MTg0NDEyLCAwLjAzMTMxMDgyOTM3NzUyOF0sXFxuICAgIFswLjAwNzcyNjgzNzk5NDc3MiwgMC4wMzEzMzYyODMxNDM4MTNdLFxcbiAgICBbMC4wMDc2MjQyNDkwNTY5MDYsIDAuMDMxMzYxNDAxMzIzNjgwXSxcXG4gICAgWzAuMDA3NTIxNTc4NDY5NDU3LCAwLjAzMTM4NjE4MzY0ODEzNV0sXFxuICAgIFswLjAwNzQxODgyNzMzMTk0NiwgMC4wMzE0MTA2Mjk4NTE3NzhdLFxcbiAgICBbMC4wMDczMTU5OTY3NDQ3NTUsIDAuMDMxNDM0NzM5NjcyODExXSxcXG4gICAgWzAuMDA3MjEzMDg3ODA5MTE1LCAwLjAzMTQ1ODUxMjg1MzAzNl0sXFxuICAgIFswLjAwNzExMDEwMTYyNzEwMSwgMC4wMzE0ODE5NDkxMzc4NjNdLFxcbiAgICBbMC4wMDcwMDcwMzkzMDE2MTAsIDAuMDMxNTA1MDQ4Mjc2MzA2XSxcXG4gICAgWzAuMDA2OTAzOTAxOTM2MzU3LCAwLjAzMTUyNzgxMDAyMDk5M10sXFxuICAgIFswLjAwNjgwMDY5MDYzNTg2MiwgMC4wMzE1NTAyMzQxMjgxNjRdLFxcbiAgICBbMC4wMDY2OTc0MDY1MDU0MzMsIDAuMDMxNTcyMzIwMzU3Njc1XSxcXG4gICAgWzAuMDA2NTk0MDUwNjUxMTYxLCAwLjAzMTU5NDA2ODQ3MzAwMF0sXFxuICAgIFswLjAwNjQ5MDYyNDE3OTkwNSwgMC4wMzE2MTU0NzgyNDEyMzNdLFxcbiAgICBbMC4wMDYzODcxMjgxOTkyNzgsIDAuMDMxNjM2NTQ5NDMzMDk1XSxcXG4gICAgWzAuMDA2MjgzNTYzODE3NjM5LCAwLjAzMTY1NzI4MTgyMjkyOV0sXFxuICAgIFswLjAwNjE3OTkzMjE0NDA4MCwgMC4wMzE2Nzc2NzUxODg3MDddLFxcbiAgICBbMC4wMDYwNzYyMzQyODg0MTIsIDAuMDMxNjk3NzI5MzEyMDM0XSxcXG4gICAgWzAuMDA1OTcyNDcxMzYxMTU3LCAwLjAzMTcxNzQ0Mzk3ODE0Nl0sXFxuICAgIFswLjAwNTg2ODY0NDQ3MzUzMiwgMC4wMzE3MzY4MTg5NzU5MTRdLFxcbiAgICBbMC4wMDU3NjQ3NTQ3Mzc0NDAsIDAuMDMxNzU1ODU0MDk3ODQ4XSxcXG4gICAgWzAuMDA1NjYwODAzMjY1NDU2LCAwLjAzMTc3NDU0OTE0MDA5OF0sXFxuICAgIFswLjAwNTU1Njc5MTE3MDgxNiwgMC4wMzE3OTI5MDM5MDI0NTNdLFxcbiAgICBbMC4wMDU0NTI3MTk1Njc0MDcsIDAuMDMxODEwOTE4MTg4MzUwXSxcXG4gICAgWzAuMDA1MzQ4NTg5NTY5NzUzLCAwLjAzMTgyODU5MTgwNDg2OV0sXFxuICAgIFswLjAwNTI0NDQwMjI5MzAwMSwgMC4wMzE4NDU5MjQ1NjI3NDJdLFxcbiAgICBbMC4wMDUxNDAxNTg4NTI5MTQsIDAuMDMxODYyOTE2Mjc2MzQ3XSxcXG4gICAgWzAuMDA1MDM1ODYwMzY1ODU1LCAwLjAzMTg3OTU2Njc2MzcxN10sXFxuICAgIFswLjAwNDkzMTUwNzk0ODc3OCwgMC4wMzE4OTU4NzU4NDY1MzldLFxcbiAgICBbMC4wMDQ4MjcxMDI3MTkyMTIsIDAuMDMxOTExODQzMzUwMTU1XSxcXG4gICAgWzAuMDA0NzIyNjQ1Nzk1MjU0LCAwLjAzMTkyNzQ2OTEwMzU2N10sXFxuICAgIFswLjAwNDYxODEzODI5NTU1NCwgMC4wMzE5NDI3NTI5Mzk0MzVdLFxcbiAgICBbMC4wMDQ1MTM1ODEzMzkzMDMsIDAuMDMxOTU3Njk0Njk0MDgyXSxcXG4gICAgWzAuMDA0NDA4OTc2MDQ2MjIyLCAwLjAzMTk3MjI5NDIwNzQ5M10sXFxuICAgIFswLjAwNDMwNDMyMzUzNjU0OSwgMC4wMzE5ODY1NTEzMjMzMjBdLFxcbiAgICBbMC4wMDQxOTk2MjQ5MzEwMzAsIDAuMDMyMDAwNDY1ODg4ODc5XSxcXG4gICAgWzAuMDA0MDk0ODgxMzUwOTAyLCAwLjAzMjAxNDAzNzc1NTE1OF0sXFxuICAgIFswLjAwMzk5MDA5MzkxNzg4NCwgMC4wMzIwMjcyNjY3NzY4MTNdLFxcbiAgICBbMC4wMDM4ODUyNjM3NTQxNjYsIDAuMDMyMDQwMTUyODEyMTcwXSxcXG4gICAgWzAuMDAzNzgwMzkxOTgyMzk0LCAwLjAzMjA1MjY5NTcyMzIzMl0sXFxuICAgIFswLjAwMzY3NTQ3OTcyNTY2MSwgMC4wMzIwNjQ4OTUzNzU2NzRdLFxcbiAgICBbMC4wMDM1NzA1MjgxMDc0OTQsIDAuMDMyMDc2NzUxNjM4ODQ3XSxcXG4gICAgWzAuMDAzNDY1NTM4MjUxODM5LCAwLjAzMjA4ODI2NDM4NTc4MF0sXFxuICAgIFswLjAwMzM2MDUxMTI4MzA1MywgMC4wMzIwOTk0MzM0OTMxODFdLFxcbiAgICBbMC4wMDMyNTU0NDgzMjU4OTIsIDAuMDMyMTEwMjU4ODQxNDM4XSxcXG4gICAgWzAuMDAzMTUwMzUwNTA1NDk0LCAwLjAzMjEyMDc0MDMxNDYxOV0sXFxuICAgIFswLjAwMzA0NTIxODk0NzM3MywgMC4wMzIxMzA4Nzc4MDA0NzhdLFxcbiAgICBbMC4wMDI5NDAwNTQ3Nzc0MDQsIDAuMDMyMTQwNjcxMTkwNDQ5XSxcXG4gICAgWzAuMDAyODM0ODU5MTIxODEwLCAwLjAzMjE1MDEyMDM3OTY1M10sXFxuICAgIFswLjAwMjcyOTYzMzEwNzE1MywgMC4wMzIxNTkyMjUyNjY4OTddLFxcbiAgICBbMC4wMDI2MjQzNzc4NjAzMTgsIDAuMDMyMTY3OTg1NzU0Njc0XSxcXG4gICAgWzAuMDAyNTE5MDk0NTA4NTA0LCAwLjAzMjE3NjQwMTc0OTE2OF0sXFxuICAgIFswLjAwMjQxMzc4NDE3OTIxMiwgMC4wMzIxODQ0NzMxNjAyNTBdLFxcbiAgICBbMC4wMDIzMDg0NDgwMDAyMzEsIDAuMDMyMTkyMTk5OTAxNDgxXSxcXG4gICAgWzAuMDAyMjAzMDg3MDk5NjI2LCAwLjAzMjE5OTU4MTg5MDExNF0sXFxuICAgIFswLjAwMjA5NzcwMjYwNTcyOCwgMC4wMzIyMDY2MTkwNDcwOTNdLFxcbiAgICBbMC4wMDE5OTIyOTU2NDcxMjEsIDAuMDMyMjEzMzExMjk3MDU3XSxcXG4gICAgWzAuMDAxODg2ODY3MzUyNjI4LCAwLjAzMjIxOTY1ODU2ODMzOF0sXFxuICAgIFswLjAwMTc4MTQxODg1MTMwMiwgMC4wMzIyMjU2NjA3OTI5NjBdLFxcbiAgICBbMC4wMDE2NzU5NTEyNzI0MTAsIDAuMDMyMjMxMzE3OTA2NjQ0XSxcXG4gICAgWzAuMDAxNTcwNDY1NzQ1NDI4LCAwLjAzMjIzNjYyOTg0ODgwOV0sXFxuICAgIFswLjAwMTQ2NDk2MzQwMDAxOCwgMC4wMzIyNDE1OTY1NjI1NjZdLFxcbiAgICBbMC4wMDEzNTk0NDUzNjYwMjgsIDAuMDMyMjQ2MjE3OTk0NzI3XSxcXG4gICAgWzAuMDAxMjUzOTEyNzczNDcwLCAwLjAzMjI1MDQ5NDA5NTc5OV0sXFxuICAgIFswLjAwMTE0ODM2Njc1MjUxMywgMC4wMzIyNTQ0MjQ4MTk5OTBdLFxcbiAgICBbMC4wMDEwNDI4MDg0MzM0NzEsIDAuMDMyMjU4MDEwMTI1MjA0XSxcXG4gICAgWzAuMDAwOTM3MjM4OTQ2Nzg5LCAwLjAzMjI2MTI0OTk3MzA0NV0sXFxuICAgIFswLjAwMDgzMTY1OTQyMzAzMCwgMC4wMzIyNjQxNDQzMjg4MTddLFxcbiAgICBbMC4wMDA3MjYwNzA5OTI4NjgsIDAuMDMyMjY2NjkzMTYxNTI1XSxcXG4gICAgWzAuMDAwNjIwNDc0Nzg3MDY4LCAwLjAzMjI2ODg5NjQ0Mzg3MV0sXFxuICAgIFswLjAwMDUxNDg3MTkzNjQ4MSwgMC4wMzIyNzA3NTQxNTIyNjFdLFxcbiAgICBbMC4wMDA0MDkyNjM1NzIwMzAsIDAuMDMyMjcyMjY2MjY2ODAxXSxcXG4gICAgWzAuMDAwMzAzNjUwODI0Njk1LCAwLjAzMjI3MzQzMjc3MTI5NV0sXFxuICAgIFswLjAwMDE5ODAzNDgyNTUwNCwgMC4wMzIyNzQyNTM2NTMyNTRdLFxcbiAgICBbMC4wMDAwOTI0MTY3MDU1MTgsIDAuMDMyMjc0NzI4OTAzODg0XVxcbl07XFxuXFxuY29uc3QgTURDVF9UQUJMRV8yNDAgPSBbICAgICAgICAgICAgICBcXG4gICAgWzAuMDkxMjg2NjA0MTExODE1LCAwLjAwMDI5ODczNTc3OTc5M10sXFxuICAgIFswLjA5MTI0NzUwMjQ4MTQ1NCwgMC4wMDI2ODgyMzgxMjc1MzhdLFxcbiAgICBbMC4wOTExNDU4NjQzNzA4MDcsIDAuMDA1MDc1ODk4MDkxMTUyXSxcXG4gICAgWzAuMDkwOTgxNzU5NDM3NTU4LCAwLjAwNzQ2MDA3OTI4Nzc2MF0sXFxuICAgIFswLjA5MDc1NTMwMDE1MTAzMCwgMC4wMDk4MzkxNDc3MTg2NjRdLFxcbiAgICBbMC4wOTA0NjY2NDE3MTUxMDgsIDAuMDEyMjExNDcyODg5MTk4XSxcXG4gICAgWzAuMDkwMTE1OTgxOTYxODYzLCAwLjAxNDU3NTQyODkyNjE5MV0sXFxuICAgIFswLjA4OTcwMzU2MTIxNTk3NiwgMC4wMTY5MjkzOTU2OTIyNTZdLFxcbiAgICBbMC4wODkyMjk2NjIxMzAwMjQsIDAuMDE5MjcxNzU5ODk2MTU2XSxcXG4gICAgWzAuMDg4Njk0NjA5NDkwNzY5LCAwLjAyMTYwMDkxNjE5ODQ3MF0sXFxuICAgIFswLjA4ODA5ODc2OTk5NjU2NCwgMC4wMjM5MTUyNjgzMTE4MTBdLFxcbiAgICBbMC4wODc0NDI1NTIwMDYwMzUsIDAuMDI2MjEzMjMwMDk0ODQ0XSxcXG4gICAgWzAuMDg2NzI2NDA1MjU4MjE0LCAwLjAyODQ5MzIyNjYzOTM1MV0sXFxuICAgIFswLjA4NTk1MDgyMDU2NDMwOSwgMC4wMzA3NTM2OTUzNDk1ODhdLFxcbiAgICBbMC4wODUxMTYzMjk0NzEzMjksIDAuMDMyOTkzMDg3MDEzMjEzXSxcXG4gICAgWzAuMDg0MjIzNTAzODk3Nzg1LCAwLjAzNTIwOTg2Njg2MzA0Ml0sXFxuICAgIFswLjA4MzI3Mjk1NTc0MTcyNywgMC4wMzc0MDI1MTU2Mjg4OTRdLFxcbiAgICBbMC4wODIyNjUzMzY0NjEzODEsIDAuMDM5NTY5NTMwNTc4ODMyXSxcXG4gICAgWzAuMDgxMjAxMzM2NjI4NjcwLCAwLjA0MTcwOTQyNjU0OTA1M10sXFxuICAgIFswLjA4MDA4MTY4NTQ1NTkzMCwgMC4wNDM4MjA3MzY5NjE3NDldLFxcbiAgICBbMC4wNzg5MDcxNTAyOTYxNDgsIDAuMDQ1OTAyMDE0ODMwMjI3XSxcXG4gICAgWzAuMDc3Njc4NTM2MTE3MDU0LCAwLjA0Nzk1MTgzMzc1MDU5N10sXFxuICAgIFswLjA3NjM5NjY4NDk0OTQzNCwgMC4wNDk5Njg3ODg4NzkzNjJdLFxcbiAgICBbMC4wNzUwNjI0NzUzMTAwNTAsIDAuMDUxOTUxNDk3ODk2MjI2XSxcXG4gICAgWzAuMDczNjc2ODIxNTk5NTQyLCAwLjA1Mzg5ODYwMTk1MTQ2Nl0sXFxuICAgIFswLjA3MjI0MDY3MzQ3NTc0OSwgMC4wNTU4MDg3NjY1OTcyMjVdLFxcbiAgICBbMC4wNzA3NTUwMTUyMDI4NTgsIDAuMDU3NjgwNjgyNzAyMDY4XSxcXG4gICAgWzAuMDY5MjIwODY0OTc2ODQwLCAwLjA1OTUxMzA2NzM0ODIwMV0sXFxuICAgIFswLjA2NzYzOTI3NDIyNzYyNSwgMC4wNjEzMDQ2NjQ3MTA3MThdLFxcbiAgICBbMC4wNjYwMTEzMjY4OTg1MTIsIDAuMDYzMDU0MjQ2OTE4Mjc4XSxcXG4gICAgWzAuMDY0MzM4MTM4NzAzMjgyLCAwLjA2NDc2MDYxNDg5NDYzMF0sXFxuICAgIFswLjA2MjYyMDg1NjM2MTU0NiwgMC4wNjY0MjI1OTkxODAzOTldLFxcbiAgICBbMC4wNjA4NjA2NTY4MTI4NDIsIDAuMDY4MDM5MDYwNzM0NTcyXSxcXG4gICAgWzAuMDU5MDU4NzQ2NDEwMDE2LCAwLjA2OTYwODg5MTcxNTE0NV0sXFxuICAgIFswLjA1NzIxNjM2MDA5MjQ1MCwgMC4wNzExMzEwMTYyMzgzNzhdLFxcbiAgICBbMC4wNTUzMzQ3NjA1Mzk2OTksIDAuMDcyNjA0MzkxMTE2MTU0XSxcXG4gICAgWzAuMDUzNDE1MjM3MzA2MTA2LCAwLjA3NDAyODAwNjU3MDkzMF0sXFxuICAgIFswLjA1MTQ1OTEwNTkzNzAxNCwgMC4wNzU0MDA4ODY5Mjc3ODRdLFxcbiAgICBbMC4wNDk0Njc3MDcwNjcxNTMsIDAuMDc2NzIyMDkxMjgzMDk2XSxcXG4gICAgWzAuMDQ3NDQyNDA1NTAxODM1LCAwLjA3Nzk5MDcxNDE0OTM5Nl0sXFxuICAgIFswLjA0NTM4NDU4OTI4MTU4OCwgMC4wNzkyMDU4ODYwNzU5NDFdLFxcbiAgICBbMC4wNDMyOTU2Njg3MzA4NTcsIDAuMDgwMzY2Nzc0MjQ0NTkyXSxcXG4gICAgWzAuMDQxMTc3MDc1NDkxNDQ1LCAwLjA4MTQ3MjU4MzA0MDU4Nl0sXFxuICAgIFswLjAzOTAzMDI2MTU0MTMzMiwgMC4wODI1MjI1NTQ1OTc4MTBdLFxcbiAgICBbMC4wMzY4NTY2OTgxOTk1NjQsIDAuMDgzNTE1OTY5MzE4MjA2XSxcXG4gICAgWzAuMDM0NjU3ODc1MTE3ODgzLCAwLjA4NDQ1MjE0NjM2NDk0OF0sXFxuICAgIFswLjAzMjQzNTI5OTI1OTc5NiwgMC4wODUzMzA0NDQxMjkwNDldLFxcbiAgICBbMC4wMzAxOTA0OTM4Njc3NzUsIDAuMDg2MTUwMjYwNjY5MDk2XSxcXG4gICAgWzAuMDI3OTI0OTk3NDE5MzA2LCAwLjA4NjkxMTAzNDEyMzc4MV0sXFxuICAgIFswLjAyNTY0MDM2MjU3MjQ5MSwgMC4wODc2MTIyNDMwOTY5ODFdLFxcbiAgICBbMC4wMjMzMzgxNTUxMDE5MzMsIDAuMDg4MjUzNDA3MDE1MDkyXSxcXG4gICAgWzAuMDIxMDE5OTUyODI1NjM2LCAwLjA4ODgzNDA4NjQ1NjM5MF0sXFxuICAgIFswLjAxODY4NzM0NDUyMzY0MSwgMC4wODkzNTM4ODM0NTIxOTNdLFxcbiAgICBbMC4wMTYzNDE5Mjg4NDkxNjQsIDAuMDg5ODEyNDQxNzU5NjA0XSxcXG4gICAgWzAuMDEzOTg1MzEzMjMyOTUxLCAwLjA5MDIwOTQ0NzEwNTY2NF0sXFxuICAgIFswLjAxMTYxOTExMjc4MTYzMSwgMC4wOTA1NDQ2Mjc0MDI3NDBdLFxcbiAgICBbMC4wMDkyNDQ5NDkxNzA3OTcsIDAuMDkwODE3NzUyOTM1MDAwXSxcXG4gICAgWzAuMDA2ODY0NDQ5NTMzNTk3LCAwLjA5MTAyODYzNjUxNTg0Nl0sXFxuICAgIFswLjAwNDQ3OTI0NTM0NTU3NCwgMC4wOTExNzcxMzM2MTYyMDZdLFxcbiAgICBbMC4wMDIwOTA5NzEzMDY1MzQsIDAuMDkxMjYzMTQyNDYzNTg1XVxcbl07ICAgICAgICAgICAgICAgICAgICAvL2ltcG9ydCBcXFwibWRjdF90YWJsZXMuanNcXFwiXFxuLypcXG4gKiBBQUMuanMgLSBBZHZhbmNlZCBBdWRpbyBDb2RpbmcgZGVjb2RlciBpbiBKYXZhU2NyaXB0XFxuICogQ3JlYXRlZCBieSBEZXZvbiBHb3ZldHRcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIsIE9mZmljaWFsLmZtIExhYnNcXG4gKlxcbiAqIEFBQy5qcyBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IFxcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIFxcbiAqIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBcXG4gKiBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxcbiAqXFxuICogQUFDLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUIFxcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBcXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFxcbiAqIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXFxuICpcXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXFxuICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeS5cXG4gKiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXFxuICovXFxuXFxudmFyIEZGVCA9IChmdW5jdGlvbigpIHtcXG4gICAgXFxuICAgIGZ1bmN0aW9uIEZGVChsZW5ndGgpIHtcXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xcbiAgICBcXG4gICAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XFxuICAgICAgICAgICAgY2FzZSA2NDpcXG4gICAgICAgICAgICAgICAgdGhpcy5yb290cyA9IGdlbmVyYXRlRkZUVGFibGVTaG9ydCg2NCk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICBcXG4gICAgICAgICAgICBjYXNlIDUxMjpcXG4gICAgICAgICAgICAgICAgdGhpcy5yb290cyA9IGdlbmVyYXRlRkZUVGFibGVMb25nKDUxMik7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICBcXG4gICAgICAgICAgICBjYXNlIDYwOlxcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RzID0gZ2VuZXJhdGVGRlRUYWJsZVNob3J0KDYwKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgIFxcbiAgICAgICAgICAgIGNhc2UgNDgwOlxcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RzID0gZ2VuZXJhdGVGRlRUYWJsZUxvbmcoNDgwKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgIFxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwidW5leHBlY3RlZCBGRlQgbGVuZ3RoOiBcXFwiICsgbGVuZ3RoKTtcXG4gICAgICAgIH1cXG4gICAgXFxuICAgICAgICAvLyBwcm9jZXNzaW5nIGJ1ZmZlcnNcXG4gICAgICAgIHRoaXMucmV2ID0gbmV3IEFycmF5KGxlbmd0aCk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdGhpcy5yZXZbaV0gPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xcbiAgICAgICAgfVxcbiAgICBcXG4gICAgICAgIHRoaXMuYSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XFxuICAgICAgICB0aGlzLmIgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xcbiAgICAgICAgdGhpcy5jID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcXG4gICAgICAgIHRoaXMuZCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7ICAgICBcXG4gICAgICAgIHRoaXMuZTEgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xcbiAgICAgICAgdGhpcy5lMiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRkZUVGFibGVTaG9ydChsZW4pIHtcXG4gICAgICAgIHZhciB0ID0gMiAqIE1hdGguUEkgLyBsZW4sXFxuICAgICAgICAgICAgY29zVCA9IE1hdGguY29zKHQpLFxcbiAgICAgICAgICAgIHNpblQgPSBNYXRoLnNpbih0KSxcXG4gICAgICAgICAgICBmID0gbmV3IEFycmF5KGxlbik7XFxuICAgIFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICAgIGZbaV0gPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xcbiAgICAgICAgfVxcbiAgICBcXG4gICAgICAgIGZbMF1bMF0gPSAxO1xcbiAgICAgICAgZlswXVsxXSA9IDA7XFxuICAgICAgICB2YXIgbGFzdEltYWcgPSAwO1xcbiAgICBcXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICBmW2ldWzBdID0gZltpIC0gMV1bMF0gKiBjb3NUICsgbGFzdEltYWcgKiBzaW5UO1xcbiAgICAgICAgICAgIGxhc3RJbWFnID0gbGFzdEltYWcgKiBjb3NUIC0gZltpIC0gMV1bMF0gKiBzaW5UO1xcbiAgICAgICAgICAgIGZbaV1bMV0gPSAtbGFzdEltYWc7XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgcmV0dXJuIGY7XFxuICAgIH1cXG4gICAgXFxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRkZUVGFibGVMb25nKGxlbikge1xcbiAgICAgICAgdmFyIHQgPSAyICogTWF0aC5QSSAvIGxlbixcXG4gICAgICAgICAgICBjb3NUID0gTWF0aC5jb3ModCksXFxuICAgICAgICAgICAgc2luVCA9IE1hdGguc2luKHQpLFxcbiAgICAgICAgICAgIGYgPSBuZXcgQXJyYXkobGVuKTtcXG4gICAgXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgICAgZltpXSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgZlswXVswXSA9IDE7XFxuICAgICAgICBmWzBdWzFdID0gMDtcXG4gICAgICAgIGZbMF1bMl0gPSAwO1xcbiAgICBcXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICBmW2ldWzBdID0gZltpIC0gMV1bMF0gKiBjb3NUICsgZltpIC0gMV1bMl0gKiBzaW5UO1xcbiAgICAgICAgICAgIGZbaV1bMl0gPSBmW2kgLSAxXVsyXSAqIGNvc1QgLSBmW2kgLSAxXVswXSAqIHNpblQ7XFxuICAgICAgICAgICAgZltpXVsxXSA9IC1mW2ldWzJdO1xcbiAgICAgICAgfVxcbiAgICBcXG4gICAgICAgIHJldHVybiBmO1xcbiAgICB9XFxuICAgIFxcbiAgICBGRlQucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihpbnB1dCwgZm9yd2FyZCkge1xcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICAgIGltT2Zmc2V0ID0gKGZvcndhcmQgPyAyIDogMSksXFxuICAgICAgICAgICAgc2NhbGUgPSAoZm9yd2FyZCA/IGxlbmd0aCA6IDEpLFxcbiAgICAgICAgICAgIHJldiA9IHRoaXMucmV2LFxcbiAgICAgICAgICAgIHJvb3RzID0gdGhpcy5yb290cztcXG4gICAgXFxuICAgICAgICAvLyBiaXQtcmV2ZXJzYWxcXG4gICAgICAgIHZhciBpaSA9IDA7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgcmV2W2ldWzBdID0gaW5wdXRbaWldWzBdO1xcbiAgICAgICAgICAgIHJldltpXVsxXSA9IGlucHV0W2lpXVsxXTtcXG4gICAgXFxuICAgICAgICAgICAgdmFyIGsgPSBsZW5ndGggPj4+IDE7XFxuICAgICAgICAgICAgd2hpbGUgKGlpID49IGsgJiYgayA+IDApIHtcXG4gICAgICAgICAgICAgICAgaWkgLT0gaztcXG4gICAgICAgICAgICAgICAgayA+Pj0gMTtcXG4gICAgICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgICAgIGlpICs9IGs7XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgdmFyIGEgPSB0aGlzLmEsXFxuICAgICAgICAgICAgYiA9IHRoaXMuYixcXG4gICAgICAgICAgICBjID0gdGhpcy5jLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLmQsXFxuICAgICAgICAgICAgZTEgPSB0aGlzLmUxLFxcbiAgICAgICAgICAgIGUyID0gdGhpcy5lMjtcXG4gICAgXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgaW5wdXRbaV1bMF0gPSByZXZbaV1bMF07XFxuICAgICAgICAgICAgaW5wdXRbaV1bMV0gPSByZXZbaV1bMV07XFxuICAgICAgICB9XFxuICAgIFxcbiAgICAgICAgLy8gYm90dG9tIGJhc2UtNCByb3VuZFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xcbiAgICAgICAgICAgIGFbMF0gPSBpbnB1dFtpXVswXSArIGlucHV0W2kgKyAxXVswXTtcXG4gICAgICAgICAgICBhWzFdID0gaW5wdXRbaV1bMV0gKyBpbnB1dFtpICsgMV1bMV07XFxuICAgICAgICAgICAgYlswXSA9IGlucHV0W2kgKyAyXVswXSArIGlucHV0W2kgKyAzXVswXTtcXG4gICAgICAgICAgICBiWzFdID0gaW5wdXRbaSArIDJdWzFdICsgaW5wdXRbaSArIDNdWzFdO1xcbiAgICAgICAgICAgIGNbMF0gPSBpbnB1dFtpXVswXSAtIGlucHV0W2kgKyAxXVswXTtcXG4gICAgICAgICAgICBjWzFdID0gaW5wdXRbaV1bMV0gLSBpbnB1dFtpICsgMV1bMV07XFxuICAgICAgICAgICAgZFswXSA9IGlucHV0W2kgKyAyXVswXSAtIGlucHV0W2kgKyAzXVswXTtcXG4gICAgICAgICAgICBkWzFdID0gaW5wdXRbaSArIDJdWzFdIC0gaW5wdXRbaSArIDNdWzFdO1xcbiAgICAgICAgICAgIGlucHV0W2ldWzBdID0gYVswXSArIGJbMF07XFxuICAgICAgICAgICAgaW5wdXRbaV1bMV0gPSBhWzFdICsgYlsxXTtcXG4gICAgICAgICAgICBpbnB1dFtpICsgMl1bMF0gPSBhWzBdIC0gYlswXTtcXG4gICAgICAgICAgICBpbnB1dFtpICsgMl1bMV0gPSBhWzFdIC0gYlsxXTtcXG4gICAgXFxuICAgICAgICAgICAgZTFbMF0gPSBjWzBdIC0gZFsxXTtcXG4gICAgICAgICAgICBlMVsxXSA9IGNbMV0gKyBkWzBdO1xcbiAgICAgICAgICAgIGUyWzBdID0gY1swXSArIGRbMV07XFxuICAgICAgICAgICAgZTJbMV0gPSBjWzFdIC0gZFswXTtcXG4gICAgXFxuICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcXG4gICAgICAgICAgICAgICAgaW5wdXRbaSArIDFdWzBdID0gZTJbMF07XFxuICAgICAgICAgICAgICAgIGlucHV0W2kgKyAxXVsxXSA9IGUyWzFdO1xcbiAgICAgICAgICAgICAgICBpbnB1dFtpICsgM11bMF0gPSBlMVswXTtcXG4gICAgICAgICAgICAgICAgaW5wdXRbaSArIDNdWzFdID0gZTFbMV07XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaW5wdXRbaSArIDFdWzBdID0gZTFbMF07XFxuICAgICAgICAgICAgICAgIGlucHV0W2kgKyAxXVsxXSA9IGUxWzFdO1xcbiAgICAgICAgICAgICAgICBpbnB1dFtpICsgM11bMF0gPSBlMlswXTtcXG4gICAgICAgICAgICAgICAgaW5wdXRbaSArIDNdWzFdID0gZTJbMV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICBcXG4gICAgICAgIC8vIGl0ZXJhdGlvbnMgZnJvbSBib3R0b20gdG8gdG9wXFxuICAgICAgICBmb3IgKHZhciBpID0gNDsgaSA8IGxlbmd0aDsgaSA8PD0gMSkge1xcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IGkgPDwgMSxcXG4gICAgICAgICAgICAgICAgbSA9IGxlbmd0aCAvIHNoaWZ0O1xcbiAgICBcXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IHNoaWZ0KSB7XFxuICAgICAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBpOyBrKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBrbSA9IGsgKiBtLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RSZSA9IHJvb3RzW2ttXVswXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICByb290SW0gPSByb290c1trbV1baW1PZmZzZXRdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpSZSA9IGlucHV0W2kgKyBqICsga11bMF0gKiByb290UmUgLSBpbnB1dFtpICsgaiArIGtdWzFdICogcm9vdEltLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpJbSA9IGlucHV0W2kgKyBqICsga11bMF0gKiByb290SW0gKyBpbnB1dFtpICsgaiArIGtdWzFdICogcm9vdFJlO1xcbiAgICBcXG4gICAgICAgICAgICAgICAgICAgIGlucHV0W2kgKyBqICsga11bMF0gPSAoaW5wdXRbaiArIGtdWzBdIC0gelJlKSAqIHNjYWxlO1xcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRbaSArIGogKyBrXVsxXSA9IChpbnB1dFtqICsga11bMV0gLSB6SW0pICogc2NhbGU7XFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFtqICsga11bMF0gPSAoaW5wdXRbaiArIGtdWzBdICsgelJlKSAqIHNjYWxlO1xcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRbaiArIGtdWzFdID0gKGlucHV0W2ogKyBrXVsxXSArIHpJbSkgKiBzY2FsZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgXFxuICAgIHJldHVybiBGRlQ7XFxuICAgIFxcbn0pKCk7Ly9pbXBvcnQgXFxcImZmdC5qc1xcXCJcXG5cXG4vLyBNb2RpZmllZCBEaXNjcmV0ZSBDb3NpbmUgVHJhbnNmb3JtXFxuZnVuY3Rpb24gTURDVChsZW5ndGgpIHtcXG4gICAgdGhpcy5OID0gbGVuZ3RoO1xcbiAgICB0aGlzLk4yID0gbGVuZ3RoID4+PiAxO1xcbiAgICB0aGlzLk40ID0gbGVuZ3RoID4+PiAyO1xcbiAgICB0aGlzLk44ID0gbGVuZ3RoID4+PiAzO1xcbiAgICBcXG4gICAgc3dpdGNoIChsZW5ndGgpIHtcXG4gICAgICAgIGNhc2UgMjA0ODpcXG4gICAgICAgICAgICB0aGlzLnNpbmNvcyA9IE1EQ1RfVEFCTEVfMjA0ODtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBcXG4gICAgICAgIGNhc2UgMjU2OlxcbiAgICAgICAgICAgIHRoaXMuc2luY29zID0gTURDVF9UQUJMRV8yNTY7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgXFxuICAgICAgICBjYXNlIDE5MjA6XFxuICAgICAgICAgICAgdGhpcy5zaW5jb3MgPSBNRENUX1RBQkxFXzE5MjA7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgXFxuICAgICAgICBjYXNlIDI0MDpcXG4gICAgICAgICAgICB0aGlzLnNpbmNvcyA9IE1EQ1RfVEFCTEVfMjQwO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInVuc3VwcG9ydGVkIE1EQ1QgbGVuZ3RoOiBcXFwiICsgbGVuZ3RoKTtcXG4gICAgfVxcbiAgICBcXG4gICAgdGhpcy5mZnQgPSBuZXcgRkZUKHRoaXMuTjQpO1xcbiAgICBcXG4gICAgdGhpcy5idWYgPSBuZXcgQXJyYXkodGhpcy5ONCk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ONDsgaSsrKSB7XFxuICAgICAgICB0aGlzLmJ1ZltpXSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XFxuICAgIH1cXG4gICAgXFxuICAgIHRoaXMudG1wID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcXG59XFxuXFxuTURDVC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGlucHV0LCBpbk9mZnNldCwgb3V0cHV0LCBvdXRPZmZzZXQpIHtcXG4gICAgLy8gbG9jYWwgYWNjZXNzXFxuICAgIHZhciBOMiA9IHRoaXMuTjIsXFxuICAgICAgICBONCA9IHRoaXMuTjQsXFxuICAgICAgICBOOCA9IHRoaXMuTjgsXFxuICAgICAgICBidWYgPSB0aGlzLmJ1ZixcXG4gICAgICAgIHRtcCA9IHRoaXMudG1wLFxcbiAgICAgICAgc2luY29zID0gdGhpcy5zaW5jb3MsXFxuICAgICAgICBmZnQgPSB0aGlzLmZmdDtcXG4gICAgXFxuICAgIC8vIHByZS1JRkZUIGNvbXBsZXggbXVsdGlwbGljYXRpb25cXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBONDsgaysrKSB7XFxuICAgICAgICBidWZba11bMV0gPSAoaW5wdXRbaW5PZmZzZXQgKyAyICoga10gKiBzaW5jb3Nba11bMF0pICsgKGlucHV0W2luT2Zmc2V0ICsgTjIgLSAxIC0gMiAqIGtdICogc2luY29zW2tdWzFdKTtcXG4gICAgICAgIGJ1ZltrXVswXSA9IChpbnB1dFtpbk9mZnNldCArIE4yIC0gMSAtIDIgKiBrXSAqIHNpbmNvc1trXVswXSkgLSAoaW5wdXRbaW5PZmZzZXQgKyAyICoga10gKiBzaW5jb3Nba11bMV0pO1xcbiAgICB9XFxuICAgIFxcbiAgICAvLyBjb21wbGV4IElGRlQsIG5vbi1zY2FsaW5nXFxuICAgIGZmdC5wcm9jZXNzKGJ1ZiwgZmFsc2UpO1xcbiAgICBcXG4gICAgLy8gcG9zdC1JRkZUIGNvbXBsZXggbXVsdGlwbGljYXRpb25cXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBONDsgaysrKSB7XFxuICAgICAgICB0bXBbMF0gPSBidWZba11bMF07XFxuICAgICAgICB0bXBbMV0gPSBidWZba11bMV07XFxuICAgICAgICBidWZba11bMV0gPSAodG1wWzFdICogc2luY29zW2tdWzBdKSArICh0bXBbMF0gKiBzaW5jb3Nba11bMV0pO1xcbiAgICAgICAgYnVmW2tdWzBdID0gKHRtcFswXSAqIHNpbmNvc1trXVswXSkgLSAodG1wWzFdICogc2luY29zW2tdWzFdKTtcXG4gICAgfVxcbiAgICBcXG4gICAgLy8gcmVvcmRlcmluZ1xcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IE44OyBrICs9IDIpIHtcXG4gICAgICAgIG91dHB1dFtvdXRPZmZzZXQgKyAyICoga10gPSBidWZbTjggKyBrXVsxXTtcXG4gICAgICAgIG91dHB1dFtvdXRPZmZzZXQgKyAyICsgMiAqIGtdID0gYnVmW044ICsgMSArIGtdWzFdO1xcblxcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIDEgKyAyICoga10gPSAtYnVmW044IC0gMSAtIGtdWzBdO1xcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIDMgKyAyICoga10gPSAtYnVmW044IC0gMiAtIGtdWzBdO1xcblxcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIE40ICsgMiAqIGtdID0gYnVmW2tdWzBdO1xcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIE40ICsgMiArIDIgKiBrXSA9IGJ1ZlsxICsga11bMF07XFxuXFxuICAgICAgICBvdXRwdXRbb3V0T2Zmc2V0ICsgTjQgKyAxICsgMiAqIGtdID0gLWJ1ZltONCAtIDEgLSBrXVsxXTtcXG4gICAgICAgIG91dHB1dFtvdXRPZmZzZXQgKyBONCArIDMgKyAyICoga10gPSAtYnVmW040IC0gMiAtIGtdWzFdO1xcblxcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIE4yICsgMiAqIGtdID0gYnVmW044ICsga11bMF07XFxuICAgICAgICBvdXRwdXRbb3V0T2Zmc2V0ICsgTjIgKyAyICsgMiAqIGtdID0gYnVmW044ICsgMSArIGtdWzBdO1xcblxcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIE4yICsgMSArIDIgKiBrXSA9IC1idWZbTjggLSAxIC0ga11bMV07XFxuICAgICAgICBvdXRwdXRbb3V0T2Zmc2V0ICsgTjIgKyAzICsgMiAqIGtdID0gLWJ1ZltOOCAtIDIgLSBrXVsxXTtcXG5cXG4gICAgICAgIG91dHB1dFtvdXRPZmZzZXQgKyBOMiArIE40ICsgMiAqIGtdID0gLWJ1ZltrXVsxXTtcXG4gICAgICAgIG91dHB1dFtvdXRPZmZzZXQgKyBOMiArIE40ICsgMiArIDIgKiBrXSA9IC1idWZbMSArIGtdWzFdO1xcblxcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIE4yICsgTjQgKyAxICsgMiAqIGtdID0gYnVmW040IC0gMSAtIGtdWzBdO1xcbiAgICAgICAgb3V0cHV0W291dE9mZnNldCArIE4yICsgTjQgKyAzICsgMiAqIGtdID0gYnVmW040IC0gMiAtIGtdWzBdO1xcbiAgICB9XFxufTsvL2ltcG9ydCBcXFwibWRjdC5qc1xcXCJcXG5cXG52YXIgRmlsdGVyQmFuayA9IChmdW5jdGlvbigpIHtcXG4gIFxcbiAgZnVuY3Rpb24gRmlsdGVyQmFuayhzbWFsbEZyYW1lcywgY2hhbm5lbHMpIHtcXG4gICAgICBpZiAoc21hbGxGcmFtZXMpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJXSEE/PyBObyBzbWFsbCBmcmFtZXMgYWxsb3dlZC5cXFwiKTtcXG4gICAgICB9XFxuICBcXG4gICAgICB0aGlzLmxlbmd0aCA9IDEwMjQ7XFxuICAgICAgdGhpcy5zaG9ydExlbmd0aCA9IDEyODtcXG4gIFxcbiAgICAgIHRoaXMubWlkID0gKHRoaXMubGVuZ3RoIC0gdGhpcy5zaG9ydExlbmd0aCkgLyAyO1xcbiAgICAgIHRoaXMudHJhbnMgPSB0aGlzLnNob3J0TGVuZ3RoIC8gMjtcXG4gIFxcbiAgICAgIHRoaXMubWRjdFNob3J0ID0gbmV3IE1EQ1QodGhpcy5zaG9ydExlbmd0aCAqIDIpO1xcbiAgICAgIHRoaXMubWRjdExvbmcgID0gbmV3IE1EQ1QodGhpcy5sZW5ndGggKiAyKTtcXG4gIFxcbiAgICAgIHRoaXMub3ZlcmxhcHMgPSBuZXcgQXJyYXkoY2hhbm5lbHMpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xcbiAgICAgICAgICB0aGlzLm92ZXJsYXBzW2ldID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmxlbmd0aCk7XFxuICAgICAgfVxcbiAgXFxuICAgICAgdGhpcy5idWYgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiB0aGlzLmxlbmd0aCk7XFxuICB9XFxuICAgIFxcbiAgZnVuY3Rpb24gZ2VuZXJhdGVTaW5lV2luZG93KGxlbikge1xcbiAgICAgIHZhciBkID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgZFtpXSA9IE1hdGguc2luKChpICsgMC41KSAqIChNYXRoLlBJIC8gKDIuMCAqIGxlbikpKVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZDtcXG4gIH1cXG4gIFxcbiAgZnVuY3Rpb24gZ2VuZXJhdGVLQkRXaW5kb3coYWxwaGEsIGxlbikge1xcbiAgICAgIHZhciBQSU4gPSBNYXRoLlBJIC8gbGVuLFxcbiAgICAgICAgICBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbiksXFxuICAgICAgICAgIHN1bSA9IDAsXFxuICAgICAgICAgIGYgPSBuZXcgRmxvYXQzMkFycmF5KGxlbiksXFxuICAgICAgICAgIGFscGhhMiA9IChhbHBoYSAqIFBJTikgKiAoYWxwaGEgKiBQSU4pO1xcbiAgXFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xcbiAgICAgICAgICB2YXIgdG1wID0gbiAqIChsZW4gLSBuKSAqIGFscGhhMixcXG4gICAgICAgICAgICAgIGJlc3NlbCA9IDE7XFxuICBcXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDUwOyBqID4gMDsgai0tKSB7XFxuICAgICAgICAgICAgICBiZXNzZWwgPSBiZXNzZWwgKiB0bXAgLyAoaiAqIGopICsgMTtcXG4gICAgICAgICAgfVxcbiAgXFxuICAgICAgICAgIHN1bSArPSBiZXNzZWw7XFxuICAgICAgICAgIGZbbl0gPSBzdW07XFxuICAgICAgfVxcbiAgXFxuICAgICAgc3VtKys7XFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xcbiAgICAgICAgICBvdXRbbl0gPSBNYXRoLnNxcnQoZltuXSAvIHN1bSk7XFxuICAgICAgfVxcbiAgXFxuICAgICAgcmV0dXJuIG91dDtcXG4gIH1cXG4gIFxcbiAgY29uc3QgU0lORV8xMDI0ID0gZ2VuZXJhdGVTaW5lV2luZG93KDEwMjQpLFxcbiAgICAgICAgU0lORV8xMjggID0gZ2VuZXJhdGVTaW5lV2luZG93KDEyOCksXFxuICAgICAgICBLQkRfMTAyNCAgPSBnZW5lcmF0ZUtCRFdpbmRvdyg0LCAxMDI0KSxcXG4gICAgICAgIEtCRF8xMjggICA9IGdlbmVyYXRlS0JEV2luZG93KDYsIDEyOCksXFxuICAgICAgICBMT05HX1dJTkRPV1MgPSBbU0lORV8xMDI0LCBLQkRfMTAyNF0sXFxuICAgICAgICBTSE9SVF9XSU5ET1dTID0gW1NJTkVfMTI4LCBLQkRfMTI4XTtcXG4gIFxcbiAgRmlsdGVyQmFuay5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGluZm8sIGlucHV0LCBvdXRwdXQsIGNoYW5uZWwpIHtcXG4gICAgICB2YXIgb3ZlcmxhcCA9IHRoaXMub3ZlcmxhcHNbY2hhbm5lbF0sXFxuICAgICAgICAgIHdpbmRvd1NoYXBlID0gaW5mby53aW5kb3dTaGFwZVsxXSxcXG4gICAgICAgICAgd2luZG93U2hhcGVQcmV2ID0gaW5mby53aW5kb3dTaGFwZVswXSxcXG4gICAgICAgICAgbG9uZ1dpbmRvd3MgPSBMT05HX1dJTkRPV1Nbd2luZG93U2hhcGVdLFxcbiAgICAgICAgICBzaG9ydFdpbmRvd3MgPSBTSE9SVF9XSU5ET1dTW3dpbmRvd1NoYXBlXSxcXG4gICAgICAgICAgbG9uZ1dpbmRvd3NQcmV2ID0gTE9OR19XSU5ET1dTW3dpbmRvd1NoYXBlUHJldl0sXFxuICAgICAgICAgIHNob3J0V2luZG93c1ByZXYgPSBTSE9SVF9XSU5ET1dTW3dpbmRvd1NoYXBlUHJldl0sXFxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBzaG9ydExlbiA9IHRoaXMuc2hvcnRMZW5ndGgsXFxuICAgICAgICAgIG1pZCA9IHRoaXMubWlkLFxcbiAgICAgICAgICB0cmFucyA9IHRoaXMudHJhbnMsXFxuICAgICAgICAgIGJ1ZiA9IHRoaXMuYnVmLFxcbiAgICAgICAgICBtZGN0TG9uZyA9IHRoaXMubWRjdExvbmcsXFxuICAgICAgICAgIG1kY3RTaG9ydCA9IHRoaXMubWRjdFNob3J0O1xcbiAgXFxuICAgICAgc3dpdGNoIChpbmZvLndpbmRvd1NlcXVlbmNlKSB7XFxuICAgICAgICAgIGNhc2UgSUNTdHJlYW0uT05MWV9MT05HX1NFUVVFTkNFOlxcbiAgICAgICAgICAgICAgbWRjdExvbmcucHJvY2VzcyhpbnB1dCwgMCwgYnVmLCAwKTtcXG4gIFxcbiAgICAgICAgICAgICAgLy8gYWRkIHNlY29uZCBoYWxmIG91dHB1dCBvZiBwcmV2aW91cyBmcmFtZSB0byB3aW5kb3dlZCBvdXRwdXQgb2YgY3VycmVudCBmcmFtZVxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IG92ZXJsYXBbaV0gKyAoYnVmW2ldICogbG9uZ1dpbmRvd3NQcmV2W2ldKTtcXG4gICAgICAgICAgICAgIH1cXG4gIFxcbiAgICAgICAgICAgICAgLy8gd2luZG93IHRoZSBzZWNvbmQgaGFsZiBhbmQgc2F2ZSBhcyBvdmVybGFwIGZvciBuZXh0IGZyYW1lXFxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgb3ZlcmxhcFtpXSA9IGJ1ZltsZW5ndGggKyBpXSAqIGxvbmdXaW5kb3dzW2xlbmd0aCAtIDEgLSBpXTtcXG4gICAgICAgICAgICAgIH1cXG4gIFxcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICBcXG4gICAgICAgICAgY2FzZSBJQ1N0cmVhbS5MT05HX1NUQVJUX1NFUVVFTkNFOlxcbiAgICAgICAgICAgICAgbWRjdExvbmcucHJvY2VzcyhpbnB1dCwgMCwgYnVmLCAwKTtcXG4gIFxcbiAgICAgICAgICAgICAgLy8gYWRkIHNlY29uZCBoYWxmIG91dHB1dCBvZiBwcmV2aW91cyBmcmFtZSB0byB3aW5kb3dlZCBvdXRwdXQgb2YgY3VycmVudCBmcmFtZVxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IG92ZXJsYXBbaV0gKyAoYnVmW2ldICogbG9uZ1dpbmRvd3NQcmV2W2ldKTtcXG4gICAgICAgICAgICAgIH1cXG4gIFxcbiAgICAgICAgICAgICAgLy8gd2luZG93IHRoZSBzZWNvbmQgaGFsZiBhbmQgc2F2ZSBhcyBvdmVybGFwIGZvciBuZXh0IGZyYW1lXFxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pZDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgb3ZlcmxhcFtpXSA9IGJ1ZltsZW5ndGggKyBpXTtcXG4gICAgICAgICAgICAgIH1cXG4gIFxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG9ydExlbjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgb3ZlcmxhcFttaWQgKyBpXSA9IGJ1ZltsZW5ndGggKyBtaWQgKyBpXSAqIHNob3J0V2luZG93c1tzaG9ydExlbiAtIGkgLSAxXTtcXG4gICAgICAgICAgICAgIH1cXG4gIFxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaWQ7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIG92ZXJsYXBbbWlkICsgc2hvcnRMZW4gKyBpXSA9IDA7XFxuICAgICAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgXFxuICAgICAgICAgIGNhc2UgSUNTdHJlYW0uRUlHSFRfU0hPUlRfU0VRVUVOQ0U6XFxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIG1kY3RTaG9ydC5wcm9jZXNzKGlucHV0LCBpICogc2hvcnRMZW4sIGJ1ZiwgMiAqIGkgKiBzaG9ydExlbik7XFxuICAgICAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgICAgIC8vIGFkZCBzZWNvbmQgaGFsZiBvdXRwdXQgb2YgcHJldmlvdXMgZnJhbWUgdG8gd2luZG93ZWQgb3V0cHV0IG9mIGN1cnJlbnQgZnJhbWVcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlkOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBvdmVybGFwW2ldO1xcbiAgICAgICAgICAgICAgfVxcbiAgXFxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3J0TGVuOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICBvdXRwdXRbbWlkICsgaV0gPSBvdmVybGFwW21pZCArIGldICsgYnVmW2ldICogc2hvcnRXaW5kb3dzUHJldltpXTtcXG4gICAgICAgICAgICAgICAgICBvdXRwdXRbbWlkICsgMSAqIHNob3J0TGVuICsgaV0gPSBvdmVybGFwW21pZCArIHNob3J0TGVuICogMSArIGldICsgKGJ1ZltzaG9ydExlbiAqIDEgKyBpXSAqIHNob3J0V2luZG93c1tzaG9ydExlbiAtIDEgLSBpXSkgKyAoYnVmW3Nob3J0TGVuICogMiArIGldICAqIHNob3J0V2luZG93c1tpXSk7XFxuICAgICAgICAgICAgICAgICAgb3V0cHV0W21pZCArIDIgKiBzaG9ydExlbiArIGldID0gb3ZlcmxhcFttaWQgKyBzaG9ydExlbiAqIDIgKyBpXSArIChidWZbc2hvcnRMZW4gKiAzICsgaV0gKiBzaG9ydFdpbmRvd3Nbc2hvcnRMZW4gLSAxIC0gaV0pICsgKGJ1ZltzaG9ydExlbiAqIDQgKyBpXSAqIHNob3J0V2luZG93c1tpXSk7XFxuICAgICAgICAgICAgICAgICAgb3V0cHV0W21pZCArIDMgKiBzaG9ydExlbiArIGldID0gb3ZlcmxhcFttaWQgKyBzaG9ydExlbiAqIDMgKyBpXSArIChidWZbc2hvcnRMZW4gKiA1ICsgaV0gKiBzaG9ydFdpbmRvd3Nbc2hvcnRMZW4gLSAxIC0gaV0pICsgKGJ1ZltzaG9ydExlbiAqIDYgKyBpXSAqIHNob3J0V2luZG93c1tpXSk7XFxuICBcXG4gICAgICAgICAgICAgICAgICBpZiAoaSA8IHRyYW5zKVxcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbWlkICsgNCAqIHNob3J0TGVuICsgaV0gPSBvdmVybGFwW21pZCArIHNob3J0TGVuICogNCArIGldICsgKGJ1ZltzaG9ydExlbiAqIDcgKyBpXSAqIHNob3J0V2luZG93c1tzaG9ydExlbiAtIDEgLSBpXSkgKyAoYnVmW3Nob3J0TGVuICogOCArIGldICogc2hvcnRXaW5kb3dzW2ldKTtcXG4gICAgICAgICAgICAgIH1cXG4gIFxcbiAgICAgICAgICAgICAgLy8gd2luZG93IHRoZSBzZWNvbmQgaGFsZiBhbmQgc2F2ZSBhcyBvdmVybGFwIGZvciBuZXh0IGZyYW1lXFxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3J0TGVuOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICBpZihpID49IHRyYW5zKSBcXG4gICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFttaWQgKyA0ICogc2hvcnRMZW4gKyBpIC0gbGVuZ3RoXSA9IChidWZbc2hvcnRMZW4gKiA3ICsgaV0gKiBzaG9ydFdpbmRvd3Nbc2hvcnRMZW4gLSAxIC0gaV0pICsgKGJ1ZltzaG9ydExlbiAqIDggKyBpXSAqIHNob3J0V2luZG93c1tpXSk7XFxuICBcXG4gICAgICAgICAgICAgICAgICBvdmVybGFwW21pZCArIDUgKiBzaG9ydExlbiArIGkgLSBsZW5ndGhdID0gKGJ1ZltzaG9ydExlbiAqIDkgKyBpXSAqIHNob3J0V2luZG93c1tzaG9ydExlbiAtIDEgLSBpXSkgKyAoYnVmW3Nob3J0TGVuICogMTAgKyBpXSAqIHNob3J0V2luZG93c1tpXSk7XFxuICAgICAgICAgICAgICAgICAgb3ZlcmxhcFttaWQgKyA2ICogc2hvcnRMZW4gKyBpIC0gbGVuZ3RoXSA9IChidWZbc2hvcnRMZW4gKiAxMSArIGldICogc2hvcnRXaW5kb3dzW3Nob3J0TGVuIC0gMSAtIGldKSArIChidWZbc2hvcnRMZW4gKiAxMiArIGldKnNob3J0V2luZG93c1tpXSk7XFxuICAgICAgICAgICAgICAgICAgb3ZlcmxhcFttaWQgKyA3ICogc2hvcnRMZW4gKyBpIC0gbGVuZ3RoXSA9IChidWZbc2hvcnRMZW4gKiAxMyArIGldICogc2hvcnRXaW5kb3dzW3Nob3J0TGVuIC0gMSAtIGldKSArIChidWZbc2hvcnRMZW4gKiAxNCArIGldKnNob3J0V2luZG93c1tpXSk7XFxuICAgICAgICAgICAgICAgICAgb3ZlcmxhcFttaWQgKyA4ICogc2hvcnRMZW4gKyBpIC0gbGVuZ3RoXSA9IChidWZbc2hvcnRMZW4gKiAxNSArIGldICogc2hvcnRXaW5kb3dzW3Nob3J0TGVuIC0gMSAtIGldKTtcXG4gICAgICAgICAgICAgIH1cXG4gIFxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaWQ7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIG92ZXJsYXBbbWlkICsgc2hvcnRMZW4gKyBpXSA9IDA7XFxuICAgICAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgXFxuICAgICAgICAgIGNhc2UgSUNTdHJlYW0uTE9OR19TVE9QX1NFUVVFTkNFOlxcbiAgICAgICAgICAgICAgbWRjdExvbmcucHJvY2VzcyhpbnB1dCwgMCwgYnVmLCAwKTtcXG4gIFxcbiAgICAgICAgICAgICAgLy8gYWRkIHNlY29uZCBoYWxmIG91dHB1dCBvZiBwcmV2aW91cyBmcmFtZSB0byB3aW5kb3dlZCBvdXRwdXQgb2YgY3VycmVudCBmcmFtZVxcbiAgICAgICAgICAgICAgLy8gY29uc3RydWN0IGZpcnN0IGhhbGYgd2luZG93IHVzaW5nIHBhZGRpbmcgd2l0aCAxJ3MgYW5kIDAnc1xcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaWQ7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IG92ZXJsYXBbaV07XFxuICAgICAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvcnRMZW47IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIG91dHB1dFttaWQgKyBpXSA9IG92ZXJsYXBbbWlkICsgaV0gKyAoYnVmW21pZCArIGldICogc2hvcnRXaW5kb3dzUHJldltpXSk7XFxuICAgICAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlkOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICBvdXRwdXRbbWlkICsgc2hvcnRMZW4gKyBpXSA9IG92ZXJsYXBbbWlkICsgc2hvcnRMZW4gKyBpXSArIGJ1ZlttaWQgKyBzaG9ydExlbiArIGldO1xcbiAgICAgICAgICAgICAgfVxcbiAgXFxuICAgICAgICAgICAgICAvLyB3aW5kb3cgdGhlIHNlY29uZCBoYWxmIGFuZCBzYXZlIGFzIG92ZXJsYXAgZm9yIG5leHQgZnJhbWVcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICBvdmVybGFwW2ldID0gYnVmW2xlbmd0aCArIGldICogbG9uZ1dpbmRvd3NbbGVuZ3RoIC0gMSAtIGldO1xcbiAgICAgICAgICAgICAgfVxcbiAgXFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICB9O1xcbiAgXFxuICByZXR1cm4gRmlsdGVyQmFuaztcXG4gICAgXFxufSkoKTsvL2ltcG9ydCBcXFwiZmlsdGVyX2JhbmsuanNcXFwiXFxuXFxudmFyIEFBQ0RlY29kZXIgPSBBVi5EZWNvZGVyLmV4dGVuZChmdW5jdGlvbigpIHtcXG4gICAgQVYuRGVjb2Rlci5yZWdpc3RlcignbXA0YScsIHRoaXMpO1xcbiAgICBBVi5EZWNvZGVyLnJlZ2lzdGVyKCdhYWMgJywgdGhpcyk7XFxuICAgIFxcbiAgICAvLyBBQUMgcHJvZmlsZXNcXG4gICAgY29uc3QgQU9UX0FBQ19NQUlOID0gMSwgLy8gbm9cXG4gICAgICAgICAgQU9UX0FBQ19MQyA9IDIsICAgLy8geWVzXFxuICAgICAgICAgIEFPVF9BQUNfTFRQID0gNCwgIC8vIG5vXFxuICAgICAgICAgIEFPVF9FU0NBUEUgPSAzMTtcXG4gICAgICAgICAgXFxuICAgIC8vIENoYW5uZWwgY29uZmlndXJhdGlvbnNcXG4gICAgY29uc3QgQ0hBTk5FTF9DT05GSUdfTk9ORSA9IDAsXFxuICAgICAgICAgIENIQU5ORUxfQ09ORklHX01PTk8gPSAxLFxcbiAgICAgICAgICBDSEFOTkVMX0NPTkZJR19TVEVSRU8gPSAyLFxcbiAgICAgICAgICBDSEFOTkVMX0NPTkZJR19TVEVSRU9fUExVU19DRU5URVIgPSAzLFxcbiAgICAgICAgICBDSEFOTkVMX0NPTkZJR19TVEVSRU9fUExVU19DRU5URVJfUExVU19SRUFSX01PTk8gPSA0LFxcbiAgICAgICAgICBDSEFOTkVMX0NPTkZJR19GSVZFID0gNSxcXG4gICAgICAgICAgQ0hBTk5FTF9DT05GSUdfRklWRV9QTFVTX09ORSA9IDYsXFxuICAgICAgICAgIENIQU5ORUxfQ09ORklHX1NFVkVOX1BMVVNfT05FID0gODtcXG4gICAgXFxuICAgIHRoaXMucHJvdG90eXBlLnNldENvb2tpZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xcbiAgICAgICAgdmFyIGRhdGEgPSBBVi5TdHJlYW0uZnJvbUJ1ZmZlcihidWZmZXIpLFxcbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBBVi5CaXRzdHJlYW0oZGF0YSk7XFxuICAgICAgICBcXG4gICAgICAgIHRoaXMuZm9ybWF0LmJpdHNQZXJDaGFubmVsID0gMTY7IC8vIGNhZiBmb3JtYXQgZG9lc24ndCBlbmNvZGUgdGhpc1xcbiAgICAgICAgdGhpcy5jb25maWcgPSB7fTtcXG4gICAgICAgIFxcbiAgICAgICAgdGhpcy5jb25maWcucHJvZmlsZSA9IHN0cmVhbS5yZWFkKDUpO1xcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByb2ZpbGUgPT09IEFPVF9FU0NBUEUpXFxuICAgICAgICAgICAgdGhpcy5jb25maWcucHJvZmlsZSA9IDMyICsgc3RyZWFtLnJlYWQoNik7XFxuICAgICAgICAgICAgXFxuICAgICAgICB0aGlzLmNvbmZpZy5zYW1wbGVJbmRleCA9IHN0cmVhbS5yZWFkKDQpO1xcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNhbXBsZUluZGV4ID09PSAweDBmKSB7XFxuICAgICAgICAgICAgdGhpcy5jb25maWcuc2FtcGxlUmF0ZSA9IDQ4MDAwLy9zdHJlYW0ucmVhZCgyNCk7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTQU1QTEVfUkFURVMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKFNBTVBMRV9SQVRFU1tpXSA9PT0gdGhpcy5jb25maWcuc2FtcGxlUmF0ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2FtcGxlSW5kZXggPSBpO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNhbXBsZVJhdGUgPSA0ODAwMC8vU0FNUExFX1JBVEVTW3RoaXMuY29uZmlnLnNhbXBsZUluZGV4XTtcXG4gICAgICAgIH1cXG4gICAgICAgICAgICBcXG4gICAgICAgIHRoaXMuY29uZmlnLmNoYW5Db25maWcgPSBzdHJlYW0ucmVhZCg0KTtcXG4gICAgICAgIHRoaXMuZm9ybWF0LmNoYW5uZWxzUGVyRnJhbWUgPSB0aGlzLmNvbmZpZy5jaGFuQ29uZmlnOyAvLyBzb21ldGltZXMgbTRhIGZpbGVzIGVuY29kZSB0aGlzIHdyb25nXFxuICAgICAgICBcXG4gICAgICAgIHN3aXRjaCAodGhpcy5jb25maWcucHJvZmlsZSkge1xcbiAgICAgICAgICAgIGNhc2UgQU9UX0FBQ19NQUlOOlxcbiAgICAgICAgICAgIGNhc2UgQU9UX0FBQ19MQzpcXG4gICAgICAgICAgICBjYXNlIEFPVF9BQUNfTFRQOlxcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnJlYWQoMSkpIC8vIGZyYW1lTGVuZ3RoRmxhZ1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcmFtZUxlbmd0aEZsYWcgbm90IHN1cHBvcnRlZCcpO1xcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmZyYW1lTGVuZ3RoID0gMTAyNDtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnJlYWQoMSkpIC8vIGRlcGVuZHNPbkNvcmVDb2RlclxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmFkdmFuY2UoMTQpOyAvLyBjb3JlQ29kZXJEZWxheVxcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0ucmVhZCgxKSkgeyAvLyBleHRlbnNpb25GbGFnXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcucHJvZmlsZSA+IDE2KSB7IC8vIGVycm9yIHJlc2lsaWFudCBwcm9maWxlXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2VjdGlvbkRhdGFSZXNpbGllbmNlID0gc3RyZWFtLnJlYWQoMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2NhbGVmYWN0b3JSZXNpbGllbmNlID0gc3RyZWFtLnJlYWQoMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc3BlY3RyYWxEYXRhUmVzaWxpZW5jZSA9IHN0cmVhbS5yZWFkKDEpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uYWR2YW5jZSgxKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmNoYW5Db25maWcgPT09IENIQU5ORUxfQ09ORklHX05PTkUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5hZHZhbmNlKDQpIC8vIGVsZW1lbnRfaW5zdGFuY2VfdGFnXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BDRSB1bmltcGxlbWVudGVkJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FBQyBwcm9maWxlICcgKyB0aGlzLmNvbmZpZy5wcm9maWxlICsgJyBub3Qgc3VwcG9ydGVkLicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICB0aGlzLmZpbHRlcl9iYW5rID0gbmV3IEZpbHRlckJhbmsoZmFsc2UsIHRoaXMuY29uZmlnLmNoYW5Db25maWcpOyAgICAgICAgXFxuICAgICAgICB0aGlzLmljcyA9IG5ldyBJQ1N0cmVhbSh0aGlzLmNvbmZpZyk7XFxuICAgICAgICB0aGlzLmNwZSA9IG5ldyBDUEVFbGVtZW50KHRoaXMuY29uZmlnKTtcXG4gICAgICAgIHRoaXMuY2NlID0gbmV3IENDRUVsZW1lbnQodGhpcy5jb25maWcpO1xcbiAgICB9O1xcbiAgICBcXG4gICAgY29uc3QgU0NFX0VMRU1FTlQgPSAwLFxcbiAgICAgICAgICBDUEVfRUxFTUVOVCA9IDEsXFxuICAgICAgICAgIENDRV9FTEVNRU5UID0gMixcXG4gICAgICAgICAgTEZFX0VMRU1FTlQgPSAzLFxcbiAgICAgICAgICBEU0VfRUxFTUVOVCA9IDQsXFxuICAgICAgICAgIFBDRV9FTEVNRU5UID0gNSxcXG4gICAgICAgICAgRklMX0VMRU1FTlQgPSA2LFxcbiAgICAgICAgICBFTkRfRUxFTUVOVCA9IDc7XFxuICAgIFxcbiAgICAvLyBUaGUgbWFpbiBkZWNvZGluZyBmdW5jdGlvbi5cXG4gICAgdGhpcy5wcm90b3R5cGUucmVhZENodW5rID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgc3RyZWFtID0gdGhpcy5iaXRzdHJlYW07XFxuICAgICAgICBcXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFuIEFEVFMgaGVhZGVyLCBhbmQgcmVhZCBpdCBpZiBzb1xcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKDEyKSA9PT0gMHhmZmYpXFxuICAgICAgICAgICAgQURUU0RlbXV4ZXIucmVhZEhlYWRlcihzdHJlYW0pO1xcbiAgICAgICAgXFxuICAgICAgICB0aGlzLmNjZXMgPSBbXTtcXG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdLFxcbiAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxcbiAgICAgICAgICAgIGZyYW1lTGVuZ3RoID0gY29uZmlnLmZyYW1lTGVuZ3RoLFxcbiAgICAgICAgICAgIGVsZW1lbnRUeXBlID0gbnVsbDtcXG5cXG4gICAgICAgIHdoaWxlICgoZWxlbWVudFR5cGUgPSBzdHJlYW0ucmVhZCgzKSkgIT09IEVORF9FTEVNRU5UKSB7XFxuICAgICAgICAgICAgdmFyIGlkID0gc3RyZWFtLnJlYWQoNCk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50VHlwZSkge1xcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2hhbm5lbCBhbmQgbG93IGZyZXF1ZW5jeSBlbGVtZW50c1xcbiAgICAgICAgICAgICAgICBjYXNlIFNDRV9FTEVNRU5UOlxcbiAgICAgICAgICAgICAgICBjYXNlIExGRV9FTEVNRU5UOlxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGljcyA9IHRoaXMuaWNzO1xcbiAgICAgICAgICAgICAgICAgICAgaWNzLmlkID0gaWQ7XFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGljcyk7XFxuICAgICAgICAgICAgICAgICAgICBpY3MuZGVjb2RlKHN0cmVhbSwgY29uZmlnLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVsIHBhaXIgZWxlbWVudFxcbiAgICAgICAgICAgICAgICBjYXNlIENQRV9FTEVNRU5UOlxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNwZSA9IHRoaXMuY3BlO1xcbiAgICAgICAgICAgICAgICAgICAgY3BlLmlkID0gaWQ7XFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGNwZSk7XFxuICAgICAgICAgICAgICAgICAgICBjcGUuZGVjb2RlKHN0cmVhbSwgY29uZmlnKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgLy8gY2hhbm5lbCBjb3VwbGluZyBlbGVtZW50XFxuICAgICAgICAgICAgICAgIGNhc2UgQ0NFX0VMRU1FTlQ6XFxuICAgICAgICAgICAgICAgICAgICB2YXIgY2NlID0gdGhpcy5jY2U7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNjZXMucHVzaChjY2UpO1xcbiAgICAgICAgICAgICAgICAgICAgY2NlLmRlY29kZShzdHJlYW0sIGNvbmZpZyk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAvLyBkYXRhLXN0cmVhbSBlbGVtZW50XFxuICAgICAgICAgICAgICAgIGNhc2UgRFNFX0VMRU1FTlQ6XFxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxpZ24gPSBzdHJlYW0ucmVhZCgxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IHN0cmVhbS5yZWFkKDgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAyNTUpXFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gc3RyZWFtLnJlYWQoOCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ24pXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmFsaWduKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGZvciBub3cuLi5cXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5hZHZhbmNlKGNvdW50ICogOCk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAvLyBwcm9ncmFtIGNvbmZpZ3VyYXRpb24gZWxlbWVudFxcbiAgICAgICAgICAgICAgICBjYXNlIFBDRV9FTEVNRU5UOlxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJUT0RPOiBQQ0VfRUxFTUVOVFxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAvLyBmaWxsZXIgZWxlbWVudFxcbiAgICAgICAgICAgICAgICBjYXNlIEZJTF9FTEVNRU5UOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSAxNSlcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCArPSBzdHJlYW0ucmVhZCg4KSAtIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGZvciBub3cuLi5cXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5hZHZhbmNlKGlkICogOCk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVsZW1lbnQnKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgc3RyZWFtLmFsaWduKCk7XFxuICAgICAgICB0aGlzLnByb2Nlc3MoZWxlbWVudHMpO1xcbiAgICAgICAgLy8gSW50ZXJsZWF2ZSBjaGFubmVsc1xcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXFxuICAgICAgICAgICAgY2hhbm5lbHMgPSBkYXRhLmxlbmd0aCxcXG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgSW50MTZBcnJheShmcmFtZUxlbmd0aCAqIGNoYW5uZWxzKSxcXG4gICAgICAgICAgICBqID0gMDtcXG4gICAgICAgICAgICBcXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZnJhbWVMZW5ndGg7IGsrKykge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xcbiAgICAgICAgICAgICAgICBkYXRhW2ldW2tdID0gTWF0aC5tYXgoTWF0aC5taW4oZGF0YVtpXVtrXSwgMzI3NjcpLCAtMzI3NjgpIC8gMTAwMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZGF0YVxcbi8vICAgICAgICByZXR1cm4gb3V0cHV0O1xcbiAgICB9O1xcbiAgICBcXG4gICAgdGhpcy5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XFxuICAgICAgICB2YXIgY2hhbm5lbHMgPSB0aGlzLmNvbmZpZy5jaGFuQ29uZmlnO1xcbiAgICAgICAgXFxuICAgICAgICAvLyBpZiAoY2hhbm5lbHMgPT09IDEgJiYgcHNQcmVzZW50KVxcbiAgICAgICAgLy8gVE9ETzogc2JyUHJlc2VudCAoMilcXG4gICAgICAgIHZhciBtdWx0ID0gMTtcXG4gICAgICAgIFxcbiAgICAgICAgdmFyIGxlbiA9IG11bHQgKiB0aGlzLmNvbmZpZy5mcmFtZUxlbmd0aDtcXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhID0gW107XFxuICAgICAgICBcXG4gICAgICAgIC8vIEluaXRpYWxpemUgY2hhbm5lbHNcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xcbiAgICAgICAgICAgIGRhdGFbaV0gPSBuZXcgRmxvYXQzMkFycmF5KGxlbik7XFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIHZhciBjaGFubmVsID0gMDtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoICYmIGNoYW5uZWwgPCBjaGFubmVsczsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIGUgPSBlbGVtZW50c1tpXTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIElDU3RyZWFtKSB7IC8vIFNDRSBvciBMRkUgZWxlbWVudFxcbiAgICAgICAgICAgICAgICBjaGFubmVsICs9IHRoaXMucHJvY2Vzc1NpbmdsZShlLCBjaGFubmVsKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBDUEVFbGVtZW50KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BhaXIoZSwgY2hhbm5lbCk7XFxuICAgICAgICAgICAgICAgIGNoYW5uZWwgKz0gMjtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBDQ0VFbGVtZW50KSB7XFxuICAgICAgICAgICAgICAgIGNoYW5uZWwrKztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlVua25vd24gZWxlbWVudCBmb3VuZC5cXFwiKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgXFxuICAgIHRoaXMucHJvdG90eXBlLnByb2Nlc3NTaW5nbGUgPSBmdW5jdGlvbihlbGVtZW50LCBjaGFubmVsKSB7XFxuICAgICAgICB2YXIgcHJvZmlsZSA9IHRoaXMuY29uZmlnLnByb2ZpbGUsXFxuICAgICAgICAgICAgaW5mbyA9IGVsZW1lbnQuaW5mbyxcXG4gICAgICAgICAgICBkYXRhID0gZWxlbWVudC5kYXRhO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgaWYgKHByb2ZpbGUgPT09IEFPVF9BQUNfTUFJTilcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIk1haW4gcHJlZGljdGlvbiB1bmltcGxlbWVudGVkXFxcIik7XFxuICAgICAgICAgICAgXFxuICAgICAgICBpZiAocHJvZmlsZSA9PT0gQU9UX0FBQ19MVFApXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJMVFAgcHJlZGljdGlvbiB1bmltcGxlbWVudGVkXFxcIik7XFxuICAgICAgICAgICAgXFxuICAgICAgICB0aGlzLmFwcGx5Q2hhbm5lbENvdXBsaW5nKGVsZW1lbnQsIENDRUVsZW1lbnQuQkVGT1JFX1ROUywgZGF0YSwgbnVsbCk7XFxuICAgICAgICBcXG4gICAgICAgIGlmIChlbGVtZW50LnRuc1ByZXNlbnQpXFxuICAgICAgICAgICAgZWxlbWVudC50bnMucHJvY2VzcyhlbGVtZW50LCBkYXRhLCBmYWxzZSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICB0aGlzLmFwcGx5Q2hhbm5lbENvdXBsaW5nKGVsZW1lbnQsIENDRUVsZW1lbnQuQUZURVJfVE5TLCBkYXRhLCBudWxsKTtcXG4gICAgICAgIFxcbiAgICAgICAgLy8gZmlsdGVyYmFua1xcbiAgICAgICAgdGhpcy5maWx0ZXJfYmFuay5wcm9jZXNzKGluZm8sIGRhdGEsIHRoaXMuZGF0YVtjaGFubmVsXSwgY2hhbm5lbCk7XFxuICAgICAgICBcXG4gICAgICAgIGlmIChwcm9maWxlID09PSBBT1RfQUFDX0xUUClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkxUUCBwcmVkaWN0aW9uIHVuaW1wbGVtZW50ZWRcXFwiKTtcXG4gICAgICAgIFxcbiAgICAgICAgdGhpcy5hcHBseUNoYW5uZWxDb3VwbGluZyhlbGVtZW50LCBDQ0VFbGVtZW50LkFGVEVSX0lNRENULCB0aGlzLmRhdGFbY2hhbm5lbF0sIG51bGwpO1xcbiAgICAgICAgXFxuICAgICAgICBpZiAoZWxlbWVudC5nYWluUHJlc2VudClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkdhaW4gY29udHJvbCBub3QgaW1wbGVtZW50ZWRcXFwiKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgIGlmICh0aGlzLnNiclByZXNlbnQpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJTQlIgbm90IGltcGxlbWVudGVkXFxcIik7XFxuICAgICAgICAgICAgXFxuICAgICAgICByZXR1cm4gMTtcXG4gICAgfTtcXG4gICAgXFxuICAgIHRoaXMucHJvdG90eXBlLnByb2Nlc3NQYWlyID0gZnVuY3Rpb24oZWxlbWVudCwgY2hhbm5lbCkge1xcbiAgICAgICAgdmFyIHByb2ZpbGUgPSB0aGlzLmNvbmZpZy5wcm9maWxlLFxcbiAgICAgICAgICAgIGxlZnQgPSBlbGVtZW50LmxlZnQsXFxuICAgICAgICAgICAgcmlnaHQgPSBlbGVtZW50LnJpZ2h0LFxcbiAgICAgICAgICAgIGxfaW5mbyA9IGxlZnQuaW5mbyxcXG4gICAgICAgICAgICByX2luZm8gPSByaWdodC5pbmZvLFxcbiAgICAgICAgICAgIGxfZGF0YSA9IGxlZnQuZGF0YSxcXG4gICAgICAgICAgICByX2RhdGEgPSByaWdodC5kYXRhO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgLy8gTWlkLXNpZGUgc3RlcmVvXFxuICAgICAgICBpZiAoZWxlbWVudC5jb21tb25XaW5kb3cgJiYgZWxlbWVudC5tYXNrUHJlc2VudClcXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NNUyhlbGVtZW50LCBsX2RhdGEsIHJfZGF0YSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICBpZiAocHJvZmlsZSA9PT0gQU9UX0FBQ19NQUlOKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiTWFpbiBwcmVkaWN0aW9uIHVuaW1wbGVtZW50ZWRcXFwiKTtcXG4gICAgICAgIFxcbiAgICAgICAgLy8gSW50ZW5zaXR5IHN0ZXJlbyAgICBcXG4gICAgICAgIHRoaXMucHJvY2Vzc0lTKGVsZW1lbnQsIGxfZGF0YSwgcl9kYXRhKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgIGlmIChwcm9maWxlID09PSBBT1RfQUFDX0xUUClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkxUUCBwcmVkaWN0aW9uIHVuaW1wbGVtZW50ZWRcXFwiKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgIHRoaXMuYXBwbHlDaGFubmVsQ291cGxpbmcoZWxlbWVudCwgQ0NFRWxlbWVudC5CRUZPUkVfVE5TLCBsX2RhdGEsIHJfZGF0YSk7XFxuICAgICAgICBcXG4gICAgICAgIGlmIChsZWZ0LnRuc1ByZXNlbnQpXFxuICAgICAgICAgICAgbGVmdC50bnMucHJvY2VzcyhsZWZ0LCBsX2RhdGEsIGZhbHNlKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgIGlmIChyaWdodC50bnNQcmVzZW50KVxcbiAgICAgICAgICAgIHJpZ2h0LnRucy5wcm9jZXNzKHJpZ2h0LCByX2RhdGEsIGZhbHNlKTtcXG4gICAgICAgIFxcbiAgICAgICAgdGhpcy5hcHBseUNoYW5uZWxDb3VwbGluZyhlbGVtZW50LCBDQ0VFbGVtZW50LkFGVEVSX1ROUywgbF9kYXRhLCByX2RhdGEpO1xcbiAgICAgICAgXFxuICAgICAgICAvLyBmaWx0ZXJiYW5rXFxuICAgICAgICB0aGlzLmZpbHRlcl9iYW5rLnByb2Nlc3MobF9pbmZvLCBsX2RhdGEsIHRoaXMuZGF0YVtjaGFubmVsXSwgY2hhbm5lbCk7XFxuICAgICAgICB0aGlzLmZpbHRlcl9iYW5rLnByb2Nlc3Mocl9pbmZvLCByX2RhdGEsIHRoaXMuZGF0YVtjaGFubmVsICsgMV0sIGNoYW5uZWwgKyAxKTtcXG4gICAgICAgIFxcbiAgICAgICAgaWYgKHByb2ZpbGUgPT09IEFPVF9BQUNfTFRQKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiTFRQIHByZWRpY3Rpb24gdW5pbXBsZW1lbnRlZFxcXCIpO1xcbiAgICAgICAgXFxuICAgICAgICB0aGlzLmFwcGx5Q2hhbm5lbENvdXBsaW5nKGVsZW1lbnQsIENDRUVsZW1lbnQuQUZURVJfSU1EQ1QsIHRoaXMuZGF0YVtjaGFubmVsXSwgdGhpcy5kYXRhW2NoYW5uZWwgKyAxXSk7XFxuICAgICAgICBcXG4gICAgICAgIGlmIChsZWZ0LmdhaW5QcmVzZW50KVxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiR2FpbiBjb250cm9sIG5vdCBpbXBsZW1lbnRlZFxcXCIpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgaWYgKHJpZ2h0LmdhaW5QcmVzZW50KVxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiR2FpbiBjb250cm9sIG5vdCBpbXBsZW1lbnRlZFxcXCIpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgaWYgKHRoaXMuc2JyUHJlc2VudClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlNCUiBub3QgaW1wbGVtZW50ZWRcXFwiKTtcXG4gICAgfTtcXG4gICAgXFxuICAgIC8vIEludGVuc2l0eSBzdGVyZW9cXG4gICAgdGhpcy5wcm90b3R5cGUucHJvY2Vzc0lTID0gZnVuY3Rpb24oZWxlbWVudCwgbGVmdCwgcmlnaHQpIHtcXG4gICAgICAgIHZhciBpY3MgPSBlbGVtZW50LnJpZ2h0LFxcbiAgICAgICAgICAgIGluZm8gPSBpY3MuaW5mbyxcXG4gICAgICAgICAgICBvZmZzZXRzID0gaW5mby5zd2JPZmZzZXRzLFxcbiAgICAgICAgICAgIHdpbmRvd0dyb3VwcyA9IGluZm8uZ3JvdXBDb3VudCxcXG4gICAgICAgICAgICBtYXhTRkIgPSBpbmZvLm1heFNGQixcXG4gICAgICAgICAgICBiYW5kVHlwZXMgPSBpY3MuYmFuZFR5cGVzLFxcbiAgICAgICAgICAgIHNlY3RFbmQgPSBpY3Muc2VjdEVuZCxcXG4gICAgICAgICAgICBzY2FsZUZhY3RvcnMgPSBpY3Muc2NhbGVGYWN0b3JzO1xcbiAgICAgICAgXFxuICAgICAgICB2YXIgaWR4ID0gMCwgZ3JvdXBPZmYgPSAwO1xcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCB3aW5kb3dHcm91cHM7IGcrKykge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4U0ZCOykge1xcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gc2VjdEVuZFtpZHhdO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgaWYgKGJhbmRUeXBlc1tpZHhdID09PSBJQ1N0cmVhbS5JTlRFTlNJVFlfQlQgfHwgYmFuZFR5cGVzW2lkeF0gPT09IElDU3RyZWFtLklOVEVOU0lUWV9CVDIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZW5kOyBpKyssIGlkeCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBiYW5kVHlwZXNbaWR4XSA9PT0gSUNTdHJlYW0uSU5URU5TSVRZX0JUID8gMSA6IC0xO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm1hc2tQcmVzZW50KVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICo9IGVsZW1lbnQubXNfdXNlZFtpZHhdID8gLTEgOiAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBjICogc2NhbGVGYWN0b3JzW2lkeF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBpbmZvLmdyb3VwTGVuZ3RoW2ddOyB3KyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZiA9IGdyb3VwT2ZmICsgdyAqIDEyOCArIG9mZnNldHNbaV0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBvZmZzZXRzW2kgKyAxXSAtIG9mZnNldHNbaV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRbb2ZmICsgal0gPSBsZWZ0W29mZiArIGpdICogc2NhbGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSAge1xcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IGVuZCAtIGk7XFxuICAgICAgICAgICAgICAgICAgICBpID0gZW5kO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGdyb3VwT2ZmICs9IGluZm8uZ3JvdXBMZW5ndGhbZ10gKiAxMjg7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICAvLyBNaWQtc2lkZSBzdGVyZW9cXG4gICAgdGhpcy5wcm90b3R5cGUucHJvY2Vzc01TID0gZnVuY3Rpb24oZWxlbWVudCwgbGVmdCwgcmlnaHQpIHtcXG4gICAgICAgIHZhciBpY3MgPSBlbGVtZW50LmxlZnQsXFxuICAgICAgICAgICAgaW5mbyA9IGljcy5pbmZvLFxcbiAgICAgICAgICAgIG9mZnNldHMgPSBpbmZvLnN3Yk9mZnNldHMsXFxuICAgICAgICAgICAgd2luZG93R3JvdXBzID0gaW5mby5ncm91cENvdW50LFxcbiAgICAgICAgICAgIG1heFNGQiA9IGluZm8ubWF4U0ZCLFxcbiAgICAgICAgICAgIHNmYkNCbCA9IGljcy5iYW5kVHlwZXMsXFxuICAgICAgICAgICAgc2ZiQ0JyID0gZWxlbWVudC5yaWdodC5iYW5kVHlwZXM7XFxuICAgICAgICAgICAgXFxuICAgICAgICB2YXIgZ3JvdXBPZmYgPSAwLCBpZHggPSAwO1xcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCB3aW5kb3dHcm91cHM7IGcrKykge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4U0ZCOyBpKyssIGlkeCsrKSB7XFxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm1zX3VzZWRbaWR4XSAmJiBzZmJDQmxbaWR4XSA8IElDU3RyZWFtLk5PSVNFX0JUICYmIHNmYkNCcltpZHhdIDwgSUNTdHJlYW0uTk9JU0VfQlQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgaW5mby5ncm91cExlbmd0aFtnXTsgdysrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZiA9IGdyb3VwT2ZmICsgdyAqIDEyOCArIG9mZnNldHNbaV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvZmZzZXRzW2kgKyAxXSAtIG9mZnNldHNbaV07IGorKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGxlZnRbb2ZmICsgal0gLSByaWdodFtvZmYgKyBqXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFtvZmYgKyBqXSArPSByaWdodFtvZmYgKyBqXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRbb2ZmICsgal0gPSB0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBncm91cE9mZiArPSBpbmZvLmdyb3VwTGVuZ3RoW2ddICogMTI4O1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBcXG4gICAgdGhpcy5wcm90b3R5cGUuYXBwbHlDaGFubmVsQ291cGxpbmcgPSBmdW5jdGlvbihlbGVtZW50LCBjb3VwbGluZ1BvaW50LCBkYXRhMSwgZGF0YTIpIHtcXG4gICAgICAgIHZhciBjY2VzID0gdGhpcy5jY2VzLFxcbiAgICAgICAgICAgIGlzQ2hhbm5lbFBhaXIgPSBlbGVtZW50IGluc3RhbmNlb2YgQ1BFRWxlbWVudCxcXG4gICAgICAgICAgICBhcHBseUNvdXBsaW5nID0gY291cGxpbmdQb2ludCA9PT0gQ0NFRWxlbWVudC5BRlRFUl9JTURDVCA/ICdhcHBseUluZGVwZW5kZW50Q291cGxpbmcnIDogJ2FwcGx5RGVwZW5kZW50Q291cGxpbmcnO1xcbiAgICAgICAgXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNjZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICB2YXIgY2NlID0gY2Nlc1tpXSxcXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICBpZiAoY2NlLmNvdXBsaW5nUG9pbnQgPT09IGNvdXBsaW5nUG9pbnQpIHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjY2UuY291cGxlZENvdW50OyBjKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaFNlbGVjdCA9IGNjZS5jaFNlbGVjdFtjXTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjY2UuY2hhbm5lbFBhaXJbY10gPT09IGlzQ2hhbm5lbFBhaXIgJiYgY2NlLmlkU2VsZWN0W2NdID09PSBlbGVtZW50LmlkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoU2VsZWN0ICE9PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjZVthcHBseUNvdXBsaW5nXShpbmRleCwgZGF0YTEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hTZWxlY3QpIGluZGV4Kys7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaFNlbGVjdCAhPT0gMilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2NlW2FwcGx5Q291cGxpbmddKGluZGV4KyssIGRhdGEyKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDEgKyAoY2hTZWxlY3QgPT09IDMgPyAxIDogMCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFxcbn0pO1xcblxcbn0pKCk7XFxuXCI7XG5cbnZhciBjb2RlID0gYXVyb3JhICsgYWFjICsgd29ya2VyO1xuXG52YXIgc2xhdmUgPSB1bmRlZmluZWQgXG52YXIgaWQgPSAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1hc3RlciwgdXJpLCBjYil7XG4gICAgdmFyIG1hc3RlciA9IG1hc3RlcjtcbiAgICB2YXIgc291cmNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgc2xhdmUgPSBzbGF2ZSB8fCBlbnNsYXZlKGNvZGUpO1xuXG4gICAgc2xhdmUucG9zdE1lc3NhZ2Uoe2lkOiBpZCsrLCB1cmk6IHVyaSwgc2FtcGxlUmF0ZTogbWFzdGVyLnNhbXBsZVJhdGV9KTtcblxuICAgIHNsYXZlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2dCl7XG5cdGlmKGV2dC5kYXRhLnR5cGUgPT0gJ21ldGEnKXtcblxuXHQgICAgdmFyIGRhdGEgPSBldnQuZGF0YS5kYXRhO1xuXHQgICAgc291cmNlLmRhdGEgPSBkYXRhO1xuXHQgICAgc291cmNlLmJ1ZmZlcnMgPSBuZXcgQXJyYXkoZGF0YS5jaGFubmVsc1BlckZyYW1lKTtcblxuXHQgICAgZm9yKHZhciB4ID0gMDsgeCA8IHNvdXJjZS5idWZmZXJzLmxlbmd0aDsgeCsrKXtcblx0XHRzb3VyY2UuYnVmZmVyc1t4XSA9IGJ1ZmZlcnMoNik7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHQgICAgdmFyIGJ1ZlNpemUgPSAyNTYgKiAyICogMiAqIDIgKiAyICogMjtcblxuXHQgICAgdmFyIHN5bnRoID0gbWFzdGVyLmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihidWZTaXplLCBkYXRhLmNoYW5uZWxzUGVyRnJhbWUsIGRhdGEuY2hhbm5lbHNQZXJGcmFtZSk7XG5cdCAgICBzeW50aC5idWZTaXplID0gYnVmU2l6ZTtcblx0ICAgIHN5bnRoLmJ1ZkluZGV4ID0gMDtcblx0ICAgIHN5bnRoLmlkID0gaWQ7XG5cdCAgICBzeW50aC5jdXJyZW50VGltZSA9IGZ1bmN0aW9uKHQpey8vIHQgaW4gc2Vjb25kc1xuXHRcdHN5bnRoLmJ1ZkluZGV4ID0gdCAqIG1hc3Rlci5zYW1wbGVSYXRlXG5cdCAgICB9O1xuXG5cdCAgICBzeW50aC5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uKGV2dCl7XG5cdFx0dmFyIG91dHB1dEJ1ZmZlciA9IGV2ZW50Lm91dHB1dEJ1ZmZlcjtcblx0XHR2YXIgY2hhbm5lbENvdW50ID0gb3V0cHV0QnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG5cdFx0dmFyIGNoYW5uZWxzID0gbmV3IEFycmF5KGNoYW5uZWxDb3VudCk7XG5cdFx0Zm9yIChpID0gX2kgPSAwOyBfaSA8IGNoYW5uZWxDb3VudDsgaSA9IF9pICs9IDEpIHtcblx0XHQgICAgY2hhbm5lbHNbaV0gPSBvdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSk7XG5cdFx0fVxuXHRcdGZvcih2YXIgeCA9IDA7IHggPCBjaGFubmVscy5sZW5ndGg7IHgrKyl7XG5cdFx0ICAgIGNoYW5uZWxzW3hdLnNldChzb3VyY2UuYnVmZmVyc1t4XS5zbGljZSh0aGlzLmJ1ZkluZGV4LCB0aGlzLmJ1ZkluZGV4ICsgdGhpcy5idWZTaXplKSk7XG5cdFx0fVxuXHRcdHRoaXMuYnVmSW5kZXgrPXRoaXMuYnVmU2l6ZVxuXHQgICAgfTtcblxuXHQgICAgY2IobnVsbCwgc3ludGgpXG5cblx0fVxuXHRlbHNlIGlmKGV2dC5kYXRhLnR5cGUgPT0gJ2VuZCcpe1xuXG4vL1x0ICAgIGFsZXJ0KChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSkgLyAxMDAwKVxuXHR9XG5cdGVsc2UgaWYoZXZ0LmRhdGEudHlwZSA9PSAncHJvZ3Jlc3MnKXtcblx0ICAgIGNvbnNvbGUubG9nKGV2dC5kYXRhLmRhdGEpO1xuXHR9XG5cdGVsc2Uge1xuXHQgICAgdmFyIHdzYiA9IHNvdXJjZS5idWZmZXJzO1xuXHQgICAgZm9yKHggaW4gZXZ0LmRhdGEuYnVmZmVyKXtcblx0XHR3c2JbeF0ucHVzaChldnQuZGF0YS5idWZmZXJbeF0pO1xuXHQgICAgfVxuXHR9XG4gICAgfVxuXG5cbn1cblxuXG59KSgpIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjc3MsIGlkKXtcbiAgICB2YXIgZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICBpZihlcyl7XG5cdHJldHVybiBmYWxzZVxuLy9cdGVzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG1ha2VTdHlsZShjc3MpLCBlcy5uZXh0U2libGluZylcbiAgICB9XG4gICAgZWxzZXtcblx0dmFyIHN0eWxlU2hlZXQgPSBtYWtlU3R5bGUoY3NzLCBpZClcblx0ZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVTaGVldCwgZG9jdW1lbnQuaGVhZC5jaGlsZE5vZGVzWzBdKTtcblx0cmV0dXJuIHN0eWxlU2hlZXRcbiAgICB9XG5cbn1cblxuXG5mdW5jdGlvbiBtYWtlU3R5bGUoc3RyLCBpZCl7XG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pZCA9IGlkIHx8ICcnO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3RyO1xuICAgIHJldHVybiBzdHlsZVxufVxuIiwidmFyIGdldENTUyA9IHJlcXVpcmUoJy4vZ2V0Q1NTJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwpe1xuICAgIFxuICAgIGVsLnN0eWxlWyctd2Via2l0LWJveC1zaXppbmcnXSA9ICdib3JkZXItYm94J1xuICAgIGVsLnBhcmVudEVsZW1lbnQuc3R5bGVbJy13ZWJraXQtYm94LXNpemluZyddID0gJ2JvcmRlci1ib3gnXG4gICAgZWwuc3R5bGVbJ2JveC1zaXppbmcnXSA9ICdib3JkZXItYm94J1xuICAgIGVsLnBhcmVudEVsZW1lbnQuc3R5bGVbJ2JveC1zaXppbmcnXSA9ICdib3JkZXItYm94J1xuXG4gICAgdmFyIHcgPSBnZXRDU1MoZWwsICd3aWR0aCcpLnByaW1pdGl2ZS52YWxcbiAgICAsICAgaCA9IGdldENTUyhlbCwgJ2hlaWdodCcpLnByaW1pdGl2ZS52YWxcbiAgICA7XG4gICAgXG4gICAgdmFyIHB3ID0gZ2V0Q1NTKGVsLnBhcmVudEVsZW1lbnQsICd3aWR0aCcpLnByaW1pdGl2ZS52YWxcbiAgICAsICAgcGggPSBnZXRDU1MoZWwucGFyZW50RWxlbWVudCwgJ2hlaWdodCcpLnByaW1pdGl2ZS52YWxcbiAgICA7XG5cbiAgICB2YXIgZHcgPSBwdyAtIHdcbiAgICAsICAgZGggPSBwaCAtIGhcbiAgICA7XG4gICAgXG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsLnN0eWxlWyd0b3AnXSA9IGRoLzIgKyAncHgnO1xuICAgIGVsLnN0eWxlWydsZWZ0J10gPSBkdy8yICsgJ3B4JztcblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCwgcGFyYW0pe1xuXG4gICAgdmFyIHByb3BWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eUNTU1ZhbHVlKHBhcmFtKVxuXHRcdGlmKCFwcm9wVmFsdWUpIHRocm93IG5ldyBFcnJvcihcIk5vIHByb3AgdmFsdWVWYWx1ZS4gSXMgdGhlIGVsZW1lbnQgYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50IHlldD9cIilcblx0XHRpZighcHJvcFZhbHVlKSByZXR1cm4gZmFsc2VcbiAgICB2YXIgdmFsdWVUeXBlID0gJyc7XG5cdFx0Zm9yKHZhciBiIGluIHByb3BWYWx1ZS5fX3Byb3RvX18pe1xuXHRcdFx0aWYocHJvcFZhbHVlLl9fcHJvdG9fX1tiXSA9PSBwcm9wVmFsdWUuY3NzVmFsdWVUeXBlKSB7XG5cdFx0XHRcdHZhbHVlVHlwZSA9IGI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuICAgIHN3aXRjaCh2YWx1ZVR5cGUudG9Mb3dlckNhc2UoKSl7XG4gICAgY2FzZSAnY3NzdmFsdWVsaXN0Jzpcblx0dmFyIGwgPSBwcm9wVmFsdWUubGVuZ3RoO1xuICAgICAgICB2YXIgb2JqID0ge307XG5cdG9iai50eXBlID0gJ2Nzc1ByaW1pdGl2ZVZhbHVlJ1xuXHRvYmoudmFsdWUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwcm9wVmFsdWUpLm1hcChmdW5jdGlvbih4KXsgcmV0dXJuIENTU0dldFByaW1pdGl2ZVZhbHVlKHgpfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG5cdGJyZWFrO1xuICAgIGNhc2UgJ2Nzc3ByaW1pdGl2ZXZhbHVlJzpcblx0cmV0dXJuIHt0eXBlOiAnY3NzUHJpbWl0aXZlVmFsdWUnLCB2YWx1ZSA6IENTU0dldFByaW1pdGl2ZVZhbHVlKHByb3BWYWx1ZSl9O1xuXHRicmVhaztcbiAgICBjYXNlICdzdmdwYWludCc6XG5cdHJldHVybiB7dHlwZTogJ1NWR1BhaW50JywgdmFsdWUgOiBDU1NHZXRQcmltaXRpdmVWYWx1ZShwcm9wVmFsdWUpfTtcblx0YnJlYWs7XG5cdCBkZWZhdWx0OlxuXHRyZXR1cm4ge3R5cGU6ICdjc3NWYWx1ZScsIHByaW1pdGl2ZTogQ1NTR2V0UHJpbWl0aXZlVmFsdWUocHJvcFZhbHVlKSwgdmFsdWUgOiB7dW5pdDogJycsIHR5cGU6IHByb3BWYWx1ZS5jc3NWYWx1ZVR5cGUsIHZhbDogcHJvcFZhbHVlLmNzc1RleHR9fTtcblx0YnJlYWs7XG4gICAgfVxuXG59O1xuXG5mdW5jdGlvbiBDU1NHZXRQcmltaXRpdmVWYWx1ZSh2YWx1ZSkge1xuXHRcdHRyeSB7XG5cblx0XHRcdFx0dmFyIHZhbHVlVHlwZSA9IHZhbHVlLnByaW1pdGl2ZVR5cGU7XG5cblx0XHRcdCAgaWYgKENTU1ByaW1pdGl2ZVZhbHVlLkNTU19QWCA9PSB2YWx1ZVR5cGUpIHtcblx0XHRcdFx0XHRyZXR1cm4ge2NsYXNzOiBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfUFgsIHVuaXQgOiAncHgnLCB0eXBlOiAnZmxvYXQnLCB2YWwgOiB2YWx1ZS5nZXRGbG9hdFZhbHVlICh2YWx1ZVR5cGUpfTtcblx0XHRcdCAgfVxuXG5cdFx0XHQgIGlmICh2YWx1ZVR5cGUgPT0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX05VTUJFUikge1xuXHRcdFx0XHRcdHJldHVybiB7Y2xhc3M6IENTU1ByaW1pdGl2ZVZhbHVlLkNTU19OVU1CRVIsIHVuaXQgOiAnJywgdHlwZTogJ2Zsb2F0JywgdmFsIDogdmFsdWUuZ2V0RmxvYXRWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHQgIH1cblxuXHRcdFx0ICBpZiAodmFsdWVUeXBlID09IENTU1ByaW1pdGl2ZVZhbHVlLkNTU19QRVJDRU5UQUdFKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1BFUkNFTlRBR0UsIHVuaXQgOiAnJScsIHR5cGU6ICdmbG9hdCcsIHZhbCA6IHZhbHVlLmdldEZsb2F0VmFsdWUgKHZhbHVlVHlwZSl9O1xuXHRcdFx0ICB9XG5cblx0XHRcdCAgaWYgKENTU1ByaW1pdGl2ZVZhbHVlLkNTU19FTVMgPT0gdmFsdWVUeXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0VNUywgdW5pdCA6ICdlbScsIHR5cGU6ICdmbG9hdCcsIHZhbCA6IHZhbHVlLmdldEZsb2F0VmFsdWUgKHZhbHVlVHlwZSl9O1xuXHRcdFx0ICB9XG5cblx0XHRcdCAgaWYgKENTU1ByaW1pdGl2ZVZhbHVlLkNTU19DTSA9PSB2YWx1ZVR5cGUpIHtcblx0XHRcdFx0XHRyZXR1cm4ge2NsYXNzOiBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfQ00sIHVuaXQgOiAnY20nLCB0eXBlOiAnZmxvYXQnLCB2YWwgOiB2YWx1ZS5nZXRGbG9hdFZhbHVlICh2YWx1ZVR5cGUpfTtcblx0XHRcdCAgfVxuXG5cdFx0XHQgIGlmIChDU1NQcmltaXRpdmVWYWx1ZS5DU1NfSURFTlQgPT0gdmFsdWVUeXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0lERU5ULCB1bml0IDogJycsIHR5cGU6ICdzdHJpbmcnLCB2YWwgOiB2YWx1ZS5nZXRTdHJpbmdWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHQgIH1cblxuXHRcdFx0ICBpZiAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0VYUyA9PSB2YWx1ZVR5cGUpIHtcblx0XHRcdFx0XHRyZXR1cm4ge2NsYXNzOiBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfRVhTLCB1bml0IDogJ2V4JywgdHlwZTogJ2Zsb2F0JywgdmFsIDogdmFsdWUuZ2V0RmxvYXRWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHQgIH1cblxuXHRcdFx0ICBpZiAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0lOID09IHZhbHVlVHlwZSkge1xuXHRcdFx0XHRcdHJldHVybiB7Y2xhc3M6IENTU1ByaW1pdGl2ZVZhbHVlLkNTU19JTiwgdW5pdCA6ICdpbicsIHR5cGU6ICdmbG9hdCcsIHZhbCA6IHZhbHVlLmdldEZsb2F0VmFsdWUgKHZhbHVlVHlwZSl9O1xuXHRcdFx0ICB9XG5cblx0XHRcdCAgaWYgKENTU1ByaW1pdGl2ZVZhbHVlLkNTU19NTSA9PSB2YWx1ZVR5cGUpIHtcblx0XHRcdFx0XHRyZXR1cm4ge2NsYXNzOiBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfTU0sIHVuaXQgOiAnbW0nLCB0eXBlOiAnZmxvYXQnLCB2YWwgOiB2YWx1ZS5nZXRGbG9hdFZhbHVlICh2YWx1ZVR5cGUpfTtcblx0XHRcdCAgfVxuXG5cdFx0XHQgIGlmIChDU1NQcmltaXRpdmVWYWx1ZS5DU1NfUEMgPT0gdmFsdWVUeXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1BDLCB1bml0IDogJ3BjJywgdHlwZTogJ2Zsb2F0JywgdmFsIDogdmFsdWUuZ2V0RmxvYXRWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHQgIH1cblxuXHRcdFx0ICBpZiAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1BUID09IHZhbHVlVHlwZSkge1xuXHRcdFx0XHRcdHJldHVybiB7Y2xhc3M6IENTU1ByaW1pdGl2ZVZhbHVlLkNTU19QVCwgdW5pdCA6ICdwdCcsIHR5cGU6ICdmbG9hdCcsIHZhbCA6IHZhbHVlLmdldEZsb2F0VmFsdWUgKHZhbHVlVHlwZSl9O1xuXHRcdFx0ICB9XG5cblx0XHRcdCBcdGlmICh2YWx1ZVR5cGUgPT0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0RJTUVOU0lPTil7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0RJTUVOU0lPTiwgdW5pdCA6ICcnLCB0eXBlOiAnZmxvYXQnLCB2YWwgOiB2YWx1ZS5nZXRGbG9hdFZhbHVlICh2YWx1ZVR5cGUpfTtcblx0XHRcdFx0fVxuXG5cdFx0XHQgIGlmIChDU1NQcmltaXRpdmVWYWx1ZS5DU1NfU1RSSU5HIDw9IHZhbHVlVHlwZSAmJiB2YWx1ZVR5cGUgPD0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0FUVFIpIHtcblx0XHRcdCAgICAgcmV0dXJuIHt1bml0IDogJycsIHR5cGU6ICdzdHJpbmcnLCB2YWw6IHZhbHVlLmdldFN0cmluZ1ZhbHVlICh2YWx1ZVR5cGUpfTtcblx0XHRcdCAgfVxuXG5cdFx0XHQgIGlmICh2YWx1ZVR5cGUgPT0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0NPVU5URVIpIHtcblx0XHRcdCAgICB2YXIgY291bnRlclZhbHVlID0gdmFsdWUuZ2V0Q291bnRlclZhbHVlICgpO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0NPVU5URVIsXG5cdFx0XHRcdFx0XHR1bml0OiAnJyxcblx0XHRcdFx0XHRcdHR5cGU6ICdjb3VudGVyJyxcblx0XHRcdFx0XHRcdHZhbCA6IHtcblx0XHRcdFx0XHRcdFx0aWRlbnRpZmllcjogY291bnRlclZhbHVlLmlkZW50aWZpZXIsXG5cdFx0XHRcdFx0XHRcdGxpc3RTdHlsZTogY291bnRlclZhbHVlLmxpc3RTdHlsZSxcblx0XHRcdFx0XHRcdFx0c2VwYXJhdG9yOiBjb3VudGVyVmFsdWUuc2VwYXJhdG9yXG5cdFx0XHRcdFx0XHR9fTtcblx0XHRcdCAgIH1cblxuXHRcdFx0ICAgaWYgKHZhbHVlVHlwZSA9PSBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfUkVDVCkge1xuXHRcdFx0ICAgICAgdmFyIHJlY3QgPSB2YWx1ZS5nZXRSZWN0VmFsdWUgKClcblx0XHRcdCAgICAgICBcdCxcdHRvcFBYID0gcmVjdC50b3AuZ2V0RmxvYXRWYWx1ZSAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1BYKVxuXHRcdFx0ICAgICAgIFx0LFx0cmlnaHRQWCA9IHJlY3QucmlnaHQuZ2V0RmxvYXRWYWx1ZSAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1BYKVxuXHRcdFx0ICAgICAgIFx0LFx0Ym90dG9tUFggPSByZWN0LmJvdHRvbS5nZXRGbG9hdFZhbHVlIChDU1NQcmltaXRpdmVWYWx1ZS5DU1NfUFgpXG5cdFx0XHQgICAgICAgXHQsXHRsZWZ0UFggPSByZWN0LmxlZnQuZ2V0RmxvYXRWYWx1ZSAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1BYKVxuXHRcdFx0XHRcdFx0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6IENTU1ByaW1pdGl2ZVZhbHVlLkNTU19SRUNULFxuXHRcdFx0XHRcdFx0XHR1bml0OiAncHgnLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiAncmVjdCcsXG5cdFx0XHRcdFx0XHRcdHZhbDoge1xuXHRcdFx0XHRcdFx0XHRcdHRvcDogdG9wUFgsXG5cdFx0XHRcdFx0XHRcdFx0cmlnaHQ6IHJpZ2h0UFgsXG5cdFx0XHRcdFx0XHRcdFx0Ym90dG9tOiBib3R0b21QWCxcblx0XHRcdFx0XHRcdFx0XHRsZWZ0OiBsZWZ0UFhcblx0XHRcdFx0XHRcdFx0fX07XG5cdFx0XHQgICB9XG5cblx0XHRcdCAgIGlmICh2YWx1ZVR5cGUgPT0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1JHQkNPTE9SKSB7XG5cdFx0XHQgICAgICB2YXIgcmdiID0gdmFsdWUuZ2V0UkdCQ29sb3JWYWx1ZSAoKVxuXHRcdFx0ICAgICAgIFx0LFx0ciA9IHJnYi5yZWQuZ2V0RmxvYXRWYWx1ZSAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX05VTUJFUilcblx0XHRcdCAgICAgICBcdCxcdGcgPSByZ2IuZ3JlZW4uZ2V0RmxvYXRWYWx1ZSAoQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX05VTUJFUilcblx0XHRcdCAgICAgICBcdCwgYiA9IHJnYi5ibHVlLmdldEZsb2F0VmFsdWUgKENTU1ByaW1pdGl2ZVZhbHVlLkNTU19OVU1CRVIpXG5cdFx0XHRcdFx0XHQ7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfUkdCQ09MT1IsXG5cdFx0XHRcdFx0XHRcdHVuaXQ6ICcnLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiAncmdiJyxcblx0XHRcdFx0XHRcdFx0dmFsOiB7XG5cdFx0XHRcdFx0XHRcdFx0cjogcixcblx0XHRcdFx0XHRcdFx0XHRnOiBnLFxuXHRcdFx0XHRcdFx0XHRcdGI6IGIsXG5cdFx0XHRcdFx0XHRcdH19O1xuXHRcdFx0ICAgfVxuXG5cdFx0XHRcdGlmIChDU1NQcmltaXRpdmVWYWx1ZS5DU1NfR1JBRCA9PSB2YWx1ZVR5cGUgPj0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0RFRyApIHtcblx0XHRcdFx0XHRyZXR1cm4ge2NsYXNzOiBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfR1JBRCwgdW5pdCA6ICdncmFkJywgdHlwZTogJ2FuZ2xlJywgdmFsIDogdmFsdWUuZ2V0RmxvYXRWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZih2YWx1ZVR5cGUgPT0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX0RFRykge1xuXHRcdFx0XHRcdHJldHVybiB7Y2xhc3M6IENTU1ByaW1pdGl2ZVZhbHVlLkNTU19ERUcsIHVuaXQgOiAnZGVnJywgdHlwZTogJ2FuZ2xlJywgdmFsIDogdmFsdWUuZ2V0RmxvYXRWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZih2YWx1ZVR5cGUgPT0gQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1JBRCkge1xuXHRcdFx0XHRcdHJldHVybiB7Y2xhc3M6IENTU1ByaW1pdGl2ZVZhbHVlLkNTU19SQUQsIHVuaXQgOiAncmFkaWFuJywgdHlwZTogJ2FuZ2xlJywgdmFsIDogdmFsdWUuZ2V0RmxvYXRWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihDU1NQcmltaXRpdmVWYWx1ZS5DU1NfUyA9PSB2YWx1ZVR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX1MsIHVuaXQgOiAnJywgdHlwZTogJ3RpbWUnLCB2YWwgOiB2YWx1ZS5nZXRGbG9hdFZhbHVlICh2YWx1ZVR5cGUpfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKHZhbHVlVHlwZSA9PSBDU1NQcmltaXRpdmVWYWx1ZS5DU1NfTVMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogQ1NTUHJpbWl0aXZlVmFsdWUuQ1NTX01TLCB1bml0IDogJycsIHR5cGU6ICd0aW1lJywgdmFsIDogdmFsdWUuZ2V0RmxvYXRWYWx1ZSAodmFsdWVUeXBlKX07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZighdmFsdWVUeXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtjbGFzczogdW5kZWZpbmVkLCB1bml0IDogJycsIHR5cGU6ICd1bmtub3duJywgdmFsIDogdmFsdWUuY3NzVGV4dH07XG5cdFx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtjbGFzczogdW5kZWZpbmVkLCB1bml0IDogJycsIHR5cGU6ICd1bmtub3duJywgdmFsIDogdmFsdWUuY3NzVGV4dH07XG5cblx0XHR9XG5cblx0XHRjYXRjaCAoRXJyKXtcdCAgIFxuXHRcdFx0cmV0dXJuIHtjbGFzczogJ3Vua25vd24nLCB1bml0IDogJycsIHR5cGU6IHZhbHVlLnByb3BWYWx1ZS5fX3Byb3RvX18uY29uc3RydWN0b3IubmFtZSwgdmFsIDogdmFsdWUuY3NzVGV4dH07XG5cdFx0fVxufTtcbiIsIihmdW5jdGlvbigpe3ZhciBCdWZmZXIgPSBCdWZmZXI7XG5cbnZhciB0eXBlcyA9IFtcbiAgICBJbnQ4QXJyYXksXG4gICAgSW50MTZBcnJheSxcbiAgICBJbnQzMkFycmF5LFxuICAgIFVpbnQ4QXJyYXksXG4gICAgVWludDE2QXJyYXksXG4gICAgVWludDMyQXJyYXksXG4gICAgRmxvYXQzMkFycmF5LFxuICAgIEZsb2F0NjRBcnJheVxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJzO1xuXG5mdW5jdGlvbiBCdWZmZXJzIChidWZzLCB0eXBlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcnMpKSByZXR1cm4gbmV3IEJ1ZmZlcnMoYnVmcyk7XG4gICAgaWYgKCghdHlwZSAmJiAoIWlzTmFOKGJ1ZnMpKSkgfHwgIWlzTmFOKHR5cGUpKSB7XG5cdHR5cGUgPSBidWZzO1xuXHRidWZzID0gbnVsbDtcblx0QnVmZmVyID0gdHlwZXNbdHlwZV1cblx0dGhpcy5pc05vdEFOb2RlQnVmZmVyID0gdHJ1ZTtcblxuICAgIH07XG4gICAgdGhpcy5idWZmZXJzID0gYnVmcyB8fCBbXTtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmZmVycy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIGJ1Zikge1xuICAgICAgICByZXR1cm4gc2l6ZSArIGJ1Zi5sZW5ndGhcbiAgICB9LCAwKTtcbn1cblxuXG5CdWZmZXJzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkgeyAgICBcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1Zik7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMudW5zaGlmdChidWYpO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGRzdCwgZFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2Uoc3RhcnQsIGVuZCkuY29weShkc3QsIGRTdGFydCwgMCwgZW5kIC0gc3RhcnQpO1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gKGksIGhvd01hbnkpIHtcbiAgICB2YXIgYnVmZmVycyA9IHRoaXMuYnVmZmVycztcbiAgICB2YXIgaW5kZXggPSBpID49IDAgPyBpIDogdGhpcy5sZW5ndGggLSBpO1xuICAgIHZhciByZXBzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIFxuICAgIGlmIChob3dNYW55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaG93TWFueSA9IHRoaXMubGVuZ3RoIC0gaW5kZXg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhvd01hbnkgPiB0aGlzLmxlbmd0aCAtIGluZGV4KSB7XG4gICAgICAgIGhvd01hbnkgPSB0aGlzLmxlbmd0aCAtIGluZGV4O1xuICAgIH1cbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gcmVwc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIFxuICAgIHZhciByZW1vdmVkID0gbmV3IEJ1ZmZlcnMoKTtcbiAgICB2YXIgYnl0ZXMgPSAwO1xuICAgIFxuICAgIHZhciBzdGFydEJ5dGVzID0gMDtcbiAgICBmb3IgKFxuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICBpaSA8IGJ1ZmZlcnMubGVuZ3RoICYmIHN0YXJ0Qnl0ZXMgKyBidWZmZXJzW2lpXS5sZW5ndGggPCBpbmRleDtcbiAgICAgICAgaWkgKytcbiAgICApIHsgc3RhcnRCeXRlcyArPSBidWZmZXJzW2lpXS5sZW5ndGggfVxuICAgIFxuICAgIGlmIChpbmRleCAtIHN0YXJ0Qnl0ZXMgPiAwKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGluZGV4IC0gc3RhcnRCeXRlcztcbiAgICAgICAgXG4gICAgICAgIGlmIChzdGFydCArIGhvd01hbnkgPCBidWZmZXJzW2lpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChidWZmZXJzW2lpXS5zbGljZShzdGFydCwgc3RhcnQgKyBob3dNYW55KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBvcmlnID0gYnVmZmVyc1tpaV07XG4gICAgICAgICAgICAvL3ZhciBidWYgPSBuZXcgQnVmZmVyKG9yaWcubGVuZ3RoIC0gaG93TWFueSk7XG4gICAgICAgICAgICB2YXIgYnVmMCA9IG5ldyBCdWZmZXIoc3RhcnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmMFtpXSA9IG9yaWdbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBidWYxID0gbmV3IEJ1ZmZlcihvcmlnLmxlbmd0aCAtIHN0YXJ0IC0gaG93TWFueSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgKyBob3dNYW55OyBpIDwgb3JpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ1ZjFbIGkgLSBob3dNYW55IC0gc3RhcnQgXSA9IG9yaWdbaV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciByZXBzXyA9IHJlcHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICByZXBzXy51bnNoaWZ0KGJ1ZjApO1xuICAgICAgICAgICAgICAgIHJlcHNfLnB1c2goYnVmMSk7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5zcGxpY2UuYXBwbHkoYnVmZmVycywgWyBpaSwgMSBdLmNvbmNhdChyZXBzXykpO1xuICAgICAgICAgICAgICAgIGlpICs9IHJlcHNfLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXBzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXJzLnNwbGljZShpaSwgMSwgYnVmMCwgYnVmMSk7XG4gICAgICAgICAgICAgICAgLy9idWZmZXJzW2lpXSA9IGJ1ZjtcbiAgICAgICAgICAgICAgICBpaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGJ1ZmZlcnNbaWldLnNsaWNlKHN0YXJ0KSk7XG4gICAgICAgICAgICBidWZmZXJzW2lpXSA9IGJ1ZmZlcnNbaWldLnNsaWNlKDAsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlpICsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChyZXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnVmZmVycy5zcGxpY2UuYXBwbHkoYnVmZmVycywgWyBpaSwgMCBdLmNvbmNhdChyZXBzKSk7XG4gICAgICAgIGlpICs9IHJlcHMubGVuZ3RoO1xuICAgIH1cbiAgICBcbiAgICB3aGlsZSAocmVtb3ZlZC5sZW5ndGggPCBob3dNYW55KSB7XG4gICAgICAgIHZhciBidWYgPSBidWZmZXJzW2lpXTtcbiAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHZhciB0YWtlID0gTWF0aC5taW4obGVuLCBob3dNYW55IC0gcmVtb3ZlZC5sZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRha2UgPT09IGxlbikge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGJ1Zik7XG4gICAgICAgICAgICBidWZmZXJzLnNwbGljZShpaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goYnVmLnNsaWNlKDAsIHRha2UpKTtcbiAgICAgICAgICAgIGJ1ZmZlcnNbaWldID0gYnVmZmVyc1tpaV0uc2xpY2UodGFrZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5sZW5ndGggLT0gcmVtb3ZlZC5sZW5ndGg7XG4gICAgXG4gICAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuIFxuQnVmZmVycy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgIHZhciBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuICAgIGlmIChqID09PSB1bmRlZmluZWQpIGogPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAoaSA9PT0gdW5kZWZpbmVkKSBpID0gMDtcbiAgICBcbiAgICBpZiAoaiA+IHRoaXMubGVuZ3RoKSBqID0gdGhpcy5sZW5ndGg7XG4gICAgXG4gICAgdmFyIHN0YXJ0Qnl0ZXMgPSAwO1xuICAgIGZvciAoXG4gICAgICAgIHZhciBzaSA9IDA7XG4gICAgICAgIHNpIDwgYnVmZmVycy5sZW5ndGggJiYgc3RhcnRCeXRlcyArIGJ1ZmZlcnNbc2ldLmxlbmd0aCA8PSBpO1xuICAgICAgICBzaSArK1xuICAgICkgeyBzdGFydEJ5dGVzICs9IGJ1ZmZlcnNbc2ldLmxlbmd0aCB9XG4gICAgXG4gICAgdmFyIHRhcmdldCA9IG5ldyBCdWZmZXIoaiAtIGkpO1xuICAgIFxuICAgIHZhciB0aSA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSBzaTsgdGkgPCBqIC0gaSAmJiBpaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXJzW2lpXS5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RhcnQgPSB0aSA9PT0gMCA/IGkgLSBzdGFydEJ5dGVzIDogMDtcbiAgICAgICAgdmFyIGVuZCA9IHRpICsgbGVuID49IGogLSBpXG4gICAgICAgICAgICA/IE1hdGgubWluKHN0YXJ0ICsgKGogLSBpKSAtIHRpLCBsZW4pXG4gICAgICAgICAgICA6IGxlblxuICAgICAgICA7XG5cblx0aWYodGhpcy5pc05vdEFOb2RlQnVmZmVyKSB0YXJnZXQuc2V0KGJ1ZmZlcnNbaWldLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCB0aSk7XG5cbiAgICAgICAgZWxzZSBidWZmZXJzW2lpXS5jb3B5KHRhcmdldCwgdGksIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHRpICs9IGVuZCAtIHN0YXJ0O1xuXG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5CdWZmZXJzLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbiAoaSkge1xuICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICAgIHZhciBsID0gaSwgYmkgPSAwLCBidSA9IG51bGw7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBidSA9IHRoaXMuYnVmZmVyc1tiaV07XG4gICAgICAgIGlmIChsIDwgYnUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge2J1ZjogYmksIG9mZnNldDogbH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsIC09IGJ1Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBiaSsrO1xuICAgIH1cbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaSkge1xuICAgIHZhciBwb3MgPSB0aGlzLnBvcyhpKTtcbiAgICBpZih0aGlzLmlzTm90QU5vZGVCdWZmZXIpIHJldHVybiB0aGlzLmJ1ZmZlcnNbcG9zLmJ1Zl1bcG9zLm9mZnNldF1cbiAgICBlbHNlIHJldHVybiB0aGlzLmJ1ZmZlcnNbcG9zLmJ1Zl0uZ2V0KHBvcy5vZmZzZXQpO1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChpLCBiKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zKGkpO1xuICAgIGlmKHRoaXMuaXNOb3RBTm9kZUJ1ZmZlcikgcmV0dXJuIHRoaXMuYnVmZmVyc1twb3MuYnVmXVtwb3Mub2Zmc2V0XSA9IGJcbiAgICBlbHNlIHJldHVybiB0aGlzLmJ1ZmZlcnNbcG9zLmJ1Zl0uc2V0KHBvcy5vZmZzZXQsIGIpO1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChuZWVkbGUsIG9mZnNldCkge1xuICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmVlZGxlKSB7XG4gICAgICAgIG5lZWRsZSA9IG5ldyBCdWZmZXIobmVlZGxlKTtcbiAgICB9IGVsc2UgaWYgKG5lZWRsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAvLyBhbHJlYWR5IGEgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUgZm9yIGEgc2VhcmNoIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghbmVlZGxlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDAsIGogPSAwLCBtYXRjaCA9IDAsIG1zdGFydCwgcG9zID0gMDtcblxuICAgIC8vIHN0YXJ0IHNlYXJjaCBmcm9tIGEgcGFydGljdWxhciBwb2ludCBpbiB0aGUgdmlydHVhbCBidWZmZXJcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb3Mob2Zmc2V0KTtcbiAgICAgICAgaSA9IHAuYnVmO1xuICAgICAgICBqID0gcC5vZmZzZXQ7XG4gICAgICAgIHBvcyA9IG9mZnNldDtcbiAgICB9XG5cbiAgICAvLyBmb3IgZWFjaCBjaGFyYWN0ZXIgaW4gdmlydHVhbCBidWZmZXJcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIHdoaWxlIChqID49IHRoaXMuYnVmZmVyc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIHN0cmluZyBub3QgZm91bmRcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhciA9IHRoaXMuYnVmZmVyc1tpXVtqXTtcblxuICAgICAgICBpZiAoY2hhciA9PSBuZWVkbGVbbWF0Y2hdKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIHdoZXJlIG1hdGNoIHN0YXJ0ZWRcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbXN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHBvc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaCsrO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09IG5lZWRsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBmdWxsIG1hdGNoXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zdGFydC5wb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggIT0gMCkge1xuICAgICAgICAgICAgLy8gYSBwYXJ0aWFsIG1hdGNoIGVuZGVkLCBnbyBiYWNrIHRvIG1hdGNoIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY29udGludWUgdGhlIHNlYXJjaCBhdCB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGkgPSBtc3RhcnQuaTtcbiAgICAgICAgICAgIGogPSBtc3RhcnQuajtcbiAgICAgICAgICAgIHBvcyA9IG1zdGFydC5wb3M7XG4gICAgICAgICAgICBtYXRjaCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBqKys7XG4gICAgICAgIHBvcysrO1xuICAgIH1cbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoKTtcbn1cblxuQnVmZmVycy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cblxufSkoKSIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7dmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHRocm91Z2ggPSByZXF1aXJlKCd0aHJvdWdoJyk7XG52YXIgZHVwbGV4ZXIgPSByZXF1aXJlKCdkdXBsZXhlcicpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGVycXVlc3Q7XG5cbmZ1bmN0aW9uIGJpbmQgKG9iaiwgZm4pIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoeXBlcnF1ZXN0ICh1cmksIG9wdHMsIGNiLCBleHRyYSkge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjYiA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSB1cmk7XG4gICAgICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdHM7XG4gICAgICBvcHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodXJpICE9PSB1bmRlZmluZWQpIG9wdHMudXJpID0gdXJpO1xuICAgIGlmIChleHRyYSkgb3B0cy5tZXRob2QgPSBleHRyYS5tZXRob2Q7XG4gICAgXG4gICAgdmFyIHJlcSA9IG5ldyBSZXEob3B0cyk7XG4gICAgdmFyIHdzID0gcmVxLmR1cGxleCAmJiB0aHJvdWdoKCk7XG4gICAgaWYgKHdzKSB3cy5wYXVzZSgpO1xuICAgIHZhciBycyA9IHRocm91Z2goKTtcbiAgICBcbiAgICB2YXIgZHVwID0gcmVxLmR1cGxleCA/IGR1cGxleGVyKHdzLCBycykgOiBycztcbiAgICBpZiAoIXJlcS5kdXBsZXgpIHtcbiAgICAgICAgcnMud3JpdGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZHVwLnJlcXVlc3QgPSByZXE7XG4gICAgZHVwLnNldEhlYWRlciA9IGJpbmQocmVxLCByZXEuc2V0SGVhZGVyKTtcbiAgICBkdXAuc2V0TG9jYXRpb24gPSBiaW5kKHJlcSwgcmVxLnNldExvY2F0aW9uKTtcbiAgICBcbiAgICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gICAgZHVwLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHsgY2xvc2VkID0gdHJ1ZSB9KTtcbiAgICBcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgICAgICBkdXAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkgeyByLmRlc3Ryb3koKSB9KTtcbiAgICAgICAgXG4gICAgICAgIHZhciByID0gcmVxLl9zZW5kKCk7XG4gICAgICAgIHIub24oJ2Vycm9yJywgYmluZChkdXAsIGR1cC5lbWl0LCAnZXJyb3InKSk7XG4gICAgICAgIFxuICAgICAgICByLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIGR1cC5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgICAgIGR1cC5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG4gICAgICAgICAgICBpZiAocmVxLmR1cGxleCkgcmVzLnBpcGUocnMpXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoYnVmKSB7IHJzLnF1ZXVlKGJ1ZikgfSk7XG4gICAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7IHJzLnF1ZXVlKG51bGwpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXEuZHVwbGV4KSB7XG4gICAgICAgICAgICB3cy5waXBlKHIpO1xuICAgICAgICAgICAgd3MucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSByLmVuZCgpO1xuICAgIH0pO1xuICAgIFxuICAgIGlmIChjYikge1xuICAgICAgICBkdXAub24oJ2Vycm9yJywgY2IpO1xuICAgICAgICBkdXAub24oJ3Jlc3BvbnNlJywgYmluZChkdXAsIGNiLCBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBkdXA7XG59XG5cbmh5cGVycXVlc3QuZ2V0ID0gaHlwZXJxdWVzdDtcblxuaHlwZXJxdWVzdC5wb3N0ID0gZnVuY3Rpb24gKHVyaSwgb3B0cywgY2IpIHtcbiAgICByZXR1cm4gaHlwZXJxdWVzdCh1cmksIG9wdHMsIGNiLCB7IG1ldGhvZDogJ1BPU1QnIH0pO1xufTtcblxuaHlwZXJxdWVzdC5wdXQgPSBmdW5jdGlvbiAodXJpLCBvcHRzLCBjYikge1xuICAgIHJldHVybiBoeXBlcnF1ZXN0KHVyaSwgb3B0cywgY2IsIHsgbWV0aG9kOiAnUFVUJyB9KTtcbn07XG5cbmh5cGVycXVlc3RbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKHVyaSwgb3B0cywgY2IpIHtcbiAgICByZXR1cm4gaHlwZXJxdWVzdCh1cmksIG9wdHMsIGNiLCB7IG1ldGhvZDogJ0RFTEVURScgfSk7XG59O1xuXG5mdW5jdGlvbiBSZXEgKG9wdHMpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgXG4gICAgdmFyIG1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKTtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLmR1cGxleCA9ICEobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdERUxFVEUnKTtcbiAgICB0aGlzLmF1dGggPSBvcHRzLmF1dGg7XG4gICAgXG4gICAgaWYgKG9wdHMudXJpKSB0aGlzLnNldExvY2F0aW9uKG9wdHMudXJpKTtcbn1cblxuUmVxLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zZW50ID0gdHJ1ZTtcbiAgICBcbiAgICB2YXIgaGVhZGVycyA9IHRoaXMuaGVhZGVycyB8fCB7fTtcbiAgICB2YXIgdSA9IHVybC5wYXJzZSh0aGlzLnVyaSk7XG4gICAgdmFyIGF1ID0gdS5hdXRoIHx8IHRoaXMuYXV0aDtcbiAgICBpZiAoYXUpIHtcbiAgICAgICAgaGVhZGVycy5hdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBCdWZmZXIoYXUpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGludGVyZmFjZSA9ICh1LnByb3RvY29sID09PSAnaHR0cHM6JykgPyBodHRwcyA6IGh0dHA7XG4gICAgdmFyIHJlcSA9IGludGVyZmFjZS5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgaG9zdDogdS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogTnVtYmVyKHUucG9ydCksXG4gICAgICAgIHBhdGg6IHUucGF0aCxcbiAgICAgICAgYWdlbnQ6IGZhbHNlLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHJlcS5zZXRUaW1lb3V0KSByZXEuc2V0VGltZW91dChNYXRoLnBvdygyLCAzMikgKiAxMDAwKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuUmVxLnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zZW50KSB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVlc3QgYWxyZWFkeSBzZW50Jyk7XG4gICAgdGhpcy5oZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlcS5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikscmVxdWlyZShcIl9fYnJvd3NlcmlmeV9CdWZmZXJcIikuQnVmZmVyKSIsInZhciBTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpXG4gICAgLCB3cml0ZU1ldGhvZHMgPSBbXCJ3cml0ZVwiLCBcImVuZFwiLCBcImRlc3Ryb3lcIl1cbiAgICAsIHJlYWRNZXRob2RzID0gW1wicmVzdW1lXCIsIFwicGF1c2VcIl1cbiAgICAsIHJlYWRFdmVudHMgPSBbXCJkYXRhXCIsIFwiY2xvc2VcIl1cbiAgICAsIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cbm1vZHVsZS5leHBvcnRzID0gZHVwbGV4XG5cbmZ1bmN0aW9uIGZvckVhY2ggKGFyciwgZm4pIHtcbiAgaWYgKGFyci5mb3JFYWNoKSByZXR1cm4gYXJyLmZvckVhY2goZm4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmbihhcnJbaV0sIGkpXG59XG5cbmZ1bmN0aW9uIGR1cGxleCh3cml0ZXIsIHJlYWRlcikge1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgICAgICAgLCBlbmRlZCA9IGZhbHNlXG5cbiAgICBmb3JFYWNoKHdyaXRlTWV0aG9kcywgcHJveHlXcml0ZXIpXG5cbiAgICBmb3JFYWNoKHJlYWRNZXRob2RzLCBwcm94eVJlYWRlcilcblxuICAgIGZvckVhY2gocmVhZEV2ZW50cywgcHJveHlTdHJlYW0pXG5cbiAgICByZWFkZXIub24oXCJlbmRcIiwgaGFuZGxlRW5kKVxuXG4gICAgd3JpdGVyLm9uKFwiZHJhaW5cIiwgZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0uZW1pdChcImRyYWluXCIpXG4gICAgfSlcblxuICAgIHdyaXRlci5vbihcImVycm9yXCIsIHJlZW1pdClcbiAgICByZWFkZXIub24oXCJlcnJvclwiLCByZWVtaXQpXG5cbiAgICBzdHJlYW0ud3JpdGFibGUgPSB3cml0ZXIud3JpdGFibGVcbiAgICBzdHJlYW0ucmVhZGFibGUgPSByZWFkZXIucmVhZGFibGVcblxuICAgIHJldHVybiBzdHJlYW1cblxuICAgIGZ1bmN0aW9uIHByb3h5V3JpdGVyKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgc3RyZWFtW21ldGhvZE5hbWVdID0gbWV0aG9kXG5cbiAgICAgICAgZnVuY3Rpb24gbWV0aG9kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlclttZXRob2ROYW1lXS5hcHBseSh3cml0ZXIsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3h5UmVhZGVyKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgc3RyZWFtW21ldGhvZE5hbWVdID0gbWV0aG9kXG5cbiAgICAgICAgZnVuY3Rpb24gbWV0aG9kKCkge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQobWV0aG9kTmFtZSlcbiAgICAgICAgICAgIHZhciBmdW5jID0gcmVhZGVyW21ldGhvZE5hbWVdXG4gICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHJlYWRlciwgYXJndW1lbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLmVtaXQobWV0aG9kTmFtZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3h5U3RyZWFtKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgcmVhZGVyLm9uKG1ldGhvZE5hbWUsIHJlZW1pdClcblxuICAgICAgICBmdW5jdGlvbiByZWVtaXQoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG1ldGhvZE5hbWUpXG4gICAgICAgICAgICBzdHJlYW0uZW1pdC5hcHBseShzdHJlYW0sIGFyZ3MpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFbmQoKSB7XG4gICAgICAgIGlmIChlbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZW5kZWQgPSB0cnVlXG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgIGFyZ3MudW5zaGlmdChcImVuZFwiKVxuICAgICAgICBzdHJlYW0uZW1pdC5hcHBseShzdHJlYW0sIGFyZ3MpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVlbWl0KGVycikge1xuICAgICAgICBzdHJlYW0uZW1pdChcImVycm9yXCIsIGVycilcbiAgICB9XG59XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7dmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCkge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBidWZmZXIucHVzaChkYXRhKVxuICAgIGRyYWluKClcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICAvL3RoaXMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIHRoZSBmaXJzdCAnZW5kJyBsaXN0ZW5lclxuICAvL211c3QgY2FsbCBkZXN0cm95IG5leHQgdGljaywgdG8gbWFrZSBzdXJlIHdlJ3JlIGFmdGVyIGFueVxuICAvL3N0cmVhbSBwaXBlZCBmcm9tIGhlcmUuXG4gIC8vdGhpcyBpcyBvbmx5IGEgcHJvYmxlbSBpZiBlbmQgaXMgbm90IGVtaXR0ZWQgc3luY2hyb25vdXNseS5cbiAgLy9hIG5pY2VyIHdheSB0byBkbyB0aGlzIGlzIHRvIG1ha2Ugc3VyZSB0aGlzIGlzIHRoZSBsYXN0IGxpc3RlbmVyIGZvciAnZW5kJ1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgaWYoIXN0cmVhbS53cml0YWJsZSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHN0cmVhbS5lbWl0KCdwYXVzZScpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsInZhciBzcGxpdCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3BsaXQnKVxudmFyIENsYXNzTGlzdCA9IHJlcXVpcmUoJ2NsYXNzLWxpc3QnKVxudmFyIERhdGFTZXQgPSByZXF1aXJlKCdkYXRhLXNldCcpXG5cbm1vZHVsZS5leHBvcnRzID0gaFxuXG5mdW5jdGlvbiBoKCkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZSA9IG51bGxcbiAgZnVuY3Rpb24gaXRlbSAobCkge1xuICAgIHZhciByXG4gICAgZnVuY3Rpb24gcGFyc2VDbGFzcyAoc3RyaW5nKSB7XG4gICAgICB2YXIgbSA9IHNwbGl0KHN0cmluZywgLyhbXFwuI10/W2EtekEtWjAtOV8tXSspLylcbiAgICAgIGZvckVhY2gobSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHMgPSB2LnN1YnN0cmluZygxLHYubGVuZ3RoKVxuICAgICAgICBpZighdikgcmV0dXJuXG4gICAgICAgIGlmKCFlKVxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHYpXG4gICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcuJylcbiAgICAgICAgICBDbGFzc0xpc3QoZSkuYWRkKHMpXG4gICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcjJylcbiAgICAgICAgICBlLnNldEF0dHJpYnV0ZSgnaWQnLCBzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZihsID09IG51bGwpXG4gICAgICA7XG4gICAgZWxzZSBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgIGlmKCFlKVxuICAgICAgICBwYXJzZUNsYXNzKGwpXG4gICAgICBlbHNlXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwpKVxuICAgIH1cbiAgICBlbHNlIGlmKCdudW1iZXInID09PSB0eXBlb2YgbFxuICAgICAgfHwgJ2Jvb2xlYW4nID09PSB0eXBlb2YgbFxuICAgICAgfHwgbCBpbnN0YW5jZW9mIERhdGVcbiAgICAgIHx8IGwgaW5zdGFuY2VvZiBSZWdFeHAgKSB7XG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwudG9TdHJpbmcoKSkpXG4gICAgfVxuICAgIC8vdGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgZWxzZSBpZiAoaXNBcnJheShsKSlcbiAgICAgIGZvckVhY2gobCwgaXRlbSlcbiAgICBlbHNlIGlmKGlzTm9kZShsKSlcbiAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgZWxzZSBpZihsIGluc3RhbmNlb2YgVGV4dClcbiAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBsKSB7XG4gICAgICBmb3IgKHZhciBrIGluIGwpIHtcbiAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICBpZigvXm9uXFx3Ky8udGVzdChrKSkge1xuICAgICAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAgICAgID8gZS5hZGRFdmVudExpc3RlbmVyKGsuc3Vic3RyaW5nKDIpLCBsW2tdKVxuICAgICAgICAgICAgICA6IGUuYXR0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZVtrXSA9IGxba10oKVxuICAgICAgICAgICAgbFtrXShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICBlW2tdID0gdlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihrID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcyBpbiBsW2tdKSAoZnVuY3Rpb24ocywgdikge1xuICAgICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2KCkpXG4gICAgICAgICAgICAgIHYoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgdmFsKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgbFtrXVtzXSlcbiAgICAgICAgICB9KShzLCBsW2tdW3NdKVxuICAgICAgICB9IGVsc2UgaWYgKGsuc3Vic3RyKDAsIDUpID09PSBcImRhdGEtXCIpIHtcbiAgICAgICAgICBEYXRhU2V0KGUpW2suc3Vic3RyKDUpXSA9IGxba11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlW2tdID0gbFtrXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbCkge1xuICAgICAgLy9hc3N1bWUgaXQncyBhbiBvYnNlcnZhYmxlIVxuICAgICAgdmFyIHYgPSBsKClcbiAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGlzTm9kZSh2KSA/IHYgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2KSlcblxuICAgICAgbChmdW5jdGlvbiAodikge1xuICAgICAgICBpZihpc05vZGUodikgJiYgci5wYXJlbnRFbGVtZW50KVxuICAgICAgICAgIHIucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQodiwgciksIHIgPSB2XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByLnRleHRDb250ZW50ID0gdlxuICAgICAgfSlcblxuICAgIH1cblxuICAgIHJldHVybiByXG4gIH1cbiAgd2hpbGUoYXJncy5sZW5ndGgpXG4gICAgaXRlbShhcmdzLnNoaWZ0KCkpXG5cbiAgcmV0dXJuIGVcbn1cblxuZnVuY3Rpb24gaXNOb2RlIChlbCkge1xuICByZXR1cm4gZWwgJiYgZWwubm9kZU5hbWUgJiYgZWwubm9kZVR5cGVcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoYXJyLCBmbikge1xuICBpZiAoYXJyLmZvckVhY2gpIHJldHVybiBhcnIuZm9yRWFjaChmbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSwgaSlcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nXG59XG4iLCIoZnVuY3Rpb24oKXsvKiFcbiAqIENyb3NzLUJyb3dzZXIgU3BsaXQgMS4xLjFcbiAqIENvcHlyaWdodCAyMDA3LTIwMTIgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBFQ01BU2NyaXB0IGNvbXBsaWFudCwgdW5pZm9ybSBjcm9zcy1icm93c2VyIHNwbGl0IG1ldGhvZFxuICovXG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhIHJlZ2V4IG9yIHN0cmluZyBzZXBhcmF0b3IuIE1hdGNoZXMgb2YgdGhlXG4gKiBzZXBhcmF0b3IgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LiBIb3dldmVyLCBpZiBgc2VwYXJhdG9yYCBpcyBhIHJlZ2V4IHRoYXQgY29udGFpbnNcbiAqIGNhcHR1cmluZyBncm91cHMsIGJhY2tyZWZlcmVuY2VzIGFyZSBzcGxpY2VkIGludG8gdGhlIHJlc3VsdCBlYWNoIHRpbWUgYHNlcGFyYXRvcmAgaXMgbWF0Y2hlZC5cbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHlcbiAqIGNyb3NzLWJyb3dzZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VwYXJhdG9yIFJlZ2V4IG9yIHN0cmluZyB0byB1c2UgZm9yIHNlcGFyYXRpbmcgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdCBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3Vic3RyaW5ncy5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNlXG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJyk7XG4gKiAvLyAtPiBbJ2EnLCAnYicsICdjJywgJ2QnXVxuICpcbiAqIC8vIFdpdGggbGltaXRcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnLCAyKTtcbiAqIC8vIC0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBCYWNrcmVmZXJlbmNlcyBpbiByZXN1bHQgYXJyYXlcbiAqIHNwbGl0KCcuLndvcmQxIHdvcmQyLi4nLCAvKFthLXpdKykoXFxkKykvaSk7XG4gKiAvLyAtPiBbJy4uJywgJ3dvcmQnLCAnMScsICcgJywgJ3dvcmQnLCAnMicsICcuLiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIHNwbGl0KHVuZGVmKSB7XG5cbiAgdmFyIG5hdGl2ZVNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdCxcbiAgICBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKFwiXCIpWzFdID09PSB1bmRlZixcbiAgICAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIHNlbGY7XG5cbiAgc2VsZiA9IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgYG5hdGl2ZVNwbGl0YFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gXCJbb2JqZWN0IFJlZ0V4cF1cIikge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyBcIm1cIiA6IFwiXCIpICsgKHNlcGFyYXRvci5leHRlbmRlZCA/IFwieFwiIDogXCJcIikgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAoc2VwYXJhdG9yLnN0aWNreSA/IFwieVwiIDogXCJcIiksXG4gICAgICAvLyBGaXJlZm94IDMrXG4gICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgXCJnXCIpLFxuICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICBzdHIgKz0gXCJcIjsgLy8gVHlwZS1jb252ZXJ0XG4gICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cChcIl5cIiArIHNlcGFyYXRvci5zb3VyY2UgKyBcIiQoPyFcXFxccylcIiwgZmxhZ3MpO1xuICAgIH1cbiAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICovXG4gICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWYgPyAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICBsaW1pdCA+Pj4gMDsgLy8gVG9VaW50MzIobGltaXQpXG4gICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyKSkge1xuICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHVuZGVmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KFwiXCIpKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn0pKCk7XG5cbn0pKCkiLCIvLyBjb250YWlucywgYWRkLCByZW1vdmUsIHRvZ2dsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzTGlzdFxuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWxlbSkge1xuICAgIHZhciBjbCA9IGVsZW0uY2xhc3NMaXN0XG5cbiAgICBpZiAoY2wpIHtcbiAgICAgICAgcmV0dXJuIGNsXG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTGlzdCA9IHtcbiAgICAgICAgYWRkOiBhZGRcbiAgICAgICAgLCByZW1vdmU6IHJlbW92ZVxuICAgICAgICAsIGNvbnRhaW5zOiBjb250YWluc1xuICAgICAgICAsIHRvZ2dsZTogdG9nZ2xlXG4gICAgICAgICwgdG9TdHJpbmc6ICR0b1N0cmluZ1xuICAgICAgICAsIGxlbmd0aDogMFxuICAgICAgICAsIGl0ZW06IGl0ZW1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NMaXN0XG5cbiAgICBmdW5jdGlvbiBhZGQodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICBpZiAobGlzdC5pbmRleE9mKHRva2VuKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsaXN0LnB1c2godG9rZW4pXG4gICAgICAgIHNldFRva2VucyhsaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSh0b2tlbikge1xuICAgICAgICB2YXIgbGlzdCA9IGdldFRva2VucygpXG4gICAgICAgICAgICAsIGluZGV4ID0gbGlzdC5pbmRleE9mKHRva2VuKVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIHNldFRva2VucyhsaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBnZXRUb2tlbnMoKS5pbmRleE9mKHRva2VuKSA+IC0xXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlKHRva2VuKSB7XG4gICAgICAgIGlmIChjb250YWlucyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJlbW92ZSh0b2tlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICR0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbShpbmRleCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gZ2V0VG9rZW5zKClcbiAgICAgICAgcmV0dXJuIHRva2Vuc1tpbmRleF0gfHwgbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRva2VucygpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lXG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcihjbGFzc05hbWUuc3BsaXQoXCIgXCIpLCBpc1RydXRoeSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUb2tlbnMobGlzdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGhcblxuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGxpc3Quam9pbihcIiBcIilcbiAgICAgICAgY2xhc3NMaXN0Lmxlbmd0aCA9IGxlbmd0aFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xhc3NMaXN0W2ldID0gbGlzdFtpXVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGxpc3RbbGVuZ3RoXVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyIChhcnIsIGZuKSB7XG4gICAgdmFyIHJldCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKGFycltpXSkpIHJldC5wdXNoKGFycltpXSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBpc1RydXRoeSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlXG59XG4iLCJ2YXIgV2Vha21hcCA9IHJlcXVpcmUoXCJ3ZWFrbWFwXCIpXG52YXIgSW5kaXZpZHVhbCA9IHJlcXVpcmUoXCJpbmRpdmlkdWFsXCIpXG5cbnZhciBkYXRhc2V0TWFwID0gSW5kaXZpZHVhbChcIl9fREFUQV9TRVRfV0VBS01BUFwiLCBXZWFrbWFwKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNldFxuXG5mdW5jdGlvbiBEYXRhU2V0KGVsZW0pIHtcbiAgICBpZiAoZWxlbS5kYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiBlbGVtLmRhdGFzZXRcbiAgICB9XG5cbiAgICB2YXIgaGFzaCA9IGRhdGFzZXRNYXAuZ2V0KGVsZW0pXG5cbiAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgaGFzaCA9IGNyZWF0ZUhhc2goZWxlbSlcbiAgICAgICAgZGF0YXNldE1hcC5zZXQoZWxlbSwgaGFzaClcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaFxufVxuXG5mdW5jdGlvbiBjcmVhdGVIYXNoKGVsZW0pIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGVsZW0uYXR0cmlidXRlc1xuICAgIHZhciBoYXNoID0ge31cblxuICAgIGlmIChhdHRyaWJ1dGVzID09PSBudWxsIHx8IGF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaFxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbaV1cblxuICAgICAgICBpZiAoYXR0ci5uYW1lLnN1YnN0cigwLDUpICE9PSBcImRhdGEtXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBoYXNoW2F0dHIubmFtZS5zdWJzdHIoNSldID0gYXR0ci52YWx1ZVxuICAgIH1cblxuICAgIHJldHVybiBoYXNoXG59XG4iLCIoZnVuY3Rpb24oKXt2YXIgcm9vdCA9IHJlcXVpcmUoXCJnbG9iYWxcIilcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRpdmlkdWFsXG5cbmZ1bmN0aW9uIEluZGl2aWR1YWwoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChyb290W2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHJvb3Rba2V5XVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb290LCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcblxuICAgIHJldHVybiB2YWx1ZVxufVxuXG59KSgpIiwiKGZ1bmN0aW9uKGdsb2JhbCl7LypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dcbn1cblxufSkoc2VsZikiLCIoZnVuY3Rpb24oKXsvKiAoVGhlIE1JVCBMaWNlbnNlKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgQnJhbmRvbiBCZW52aWUgPGh0dHA6Ly9iYmVudmllLmNvbT5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZFxyXG4gKiBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcclxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuICogc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIHdpdGggYWxsIGNvcGllcyBvclxyXG4gKiBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xyXG4gKiBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSAgQ0xBSU0sXHJcbiAqIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLy8gT3JpZ2luYWwgV2Vha01hcCBpbXBsZW1lbnRhdGlvbiBieSBHb3phbGEgQCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMjY5OTkxXHJcbi8vIFVwZGF0ZWQgYW5kIGJ1Z2ZpeGVkIGJ5IFJheW5vcyBAIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE2MzgwNTlcclxuLy8gRXhwYW5kZWQgYnkgQmVudmllIEAgaHR0cHM6Ly9naXRodWIuY29tL0JlbnZpZS9oYXJtb255LWNvbGxlY3Rpb25zXHJcblxyXG52b2lkIGZ1bmN0aW9uKGdsb2JhbCwgdW5kZWZpbmVkXywgdW5kZWZpbmVkKXtcclxuICB2YXIgZ2V0UHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcclxuICAgICAgZGVmUHJvcCAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXHJcbiAgICAgIHRvU291cmNlID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLFxyXG4gICAgICBjcmVhdGUgICA9IE9iamVjdC5jcmVhdGUsXHJcbiAgICAgIGhhc093biAgID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcclxuICAgICAgZnVuY05hbWUgPSAvXlxcbj9mdW5jdGlvblxccz8oXFx3Kik/Xz9cXCgvO1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZGVmaW5lKG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB2YWx1ZSA9IGtleTtcclxuICAgICAga2V5ID0gbmFtZU9mKHZhbHVlKS5yZXBsYWNlKC9fJC8sICcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZQcm9wKG9iamVjdCwga2V5LCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5hbWVPZihmdW5jKXtcclxuICAgIHJldHVybiB0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgPyAnJyA6ICduYW1lJyBpbiBmdW5jXHJcbiAgICAgICAgICA/IGZ1bmMubmFtZSA6IHRvU291cmNlLmNhbGwoZnVuYykubWF0Y2goZnVuY05hbWUpWzFdO1xyXG4gIH1cclxuXHJcbiAgLy8gIyMjIyMjIyMjIyMjXHJcbiAgLy8gIyMjIERhdGEgIyMjXHJcbiAgLy8gIyMjIyMjIyMjIyMjXHJcblxyXG4gIHZhciBEYXRhID0gKGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZGF0YURlc2MgPSB7IHZhbHVlOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0gfSxcclxuICAgICAgICBkYXRhbG9jayA9ICdyZXR1cm4gZnVuY3Rpb24oayl7aWYoaz09PXMpcmV0dXJuIGx9JyxcclxuICAgICAgICB1aWRzICAgICA9IGNyZWF0ZShudWxsKSxcclxuXHJcbiAgICAgICAgY3JlYXRlVUlEID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHZhciBrZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcclxuICAgICAgICAgIHJldHVybiBrZXkgaW4gdWlkcyA/IGNyZWF0ZVVJRCgpIDogdWlkc1trZXldID0ga2V5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdsb2JhbElEID0gY3JlYXRlVUlEKCksXHJcblxyXG4gICAgICAgIHN0b3JhZ2UgPSBmdW5jdGlvbihvYmope1xyXG4gICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgZ2xvYmFsSUQpKVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqW2dsb2JhbElEXTtcclxuXHJcbiAgICAgICAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUob2JqKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBtdXN0IGJlIGV4dGVuc2libGVcIik7XHJcblxyXG4gICAgICAgICAgdmFyIHN0b3JlID0gY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgZGVmUHJvcChvYmosIGdsb2JhbElELCB7IHZhbHVlOiBzdG9yZSB9KTtcclxuICAgICAgICAgIHJldHVybiBzdG9yZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vIGNvbW1vbiBwZXItb2JqZWN0IHN0b3JhZ2UgYXJlYSBtYWRlIHZpc2libGUgYnkgcGF0Y2hpbmcgZ2V0T3duUHJvcGVydHlOYW1lcydcclxuICAgIGRlZmluZShPYmplY3QsIGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqKXtcclxuICAgICAgdmFyIHByb3BzID0gZ2V0UHJvcHMob2JqKTtcclxuICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgZ2xvYmFsSUQpKVxyXG4gICAgICAgIHByb3BzLnNwbGljZShwcm9wcy5pbmRleE9mKGdsb2JhbElEKSwgMSk7XHJcbiAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIERhdGEoKXtcclxuICAgICAgdmFyIHB1aWQgPSBjcmVhdGVVSUQoKSxcclxuICAgICAgICAgIHNlY3JldCA9IHt9O1xyXG5cclxuICAgICAgdGhpcy51bmxvY2sgPSBmdW5jdGlvbihvYmope1xyXG4gICAgICAgIHZhciBzdG9yZSA9IHN0b3JhZ2Uob2JqKTtcclxuICAgICAgICBpZiAoaGFzT3duLmNhbGwoc3RvcmUsIHB1aWQpKVxyXG4gICAgICAgICAgcmV0dXJuIHN0b3JlW3B1aWRdKHNlY3JldCk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gY3JlYXRlKG51bGwsIGRhdGFEZXNjKTtcclxuICAgICAgICBkZWZQcm9wKHN0b3JlLCBwdWlkLCB7XHJcbiAgICAgICAgICB2YWx1ZTogbmV3IEZ1bmN0aW9uKCdzJywgJ2wnLCBkYXRhbG9jaykoc2VjcmV0LCBkYXRhKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGVmaW5lKERhdGEucHJvdG90eXBlLCBmdW5jdGlvbiBnZXQobyl7IHJldHVybiB0aGlzLnVubG9jayhvKS52YWx1ZSB9KTtcclxuICAgIGRlZmluZShEYXRhLnByb3RvdHlwZSwgZnVuY3Rpb24gc2V0KG8sIHYpeyB0aGlzLnVubG9jayhvKS52YWx1ZSA9IHYgfSk7XHJcblxyXG4gICAgcmV0dXJuIERhdGE7XHJcbiAgfSgpKTtcclxuXHJcblxyXG4gIHZhciBXTSA9IChmdW5jdGlvbihkYXRhKXtcclxuICAgIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5ICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFdlYWtNYXAga2V5XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB3cmFwID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdmFsdWUpe1xyXG4gICAgICB2YXIgc3RvcmUgPSBkYXRhLnVubG9jayhjb2xsZWN0aW9uKTtcclxuICAgICAgaWYgKHN0b3JlLnZhbHVlKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgYWxyZWFkeSBhIFdlYWtNYXBcIik7XHJcbiAgICAgIHN0b3JlLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHVud3JhcCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xyXG4gICAgICB2YXIgc3RvcmFnZSA9IGRhdGEudW5sb2NrKGNvbGxlY3Rpb24pLnZhbHVlO1xyXG4gICAgICBpZiAoIXN0b3JhZ2UpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIldlYWtNYXAgaXMgbm90IGdlbmVyaWNcIik7XHJcbiAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbml0aWFsaXplID0gZnVuY3Rpb24od2Vha21hcCwgaXRlcmFibGUpe1xyXG4gICAgICBpZiAoaXRlcmFibGUgIT09IG51bGwgJiYgdHlwZW9mIGl0ZXJhYmxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaXRlcmFibGUuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGl0ZXJhYmxlLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaSl7XHJcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5ICYmIGl0ZW0ubGVuZ3RoID09PSAyKVxyXG4gICAgICAgICAgICBzZXQuY2FsbCh3ZWFrbWFwLCBpdGVyYWJsZVtpXVswXSwgaXRlcmFibGVbaV1bMV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIFdlYWtNYXAoaXRlcmFibGUpe1xyXG4gICAgICBpZiAodGhpcyA9PT0gZ2xvYmFsIHx8IHRoaXMgPT0gbnVsbCB8fCB0aGlzID09PSBXZWFrTWFwLnByb3RvdHlwZSlcclxuICAgICAgICByZXR1cm4gbmV3IFdlYWtNYXAoaXRlcmFibGUpO1xyXG5cclxuICAgICAgd3JhcCh0aGlzLCBuZXcgRGF0YSk7XHJcbiAgICAgIGluaXRpYWxpemUodGhpcywgaXRlcmFibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldChrZXkpe1xyXG4gICAgICB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICB2YXIgdmFsdWUgPSB1bndyYXAodGhpcykuZ2V0KGtleSk7XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcclxuICAgICAgdmFsaWRhdGUoa2V5KTtcclxuICAgICAgLy8gc3RvcmUgYSB0b2tlbiBmb3IgZXhwbGljaXQgdW5kZWZpbmVkIHNvIHRoYXQgXCJoYXNcIiB3b3JrcyBjb3JyZWN0bHlcclxuICAgICAgdW53cmFwKHRoaXMpLnNldChrZXksIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRfIDogdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhcyhrZXkpe1xyXG4gICAgICB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICByZXR1cm4gdW53cmFwKHRoaXMpLmdldChrZXkpICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVsZXRlXyhrZXkpe1xyXG4gICAgICB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICB2YXIgZGF0YSA9IHVud3JhcCh0aGlzKSxcclxuICAgICAgICAgIGhhZCA9IGRhdGEuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcclxuICAgICAgZGF0YS5zZXQoa2V5LCB1bmRlZmluZWQpO1xyXG4gICAgICByZXR1cm4gaGFkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XHJcbiAgICAgIHVud3JhcCh0aGlzKTtcclxuICAgICAgcmV0dXJuICdbb2JqZWN0IFdlYWtNYXBdJztcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgc3JjID0gKCdyZXR1cm4gJytkZWxldGVfKS5yZXBsYWNlKCdlXycsICdcXFxcdTAwNjUnKSxcclxuICAgICAgICAgIGRlbCA9IG5ldyBGdW5jdGlvbigndW53cmFwJywgJ3ZhbGlkYXRlJywgc3JjKSh1bndyYXAsIHZhbGlkYXRlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdmFyIGRlbCA9IGRlbGV0ZV87XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNyYyA9ICgnJytPYmplY3QpLnNwbGl0KCdPYmplY3QnKTtcclxuICAgIHZhciBzdHJpbmdpZmllciA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XHJcbiAgICAgIHJldHVybiBzcmNbMF0gKyBuYW1lT2YodGhpcykgKyBzcmNbMV07XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmluZShzdHJpbmdpZmllciwgc3RyaW5naWZpZXIpO1xyXG5cclxuICAgIHZhciBwcmVwID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheVxyXG4gICAgICA/IGZ1bmN0aW9uKGYpeyBmLl9fcHJvdG9fXyA9IHN0cmluZ2lmaWVyIH1cclxuICAgICAgOiBmdW5jdGlvbihmKXsgZGVmaW5lKGYsIHN0cmluZ2lmaWVyKSB9O1xyXG5cclxuICAgIHByZXAoV2Vha01hcCk7XHJcblxyXG4gICAgW3RvU3RyaW5nLCBnZXQsIHNldCwgaGFzLCBkZWxdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKXtcclxuICAgICAgZGVmaW5lKFdlYWtNYXAucHJvdG90eXBlLCBtZXRob2QpO1xyXG4gICAgICBwcmVwKG1ldGhvZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gV2Vha01hcDtcclxuICB9KG5ldyBEYXRhKSk7XHJcblxyXG4gIHZhciBkZWZhdWx0Q3JlYXRvciA9IE9iamVjdC5jcmVhdGVcclxuICAgID8gZnVuY3Rpb24oKXsgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCkgfVxyXG4gICAgOiBmdW5jdGlvbigpeyByZXR1cm4ge30gfTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlU3RvcmFnZShjcmVhdG9yKXtcclxuICAgIHZhciB3ZWFrbWFwID0gbmV3IFdNO1xyXG4gICAgY3JlYXRvciB8fCAoY3JlYXRvciA9IGRlZmF1bHRDcmVhdG9yKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdG9yYWdlKG9iamVjdCwgdmFsdWUpe1xyXG4gICAgICBpZiAodmFsdWUgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHdlYWttYXAuc2V0KG9iamVjdCwgdmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gd2Vha21hcC5nZXQob2JqZWN0KTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdmFsdWUgPSBjcmVhdG9yKG9iamVjdCk7XHJcbiAgICAgICAgICB3ZWFrbWFwLnNldChvYmplY3QsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdG9yYWdlO1xyXG4gIH1cclxuXHJcblxyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBXTTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZXhwb3J0cy5XZWFrTWFwID0gV007XHJcbiAgfSBlbHNlIGlmICghKCdXZWFrTWFwJyBpbiBnbG9iYWwpKSB7XHJcbiAgICBnbG9iYWwuV2Vha01hcCA9IFdNO1xyXG4gIH1cclxuXHJcbiAgV00uY3JlYXRlU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2U7XHJcbiAgaWYgKGdsb2JhbC5XZWFrTWFwKVxyXG4gICAgZ2xvYmFsLldlYWtNYXAuY3JlYXRlU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2U7XHJcbn0oKDAsIGV2YWwpKCd0aGlzJykpO1xyXG5cbn0pKCkiLCJtb2R1bGUuZXhwb3J0cyA9IGluaGVyaXRzXG5cbmZ1bmN0aW9uIGluaGVyaXRzIChjLCBwLCBwcm90bykge1xuICBwcm90byA9IHByb3RvIHx8IHt9XG4gIHZhciBlID0ge31cbiAgO1tjLnByb3RvdHlwZSwgcHJvdG9dLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBlW2tdID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzLCBrKVxuICAgIH0pXG4gIH0pXG4gIGMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwLnByb3RvdHlwZSwgZSlcbiAgYy5zdXBlciA9IHBcbn1cblxuLy9mdW5jdGlvbiBDaGlsZCAoKSB7XG4vLyAgQ2hpbGQuc3VwZXIuY2FsbCh0aGlzKVxuLy8gIGNvbnNvbGUuZXJyb3IoW3RoaXNcbi8vICAgICAgICAgICAgICAgICx0aGlzLmNvbnN0cnVjdG9yXG4vLyAgICAgICAgICAgICAgICAsdGhpcy5jb25zdHJ1Y3RvciA9PT0gQ2hpbGRcbi8vICAgICAgICAgICAgICAgICx0aGlzLmNvbnN0cnVjdG9yLnN1cGVyID09PSBQYXJlbnRcbi8vICAgICAgICAgICAgICAgICxPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgPT09IENoaWxkLnByb3RvdHlwZVxuLy8gICAgICAgICAgICAgICAgLE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpXG4vLyAgICAgICAgICAgICAgICAgPT09IFBhcmVudC5wcm90b3R5cGVcbi8vICAgICAgICAgICAgICAgICx0aGlzIGluc3RhbmNlb2YgQ2hpbGRcbi8vICAgICAgICAgICAgICAgICx0aGlzIGluc3RhbmNlb2YgUGFyZW50XSlcbi8vfVxuLy9mdW5jdGlvbiBQYXJlbnQgKCkge31cbi8vaW5oZXJpdHMoQ2hpbGQsIFBhcmVudClcbi8vbmV3IENoaWxkXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5vZGUsIGZuKXtcblx0XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25Ib3ZlciwgdHJ1ZSlcblx0XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBvbkV4aXQsIHRydWUpXG5cdFxuXHR2YXIgbm9kZSA9IG5vZGU7XG5cdFxuXHR2YXIgcG9zaXRpb24gPSBbMCwgMF07XG5cdFxuXHRmdW5jdGlvbiBtb3VzZU1vdmUoZXZ0KXtcblx0XG5cdFx0Zm4oZXZ0LCBub2RlLCBwb3NpdGlvbiwgZmFsc2UsIGZhbHNlKVxuXHRcblx0fTtcblx0XG5cdGZ1bmN0aW9uIG9uRXhpdChldnQpe1xuXHRcdFxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmUsIHRydWUpXG5cdFx0XG5cdFx0Zm4oZXZ0LCBub2RlLCBwb3NpdGlvbiwgZmFsc2UsIHRydWUpXG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gb25Ib3ZlcihldnQpe1xuXHRcdFxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmUsIHRydWUpO1xuXHRcdFxuXHRcdHBvc2l0aW9uID0gZmluZFBvcyhldnQudGFyZ2V0KTtcblxuXHRcdGZuKGV2dCwgbm9kZSwgcG9zaXRpb24sIHRydWUsIGZhbHNlKVxuXG5cdFx0ZnVuY3Rpb24gZmluZFBvcyhvYmopIHtcblxuXHRcdFx0XHR2YXIgY3VybGVmdCA9IGN1cnRvcCA9IDA7XG5cblx0XHRcdFx0aWYgKG9iai5vZmZzZXRQYXJlbnQpIHtcblxuXHRcdFx0XHRcdGRvIHtcblxuXHRcdFx0XHRcdFx0XHRcdGN1cmxlZnQgKz0gb2JqLm9mZnNldExlZnQ7XG5cblx0XHRcdFx0XHRcdFx0XHRjdXJ0b3AgKz0gb2JqLm9mZnNldFRvcDtcblxuXHRcdFx0XHRcdFx0XHR9IFxuXG5cdFx0XHRcdFx0d2hpbGUgKG9iaiA9IG9iai5vZmZzZXRQYXJlbnQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIFtjdXJsZWZ0LGN1cnRvcF07XG5cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdH07XG5cdFxufSIsIihmdW5jdGlvbihCdWZmZXIpey8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbi8vICAgICBNSVQgTGljZW5zZVxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICAvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuICAvLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuICAvLyByZXR1cm5zIDEyOC1iaXRzIG9mIHJhbmRvbW5lc3MsIHNpbmNlIHRoYXQncyB3aGF0J3MgdXN1YWxseSByZXF1aXJlZFxuICB2YXIgX3JuZztcblxuICAvLyBOb2RlLmpzIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vbm9kZWpzLm9yZy9kb2NzL3YwLjYuMi9hcGkvY3J5cHRvLmh0bWxcbiAgLy9cbiAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgaWYgKHR5cGVvZihyZXF1aXJlKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmIgPSByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbiAgICAgIF9ybmcgPSBfcmIgJiYgZnVuY3Rpb24oKSB7cmV0dXJuIF9yYigxNik7fTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoIV9ybmcgJiYgX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgIC8vXG4gICAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgICByZXR1cm4gX3JuZHM4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIV9ybmcpIHtcbiAgICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gICAgLy9cbiAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAgIC8vIHF1YWxpdHkuXG4gICAgdmFyICBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9ybmRzO1xuICAgIH07XG4gIH1cblxuICAvLyBCdWZmZXIgY2xhc3MgdG8gdXNlXG4gIHZhciBCdWZmZXJDbGFzcyA9IHR5cGVvZihCdWZmZXIpID09ICdmdW5jdGlvbicgPyBCdWZmZXIgOiBBcnJheTtcblxuICAvLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxuICB2YXIgX2J5dGVUb0hleCA9IFtdO1xuICB2YXIgX2hleFRvQnl0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG4gIH1cblxuICAvLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbiAgZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IChidWYgJiYgb2Zmc2V0KSB8fCAwLCBpaSA9IDA7XG5cbiAgICBidWYgPSBidWYgfHwgW107XG4gICAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uKG9jdCkge1xuICAgICAgaWYgKGlpIDwgMTYpIHsgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICAgIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgICBidWZbaSArIGlpKytdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG4gIGZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IG9mZnNldCB8fCAwLCBidGggPSBfYnl0ZVRvSGV4O1xuICAgIHJldHVybiAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG4gIH1cblxuICAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4gIC8vXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4gIC8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbiAgLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbiAgdmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbiAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gIHZhciBfbm9kZUlkID0gW1xuICAgIF9zZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbiAgXTtcblxuICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICB2YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4gIC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuICB2YXIgX2xhc3RNU2VjcyA9IDAsIF9sYXN0TlNlY3MgPSAwO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPSBudWxsID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAgIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gICAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICAgIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICAgIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAgIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICAgIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAgIC8vIHRpbWUgaW50ZXJ2YWxcbiAgICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT0gbnVsbCkge1xuICAgICAgbnNlY3MgPSAwO1xuICAgIH1cblxuICAgIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICAgIH1cblxuICAgIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAgIC8vIGB0aW1lX2xvd2BcbiAgICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gICAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9taWRgXG4gICAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICAgIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gICAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gICAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gICAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gICAgLy8gYG5vZGVgXG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgICAgYltpICsgbl0gPSBub2RlW25dO1xuICAgIH1cblxuICAgIHJldHVybiBidWYgPyBidWYgOiB1bnBhcnNlKGIpO1xuICB9XG5cbiAgLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQnVmZmVyQ2xhc3MoMTYpIDogbnVsbDtcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG4gIHV1aWQuQnVmZmVyQ2xhc3MgPSBCdWZmZXJDbGFzcztcblxuICBpZiAoX2dsb2JhbC5kZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFB1Ymxpc2ggYXMgQU1EIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtyZXR1cm4gdXVpZDt9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YobW9kdWxlKSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIFB1Ymxpc2ggYXMgbm9kZS5qcyBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVibGlzaCBhcyBnbG9iYWwgKGluIGJyb3dzZXJzKVxuICAgIHZhciBfcHJldmlvdXNSb290ID0gX2dsb2JhbC51dWlkO1xuXG4gICAgLy8gKipgbm9Db25mbGljdCgpYCAtIChicm93c2VyIG9ubHkpIHRvIHJlc2V0IGdsb2JhbCAndXVpZCcgdmFyKipcbiAgICB1dWlkLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9nbG9iYWwudXVpZCA9IF9wcmV2aW91c1Jvb3Q7XG4gICAgICByZXR1cm4gdXVpZDtcbiAgICB9O1xuXG4gICAgX2dsb2JhbC51dWlkID0gdXVpZDtcbiAgfVxufSgpKTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9CdWZmZXJcIikuQnVmZmVyKSIsInZhciB0b3VjaHkgPSByZXF1aXJlKCcuL3RvdWNoeS5qcycpXG4sICAgdXVpZCA9IHJlcXVpcmUoJ25vZGUtdXVpZCcpXG47XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCl7XG5cbiAgaWYod2luZG93Ll90b3VjaCkgcmV0dXJuIHdpbmRvdy5fdG91Y2g7XG5cbiAgZWxzZSByZXR1cm4gbmV3IHRvdWNoKClcblxufSgpKTtcblxuZnVuY3Rpb24gdG91Y2goKXtcblxuICB3aW5kb3cuX3RvdWNoID0gdGhpcztcblxuICB0aGlzLmVsZW1lbnRzID0gW107XG5cbiAgdGhpcy50b3VjaHkgPSB0b3VjaHkod2luZG93LCB0b3VjaHRlc3QpO1xuXG59O1xuXG50b3VjaC5wcm90b3R5cGUuc3RhcnQgPSB0b3VjaC5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24oZWwpe1xuXG4gICAgaWYoIWVsLnRvdWNoX2lkKSBlbC50b3VjaF9pZCA9ICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dWlkLnYxKSA/IHV1aWQudjEoKSA6IHV1aWQoKTtcblxuICAgIHRoaXMuZWxlbWVudHMucHVzaChlbCk7XG5cbiAgICBlbC50b3VjaCA9IDE7XG5cbn07XG5cbnRvdWNoLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGVsKXtcblxuICAgIGlmKCFlbC50b3VjaF9pZCkgZWwudG91Y2hfaWQgPSB1dWlkLnYxKCk7XG5cbiAgICB0aGlzLmVsZW1lbnRzLnB1c2goZWwpO1xuXG4gICAgZWwudG91Y2ggPSAwOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkXG5cbn07XG5cblxuZnVuY3Rpb24gdG91Y2h0ZXN0KGhhbmQsIGZpbmdlcil7XG5cdFxuXHR2YXIgbGFzdFBvaW50ID0gW10sIGFsbFBvaW50cyA9IFtdO1xuXG4gIGZpbmdlci5vbignc3RhcnQnLCBmdW5jdGlvbihwb2ludCl7XG5cdFxuXHRcdHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwb2ludC54LCBwb2ludC55KTtcblx0XHRcdFxuICAgIHZhciBlbCA9IHNlYXJjaChlbGVtZW50KTtcblxuICAgIGlmKGVsKXtcblx0XG5cdFx0ICBsYXN0UG9pbnQgPSBbcG9pbnQueCwgcG9pbnQueV1cblx0XHRcblx0XHQgIGFsbFBvaW50cy5wdXNoKGxhc3RQb2ludC5zbGljZSgwKSlcblxuICAgICAgdGhpcy5pcyA9IHRydWU7XG5cbiAgICAgIHRoaXMuZWwgPSBlbDtcblxuICAgICAgdGhpcy5ldmVudC5pZCA9IHRoaXMuaWQ7XG5cbiAgICAgIHZhciBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3RvdWNoZG93bicsIHsgY2FuY2VsYWJsZTogdHJ1ZSwgYnViYmxlczogZmFsc2UsIGRldGFpbCA6IHBvaW50fSk7XG4gICAgICBcbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgIH1cblxuICB9KTtcbiBcbiAgZmluZ2VyLm9uKCdtb3ZlJywgZnVuY3Rpb24ocG9pbnQpe1xuXG4gICAgaWYodGhpcy5pcyl7XG5cdFxuXHRcbiAgICAgIHZhciBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2RlbHRhdmVjdG9yJywgeyBjYW5jZWxhYmxlOiB0cnVlLCBidWJibGVzOiBmYWxzZSwgZGV0YWlsIDogcG9pbnR9KTtcblxuXHRcdFx0ZXZ0LmRldGFpbC5kZWx0YSA9IFtwb2ludC54IC0gbGFzdFBvaW50WzBdLCBwb2ludC55IC0gbGFzdFBvaW50WzFdXTtcblxuXHRcdFx0ZXZ0LmRldGFpbC52ZWN0b3IgPSBbcG9pbnQueCwgcG9pbnQueV07XG5cblx0XHRcdGV2dC5kZXRhaWwuYWxsUG9pbnRzID0gYWxsUG9pbnRzO1xuXHRcdFxuXHRcdFx0ZXZ0LmRldGFpbC5sYXN0UG9pbnQgPSBsYXN0UG9pbnQuc3BsaWNlKDApXG5cdFx0XHRcdFx0XHRcblx0XHRcdGxhc3RQb2ludCA9IFtwb2ludC54LCBwb2ludC55XVxuXHRcdFxuXHRcdCAgYWxsUG9pbnRzLnB1c2gobGFzdFBvaW50LnNsaWNlKCkpXG5cbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZpbmdlci5vbignZW5kJywgZnVuY3Rpb24ocG9pbnQpe1xuIFxuICAgIGlmKHRoaXMuaXMpe1xuXG4gICAgICB2YXIgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCdsaWZ0b2ZmJywgeyBjYW5jZWxhYmxlOiB0cnVlLCBidWJibGVzOiBmYWxzZSwgZGV0YWlsIDogcG9pbnR9KTtcblxuXHRcdFx0ZXZ0LmRldGFpbC5kZWx0YSA9IFtwb2ludC54IC0gbGFzdFBvaW50WzBdLCBwb2ludC55IC0gbGFzdFBvaW50WzFdXTtcblxuXHRcdFx0ZXZ0LmRldGFpbC52ZWN0b3IgPSBbcG9pbnQueCwgcG9pbnQueV07XG5cblx0XHRcdGV2dC5kZXRhaWwuYWxsUG9pbnRzID0gYWxsUG9pbnRzO1xuXHRcdFxuXHRcdFx0ZXZ0LmRldGFpbC5sYXN0UG9pbnQgPSBsYXN0UG9pbnQuc3BsaWNlKDApXG5cdFx0XHRcdFx0XHRcblx0XHRcdGxhc3RQb2ludCA9IFtwb2ludC54LCBwb2ludC55XVxuXHRcdFxuXHRcdCAgYWxsUG9pbnRzLnB1c2gobGFzdFBvaW50LnNsaWNlKCkpXG5cbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgfVxuXG4gIH0pO1xuXG59O1xuXG5mdW5jdGlvbiBzZWFyY2goZWwpe1xuXG4gIHJldHVybiBzY2FuKGVsKVxuXG4gIGZ1bmN0aW9uIHNjYW4oZWwpe1xuXG4gICAgaWYoIWVsKSByZXR1cm4gZmFsc2U7XG4gIFxuICAgIHZhciB4ID0gd2luZG93Ll90b3VjaC5lbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24odmFsLCBpKXtcdFxuXG4gICAgICBpZihpLnRvdWNoX2lkID09IGVsLnRvdWNoX2lkICYmIGkudG91Y2gpe1xuXG4gICAgICAgIHZhbCA9IGlcblxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHZhbFxuXG4gICAgfSwgZmFsc2UpXG5cbiAgICByZXR1cm4geCB8fCBzY2FuKGVsLnBhcmVudEVsZW1lbnQpXG5cbiAgfVxuXG59O1xuXG5cbnRvdWNoLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKGVsKXtcblxuICBlbC50b3VjaCA9IDBcblxufTtcblxudG91Y2gucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKGVsKXtcblxuICBlbC50b3VjaCA9IDFcblxufTtcblxudG91Y2gucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGVsKXtcblxuICBkZWxldGUgZWwudG91Y2hcblxuICBkZWxldGUgZWwudG91Y2hfaWRcblxufTtcblxudG91Y2gucHJvdG90eXBlLmhhbmRsZU1vdXNlID0gZnVuY3Rpb24oeCl7XG5cbiAgaWYoTW9kZXJuaXpyKSBNb2Rlcm5penIudG91Y2ggPSB0cnVlO1xuXG4gIHRoaXMudG91Y2h5LmhhbmRsZU1vdXNlKHgpO1xuXG59O1xuIiwiLyogTW9kZXJuaXpyIDIuNi4yIChDdXN0b20gQnVpbGQpIHwgTUlUICYgQlNEXG4gKiBCdWlsZDogaHR0cDovL21vZGVybml6ci5jb20vZG93bmxvYWQvIy10b3VjaC10ZXN0c3R5bGVzLXByZWZpeGVzXG4gKi9cbnZhciBNb2Rlcm5penI9ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIHYoYSl7aS5jc3NUZXh0PWF9ZnVuY3Rpb24gdyhhLGIpe3JldHVybiB2KGwuam9pbihhK1wiO1wiKSsoYnx8XCJcIikpfWZ1bmN0aW9uIHgoYSxiKXtyZXR1cm4gdHlwZW9mIGE9PT1ifWZ1bmN0aW9uIHkoYSxiKXtyZXR1cm4hIX4oXCJcIithKS5pbmRleE9mKGIpfWZ1bmN0aW9uIHooYSxiLGQpe2Zvcih2YXIgZSBpbiBhKXt2YXIgZj1iW2FbZV1dO2lmKGYhPT1jKXJldHVybiBkPT09ITE/YVtlXTp4KGYsXCJmdW5jdGlvblwiKT9mLmJpbmQoZHx8Yik6Zn1yZXR1cm4hMX12YXIgZD1cIjIuNi4yXCIsZT17fSxmPWIuZG9jdW1lbnRFbGVtZW50LGc9XCJtb2Rlcm5penJcIixoPWIuY3JlYXRlRWxlbWVudChnKSxpPWguc3R5bGUsaixrPXt9LnRvU3RyaW5nLGw9XCIgLXdlYmtpdC0gLW1vei0gLW8tIC1tcy0gXCIuc3BsaXQoXCIgXCIpLG09e30sbj17fSxvPXt9LHA9W10scT1wLnNsaWNlLHIscz1mdW5jdGlvbihhLGMsZCxlKXt2YXIgaCxpLGosayxsPWIuY3JlYXRlRWxlbWVudChcImRpdlwiKSxtPWIuYm9keSxuPW18fGIuY3JlYXRlRWxlbWVudChcImJvZHlcIik7aWYocGFyc2VJbnQoZCwxMCkpd2hpbGUoZC0tKWo9Yi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGouaWQ9ZT9lW2RdOmcrKGQrMSksbC5hcHBlbmRDaGlsZChqKTtyZXR1cm4gaD1bXCImIzE3MztcIiwnPHN0eWxlIGlkPVwicycsZywnXCI+JyxhLFwiPC9zdHlsZT5cIl0uam9pbihcIlwiKSxsLmlkPWcsKG0/bDpuKS5pbm5lckhUTUwrPWgsbi5hcHBlbmRDaGlsZChsKSxtfHwobi5zdHlsZS5iYWNrZ3JvdW5kPVwiXCIsbi5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLGs9Zi5zdHlsZS5vdmVyZmxvdyxmLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsZi5hcHBlbmRDaGlsZChuKSksaT1jKGwsYSksbT9sLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobCk6KG4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSxmLnN0eWxlLm92ZXJmbG93PWspLCEhaX0sdD17fS5oYXNPd25Qcm9wZXJ0eSx1OyF4KHQsXCJ1bmRlZmluZWRcIikmJiF4KHQuY2FsbCxcInVuZGVmaW5lZFwiKT91PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHQuY2FsbChhLGIpfTp1PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGIgaW4gYSYmeChhLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtiXSxcInVuZGVmaW5lZFwiKX0sRnVuY3Rpb24ucHJvdG90eXBlLmJpbmR8fChGdW5jdGlvbi5wcm90b3R5cGUuYmluZD1mdW5jdGlvbihiKXt2YXIgYz10aGlzO2lmKHR5cGVvZiBjIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgZD1xLmNhbGwoYXJndW1lbnRzLDEpLGU9ZnVuY3Rpb24oKXtpZih0aGlzIGluc3RhbmNlb2YgZSl7dmFyIGE9ZnVuY3Rpb24oKXt9O2EucHJvdG90eXBlPWMucHJvdG90eXBlO3ZhciBmPW5ldyBhLGc9Yy5hcHBseShmLGQuY29uY2F0KHEuY2FsbChhcmd1bWVudHMpKSk7cmV0dXJuIE9iamVjdChnKT09PWc/ZzpmfXJldHVybiBjLmFwcGx5KGIsZC5jb25jYXQocS5jYWxsKGFyZ3VtZW50cykpKX07cmV0dXJuIGV9KSxtLnRvdWNoPWZ1bmN0aW9uKCl7dmFyIGM7cmV0dXJuXCJvbnRvdWNoc3RhcnRcImluIGF8fGEuRG9jdW1lbnRUb3VjaCYmYiBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2g/Yz0hMDpzKFtcIkBtZWRpYSAoXCIsbC5qb2luKFwidG91Y2gtZW5hYmxlZCksKFwiKSxnLFwiKVwiLFwieyNtb2Rlcm5penJ7dG9wOjlweDtwb3NpdGlvbjphYnNvbHV0ZX19XCJdLmpvaW4oXCJcIiksZnVuY3Rpb24oYSl7Yz1hLm9mZnNldFRvcD09PTl9KSxjfTtmb3IodmFyIEEgaW4gbSl1KG0sQSkmJihyPUEudG9Mb3dlckNhc2UoKSxlW3JdPW1bQV0oKSxwLnB1c2goKGVbcl0/XCJcIjpcIm5vLVwiKStyKSk7cmV0dXJuIGUuYWRkVGVzdD1mdW5jdGlvbihhLGIpe2lmKHR5cGVvZiBhPT1cIm9iamVjdFwiKWZvcih2YXIgZCBpbiBhKXUoYSxkKSYmZS5hZGRUZXN0KGQsYVtkXSk7ZWxzZXthPWEudG9Mb3dlckNhc2UoKTtpZihlW2FdIT09YylyZXR1cm4gZTtiPXR5cGVvZiBiPT1cImZ1bmN0aW9uXCI/YigpOmIsdHlwZW9mIGVuYWJsZUNsYXNzZXMhPVwidW5kZWZpbmVkXCImJmVuYWJsZUNsYXNzZXMmJihmLmNsYXNzTmFtZSs9XCIgXCIrKGI/XCJcIjpcIm5vLVwiKSthKSxlW2FdPWJ9cmV0dXJuIGV9LHYoXCJcIiksaD1qPW51bGwsZS5fdmVyc2lvbj1kLGUuX3ByZWZpeGVzPWwsZS50ZXN0U3R5bGVzPXMsZX0od2luZG93LHdpbmRvdy5kb2N1bWVudCk7XG5cbi8qXG5cdFRvdWNoeS5qc1xuXHRTb2NrZXQtc3R5bGUgZmluZ2VyIG1hbmFnZW1lbnQgZm9yIHRvdWNoIGV2ZW50c1xuXG5cdEphaXJhaiBTZXRoaVxuXHRodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS8zLjAvXG4qL1xuXG5cblxuLyogTWFrZSBzdXJlIEkgY2FuIGl0ZXJlYXRlIHRocm91Z2ggYXJyYXlzICovXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcnIsIGNhbGxiYWNrLCBzZWxmKSB7XG5cdCAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyciwgY2FsbGJhY2ssIHNlbGYpO1xuXHR9O1xuICAgIH1cblxuICAgIGVsc2Uge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyciwgY2FsbGJhY2ssIHNlbGYpIHtcblx0ICAgIGZvciAodmFyIGk9MCwgbGVuPWFyci5sZW5ndGg7IGk8bGVuOyBpKyspIHtcblx0XHRpZiAoaSBpbiBhcnIpIHtcblx0XHQgICAgY2FsbGJhY2suY2FsbChzZWxmLCBhcnJbaV0sIGksIGFycik7XG5cdFx0fVxuXHQgICAgfVxuXHR9O1xuICAgIH1cbn0oKTtcblxuLyogTWFrZSBzdXJlIEkgY2FuIHNlYXJjaCB0aHJvdWdoIGFycmF5cyAqL1xudmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVtLCBzdGFydEluZGV4KSB7XG5cdCAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnIsIGl0ZW0sIHN0YXJ0SW5kZXgpO1xuXHR9O1xuICAgIH1cblxuICAgIGVsc2Uge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlbSwgc3RhcnRJbmRleCkge1xuXHQgICAgZm9yICh2YXIgaT1zdGFydEluZGV4IHx8IDAsIGxlbj1hcnIubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG5cdFx0aWYgKChpIGluIGFycikgJiYgKGFycltpXSA9PT0gaXRlbSkpIHtcblx0XHQgICAgcmV0dXJuIGk7XG5cdFx0fVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gLTE7XG5cdH07XG4gICAgfVxufSgpO1xuXG4vKiBNYWtlIHN1cmUgSSBjYW4gbWFwIGFycmF5cyAqL1xudmFyIG1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLm1hcCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyciwgY2FsbGJhY2ssIHNlbGYpIHtcblx0ICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJyLCBjYWxsYmFjaywgc2VsZik7XG5cdH07XG4gICAgfVxuXG4gICAgZWxzZSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJyLCBjYWxsYmFjaywgc2VsZikge1xuXHQgICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsXG5cdCAgICBtYXBBcnIgPSBuZXcgQXJyYXkobGVuKTtcblxuXHQgICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG5cdFx0aWYgKGkgaW4gYXJyKSB7XG5cdFx0ICAgIG1hcEFycltpXSA9IGNhbGxiYWNrLmNhbGwoc2VsZiwgYXJyW2ldLCBpLCBhcnIpO1xuXHRcdH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG1hcEFycjtcblx0fTtcbiAgICB9XG59KCk7XG5cbi8qIE1ha2Ugc3VyZSBJIGNhbiBmaWx0ZXIgYXJyYXlzICovXG52YXIgZmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJyLCBmdW5jLCBzZWxmKSB7XG5cdCAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFyciwgZnVuYywgc2VsZik7XG5cdH07XG4gICAgfVxuXG4gICAgZWxzZSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJyLCBmdW5jLCBzZWxmKSB7XG5cdCAgICB2YXIgZmlsdGVyQXJyID0gW107XG5cblx0ICAgIGZvciAodmFyIHZhbCwgaT0wLCBsZW49YXJyLmxlbmd0aDsgaTxsZW47IGkrKykge1xuXHRcdHZhbCA9IGFycltpXTtcblxuXHRcdGlmICgoaSBpbiBhcnIpICYmIGZ1bmMuY2FsbChzZWxmLCB2YWwsIGksIGFycikpIHtcblx0XHQgICAgZmlsdGVyQXJyLnB1c2godmFsKTtcblx0XHR9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmaWx0ZXJBcnI7XG5cdH07XG4gICAgfVxufSgpO1xuXG4vKiBCaW5kIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnQgKi9cbnZhciBib3VuZEV2ZW50cyA9IHt9O1xuXG5mdW5jdGlvbiBiaW5kIChlbGVtLCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcblx0dmFyIGVJRCA9IGVsZW0uYXR0YWNoRXZlbnQoJ29uJytldmVudE5hbWUsIGNhbGxiYWNrKTtcblx0Ym91bmRFdmVudHNbZUlEXSA9IHsgbmFtZTogZXZlbnROYW1lLCBjYWxsYmFjazogY2FsbGJhY2sgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVuYmluZCAoZWxlbSwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICB9XG5cbiAgICBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG5cdGZvciAodmFyIGVJRCBpbiBib3VuZEV2ZW50cykge1xuXHQgICAgaWYgKChib3VuZEV2ZW50c1tlSURdLm5hbWUgPT09IGV2ZW50TmFtZSkgJiZcblx0XHQoYm91bmRFdmVudHNbZUlEXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spKSB7XG5cdFx0ZWxlbS5kZXRhY2hFdmVudChlSUQpO1xuXHRcdGRlbGV0ZSBib3VuZEV2ZW50c1tlSURdO1xuXHQgICAgfVxuXHR9XG4gICAgfVxufVxuXG4vKiBTaW1wbGUgaW5oZXJpdGFuY2UgKi9cbmZ1bmN0aW9uIGluaGVyaXRzRnJvbSAoZnVuYywgcGFyZW50KSB7XG4gICAgdmFyIHByb3RvID0gZnVuYy5wcm90b3R5cGUsXG4gICAgc3VwZXJQcm90byA9IHBhcmVudC5wcm90b3R5cGUsXG4gICAgb2xkU3VwZXI7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN1cGVyUHJvdG8pIHtcblx0cHJvdG9bcHJvcF0gPSBzdXBlclByb3RvW3Byb3BdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1cGVyTWV0aG9kIChuYW1lKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHRpZiAoIHN1cGVyUHJvdG9bbmFtZV0gKSB7XG5cdCAgICByZXR1cm4gc3VwZXJQcm90b1tuYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0fVxuICAgIH1cblxuICAgIGlmIChwcm90by5fc3VwZXIpIHtcblx0b2xkU3VwZXIgPSBwcm90by5fc3VwZXI7XG5cblx0cHJvdG8uX3N1cGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgb2xkU3VwZXIuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgc3VwZXJNZXRob2QuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuICAgIH1cblxuICAgIGVsc2Uge1xuXHRwcm90by5fc3VwZXIgPSBzdXBlck1ldGhvZDtcbiAgICB9XG59XG5cblxuXG4vKiBFdmVudCBidXMgdG8gaGFuZGxlIGZpbmdlciBldmVudCBsaXN0ZW5lcnMgKi9cbmZ1bmN0aW9uIEV2ZW50QnVzICgpIHtcbiAgICB0aGlzLm9uRXZlbnRzID0ge307XG4gICAgdGhpcy5vbmNlRXZlbnRzID0ge307XG59XG5cbi8qIEF0dGFjaCBhIGhhbmRsZXIgdG8gbGlzdGVuIGZvciBhbiBldmVudCAqL1xuRXZlbnRCdXMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCAhY2FsbGJhY2sgKSB7XG5cdHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLm9uRXZlbnRzKSB7XG5cdHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5vbkV2ZW50c1tuYW1lXSwgY2FsbGJhY2spO1xuXG5cdGlmIChpbmRleCAhPSAtMSkge1xuXHQgICAgcmV0dXJuO1xuXHR9XG4gICAgfVxuXG4gICAgZWxzZSB7XG5cdHRoaXMub25FdmVudHNbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLm9uY2VFdmVudHMpIHtcblx0dmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLm9uY2VFdmVudHNbbmFtZV0sIGNhbGxiYWNrKTtcblxuXHRpZiAoaW5kZXggIT0gLTEpIHtcblx0ICAgIHRoaXMub25jZUV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG4gICAgfVxuXG4gICAgdGhpcy5vbkV2ZW50c1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbn07XG5cbi8qIEF0dGFjaCBhIG9uZS10aW1lLXVzZSBoYW5kbGVyIHRvIGxpc3RlbiBmb3IgYW4gZXZlbnQgKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCAhY2FsbGJhY2sgKSB7XG5cdHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLm9uY2VFdmVudHMpIHtcblx0dmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLm9uY2VFdmVudHNbbmFtZV0sIGNhbGxiYWNrKTtcblxuXHRpZiAoaW5kZXggIT0gLTEpIHtcblx0ICAgIHJldHVybjtcblx0fVxuICAgIH1cblxuICAgIGVsc2Uge1xuXHR0aGlzLm9uY2VFdmVudHNbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLm9uRXZlbnRzKSB7XG5cdHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5vbkV2ZW50c1tuYW1lXSwgY2FsbGJhY2spO1xuXG5cdGlmIChpbmRleCAhPSAtMSkge1xuXHQgICAgdGhpcy5vbkV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG4gICAgfVxuXG4gICAgdGhpcy5vbmNlRXZlbnRzW25hbWVdLnB1c2goY2FsbGJhY2spO1xufTtcblxuLyogRGV0YWNoIGEgaGFuZGxlciBmcm9tIGxpc3RlbmluZyBmb3IgYW4gZXZlbnQgKi9cbkV2ZW50QnVzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoICFjYWxsYmFjayApIHtcblx0cmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuYW1lIGluIHRoaXMub25FdmVudHMpIHtcblx0dmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLm9uRXZlbnRzW25hbWVdLCBjYWxsYmFjayk7XG5cblx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdCAgICB0aGlzLm9uRXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICByZXR1cm47XG5cdH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLm9uY2VFdmVudHMpIHtcblx0dmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLm9uY2VFdmVudHNbbmFtZV0sIGNhbGxiYWNrKTtcblxuXHRpZiAoaW5kZXggIT0gLTEpIHtcblx0ICAgIHRoaXMub25jZUV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgcmV0dXJuO1xuXHR9XG4gICAgfVxufTtcblxuLyogRmlyZSBhbiBldmVudCwgdHJpZ2dlcmluZyBhbGwgaGFuZGxlcnMgKi9cbkV2ZW50QnVzLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgY2FsbGJhY2tzID0gKHRoaXMub25FdmVudHNbbmFtZV0gfHwgW10pLmNvbmNhdCh0aGlzLm9uY2VFdmVudHNbbmFtZV0gfHwgW10pLFxuICAgIGNhbGxiYWNrO1xuXG4gICAgd2hpbGUgKGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCkpIHtcblx0Y2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxufTtcblxuXG5cbi8qIE9iamVjdCB0byBtYW5hZ2UgYSBzaW5nbGUtZmluZ2VyIGludGVyYWN0aW9ucyAqL1xuZnVuY3Rpb24gRmluZ2VyIChpZCwgZSkge1xuICAgIHRoaXMuX3N1cGVyKCdjb25zdHJ1Y3RvcicpO1xuICAgIHRoaXMuaWQgICAgICAgID0gaWQ7XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBudWxsO1xuICAgIHRoaXMuZXZlbnQgPSBlO1xufVxuaW5oZXJpdHNGcm9tKEZpbmdlciwgRXZlbnRCdXMpO1xuXG5cblxuLyogT2JqZWN0IHRvIG1hbmFnZSBtdWx0aXBsZS1maW5nZXIgaW50ZXJhY3Rpb25zICovXG5mdW5jdGlvbiBIYW5kIChpZHMpIHtcbiAgICB0aGlzLl9zdXBlcignY29uc3RydWN0b3InKTtcblxuICAgIHRoaXMuZmluZ2VycyA9ICFpZHMgPyBbXSA6IG1hcChpZHMsIGZ1bmN0aW9uIChpZCkge1xuXHRyZXR1cm4gbmV3IEZpbmdlcihpZCk7XG4gICAgfSk7XG59XG5pbmhlcml0c0Zyb20oSGFuZCwgRXZlbnRCdXMpO1xuXG4vKiBHZXQgZmluZ2VyIGJ5IGlkICovXG5IYW5kLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZm91bmRGaW5nZXI7XG5cbiAgICBmb3JFYWNoKHRoaXMuZmluZ2VycywgZnVuY3Rpb24gKGZpbmdlcikge1xuXHRpZiAoZmluZ2VyLmlkID09IGlkKSB7XG5cdCAgICBmb3VuZEZpbmdlciA9IGZpbmdlcjtcblx0fVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvdW5kRmluZ2VyO1xufTtcblxuXG5cbi8qIENvbnZlcnQgRE9NIHRvdWNoIGV2ZW50IG9iamVjdCB0byBzaW1wbGUgZGljdGlvbmFyeSBzdHlsZSBvYmplY3QgKi9cbmZ1bmN0aW9uIGRvbVRvdWNoVG9PYmogKHRvdWNoZXMsIHRpbWUsIGUpIHtcbiAgICByZXR1cm4gbWFwKHRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuXHRyZXR1cm4ge1xuXHQgICAgZTogZSxcblx0ICAgIGlkOiB0b3VjaC5pZGVudGlmaWVyLFxuXHQgICAgeDogdG91Y2gucGFnZVgsXG5cdCAgICB5OiB0b3VjaC5wYWdlWSxcblx0ICAgIHRpbWU6IHRpbWVcblx0fTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZG9tTW91c2VUb09iaiAobW91c2VFdmVudCwgbW91c2VJRCkge1xuICAgIHJldHVybiBbe1xuXHRlOiBtb3VzZUV2ZW50LFxuXHRpZDogbW91c2VJRCxcblx0eDogbW91c2VFdmVudC5wYWdlWCxcblx0eTogbW91c2VFdmVudC5wYWdlWSxcblx0dGltZTogbW91c2VFdmVudC50aW1lU3RhbXBcbiAgICB9XTtcbn1cblxuXG5cbi8qIENvbnRyb2xsZXIgb2JqZWN0IHRvIGhhbmRsZSBUb3VjaHkgaW50ZXJhY3Rpb25zIG9uIGFuIGVsZW1lbnQgKi9cbmZ1bmN0aW9uIFRvdWNoQ29udHJvbGxlciAoZWxlbSwgaGFuZGxlTW91c2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PSAndW5kZWZpbmVkJykge1xuXHRzZXR0aW5ncyA9IGhhbmRsZU1vdXNlO1xuXHRoYW5kbGVNb3VzZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT0gJ2Z1bmN0aW9uJykge1xuXHRzZXR0aW5ncyA9IHsgYW55OiBzZXR0aW5ncyB9O1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2lucykge1xuXHRpZiAobmFtZSBpbiBzZXR0aW5ncykge1xuXHQgICAgdmFyIHVwZGF0ZXMgPSBwbHVnaW5zW25hbWVdKGVsZW0sIHNldHRpbmdzW25hbWVdKTtcblxuXHQgICAgaWYgKHR5cGVvZiB1cGRhdGVzID09ICdmdW5jdGlvbicpIHtcblx0XHR1cGRhdGVzID0geyBhbnk6IHVwZGF0ZXMgfTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaGFuZGxlclR5cGUgaW4gdXBkYXRlcykge1xuXHRcdGlmIChoYW5kbGVyVHlwZSBpbiBzZXR0aW5ncykge1xuXHRcdCAgICBzZXR0aW5nc1toYW5kbGVyVHlwZV0gPSAoZnVuY3Rpb24gKGhhbmRsZXIxLCBoYW5kbGVyMikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICBoYW5kbGVyMS5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHQgICAgaGFuZGxlcjIuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHQgICAgfSkoc2V0dGluZ3NbaGFuZGxlclR5cGVdLCB1cGRhdGVzW2hhbmRsZXJUeXBlXSk7XG5cdFx0fVxuXG5cdFx0ZWxzZSB7XG5cdFx0ICAgIHNldHRpbmdzW2hhbmRsZXJUeXBlXSA9IHVwZGF0ZXNbaGFuZGxlclR5cGVdO1xuXHRcdH1cblx0ICAgIH1cblx0fVxuICAgIH1cblxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgIHRoaXMubWFpbkhhbmQgPSBuZXcgSGFuZCgpO1xuICAgIHRoaXMubXVsdGlIYW5kID0gbnVsbDtcbiAgICB0aGlzLm1vdXNlSUQgPSBudWxsO1xuXG4gICAgdGhpcy5zdGFydCgpO1xufTtcblxuLyogU3RhcnQgd2F0Y2hpbmcgZWxlbWVudCBmb3IgdG91Y2ggZXZlbnRzICovXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICBcdHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRpZihNb2Rlcm5penIudG91Y2gpe1xuXHRcdCAgYmluZCh0aGlzLmVsZW0sICd0b3VjaHN0YXJ0JywgdGhpcy50b3VjaHN0YXJ0KCkgKTtcblx0ICAgIGJpbmQodGhpcy5lbGVtLCAndG91Y2htb3ZlJyAsIHRoaXMudG91Y2htb3ZlKCkgICk7XG5cdCAgICBiaW5kKHRoaXMuZWxlbSwgJ3RvdWNoZW5kJyAgLCB0aGlzLnRvdWNoZW5kKCkgICApO1x0XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0ICBiaW5kKHRoaXMuZWxlbSwgJ21vdXNlZG93bicgLCB0aGlzLm1vdXNlZG93bigpICk7XG5cdCAgICBiaW5kKHRoaXMuZWxlbSwgJ21vdXNldXAnICAgLCB0aGlzLm1vdXNldXAoKSAgICk7XG5cdCAgICBiaW5kKHRoaXMuZWxlbSwgJ21vdXNlbW92ZScgLCB0aGlzLm1vdXNlbW92ZSgpICk7XHRcblx0XHR9XG59O1xuXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlID0gZnVuY3Rpb24oeCl7XG5cbiAgaWYoeCl7XG4gICAgYmluZCh0aGlzLmVsZW0sICdtb3VzZWRvd24nICwgdGhpcy5tb3VzZWRvd24oKSApO1xuICAgIGJpbmQodGhpcy5lbGVtLCAnbW91c2V1cCcgICAsIHRoaXMubW91c2V1cCgpICAgKTtcbiAgICBiaW5kKHRoaXMuZWxlbSwgJ21vdXNlbW92ZScgLCB0aGlzLm1vdXNlbW92ZSgpICk7XG4gIH1cblxuICBlbHNle1xuICAgIHVuYmluZCh0aGlzLmVsZW0sICdtb3VzZWRvd24nICwgdGhpcy5tb3VzZWRvd24oKSApO1xuICAgIHVuYmluZCh0aGlzLmVsZW0sICdtb3VzZXVwJyAgICwgdGhpcy5tb3VzZXVwKCkgICApO1xuICAgIHVuYmluZCh0aGlzLmVsZW0sICdtb3VzZW1vdmUnICwgdGhpcy5tb3VzZW1vdmUoKSApO1xuICB9IFxufVxuXG4vKiBTdG9wIHdhdGNoaW5nIGVsZW1lbnQgZm9yIHRvdWNoIGV2ZW50cyAqL1xuVG91Y2hDb250cm9sbGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggIXRoaXMucnVubmluZyApIHtcblx0cmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIHVuYmluZCh0aGlzLmVsZW0sICd0b3VjaHN0YXJ0JywgdGhpcy50b3VjaHN0YXJ0KCkgKTtcbiAgICB1bmJpbmQodGhpcy5lbGVtLCAndG91Y2htb3ZlJyAsIHRoaXMudG91Y2htb3ZlKCkgICk7XG4gICAgdW5iaW5kKHRoaXMuZWxlbSwgJ3RvdWNoZW5kJyAgLCB0aGlzLnRvdWNoZW5kKCkgICApO1xuXG4gICAgdW5iaW5kKHRoaXMuZWxlbSwgJ21vdXNlZG93bicgLCB0aGlzLm1vdXNlZG93bigpICk7XG4gICAgdW5iaW5kKHRoaXMuZWxlbSwgJ21vdXNldXAnICAgLCB0aGlzLm1vdXNldXAoKSAgICk7XG4gICAgdW5iaW5kKHRoaXMuZWxlbSwgJ21vdXNlbW92ZScgLCB0aGlzLm1vdXNlbW92ZSgpICk7XG59O1xuXG4vKiBSZXR1cm4gYSBoYW5kbGVyIGZvciBET00gdG91Y2hzdGFydCBldmVudCAqL1xuVG91Y2hDb250cm9sbGVyLnByb3RvdHlwZS50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggIXRoaXMuX3RvdWNoc3RhcnQgKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dGhpcy5fdG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgdG91Y2hlcyA9IGRvbVRvdWNoVG9PYmooZS50b3VjaGVzLCBlLnRpbWVTdGFtcCksXG5cdCAgICBjaGFuZ2VkVG91Y2hlcyA9IGRvbVRvdWNoVG9PYmooZS5jaGFuZ2VkVG91Y2hlcywgZS50aW1lU3RhbXAsIGUpO1xuXG5cdCAgICBzZWxmLm1haW5IYW5kU3RhcnQoY2hhbmdlZFRvdWNoZXMpO1xuXHQgICAgc2VsZi5tdWx0aUhhbmRTdGFydChjaGFuZ2VkVG91Y2hlcywgdG91Y2hlcyk7XG5cdH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RvdWNoc3RhcnQ7XG59O1xuXG4vKiBSZXR1cm4gYSBoYW5kbGVyIGZvciBET00gdG91Y2htb3ZlIGV2ZW50ICovXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoICF0aGlzLl90b3VjaG1vdmUgKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dGhpcy5fdG91Y2htb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciB0b3VjaGVzID0gZG9tVG91Y2hUb09iaihlLnRvdWNoZXMsIGUudGltZVN0YW1wKSxcblx0ICAgIGNoYW5nZWRUb3VjaGVzID0gZG9tVG91Y2hUb09iaihlLmNoYW5nZWRUb3VjaGVzLCBlLnRpbWVTdGFtcCk7XG5cblx0ICAgIHNlbGYubWFpbkhhbmRNb3ZlKGNoYW5nZWRUb3VjaGVzKTtcblx0ICAgIHNlbGYubXVsdGlIYW5kTW92ZShjaGFuZ2VkVG91Y2hlcywgdG91Y2hlcyk7XG5cdH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RvdWNobW92ZTtcbn07XG5cbi8qIFJldHVybiBhIGhhbmRsZXIgZm9yIERPTSB0b3VjaGVuZCBldmVudCAqL1xuVG91Y2hDb250cm9sbGVyLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoICF0aGlzLl90b3VjaGVuZCApIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLl90b3VjaGVuZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgdG91Y2hlcyA9IGRvbVRvdWNoVG9PYmooZS50b3VjaGVzLCBlLnRpbWVTdGFtcCksXG5cdCAgICBjaGFuZ2VkVG91Y2hlcyA9IGRvbVRvdWNoVG9PYmooZS5jaGFuZ2VkVG91Y2hlcywgZS50aW1lU3RhbXApO1xuXG5cdCAgICBzZWxmLm1haW5IYW5kRW5kKGNoYW5nZWRUb3VjaGVzKTtcblx0ICAgIHNlbGYubXVsdGlIYW5kRW5kKGNoYW5nZWRUb3VjaGVzLCB0b3VjaGVzKTtcblx0fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdG91Y2hlbmQ7XG59O1xuXG4vKiBSZXR1cm4gYSBoYW5kbGVyIGZvciBET00gbW91c2Vkb3duIGV2ZW50ICovXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoICF0aGlzLl9tb3VzZWRvd24gKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dGhpcy5fbW91c2Vkb3duID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciB0b3VjaGVzO1xuXG5cdCAgICBpZiAoIHNlbGYubW91c2VJRCApIHtcblx0XHR0b3VjaGVzID0gZG9tTW91c2VUb09iaihlLCBzZWxmLm1vdXNlSUQpO1xuXHRcdHNlbGYubWFpbkhhbmRFbmQodG91Y2hlcyk7XG5cdFx0c2VsZi5tdWx0aUhhbmRFbmQodG91Y2hlcywgdG91Y2hlcyk7XG5cdFx0c2VsZi5tb3VzZUlEID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgc2VsZi5tb3VzZUlEID0gTWF0aC5yYW5kb20oKSArICcnO1xuXG5cdCAgICB0b3VjaGVzID0gZG9tTW91c2VUb09iaihlLCBzZWxmLm1vdXNlSUQpO1xuXHQgICAgc2VsZi5tYWluSGFuZFN0YXJ0KHRvdWNoZXMpO1xuXHQgICAgc2VsZi5tdWx0aUhhbmRTdGFydCh0b3VjaGVzLCB0b3VjaGVzKTtcblx0fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbW91c2Vkb3duO1xufTtcblxuLyogUmV0dXJuIGEgaGFuZGxlciBmb3IgRE9NIG1vdXNldXAgZXZlbnQgKi9cblRvdWNoQ29udHJvbGxlci5wcm90b3R5cGUubW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoICF0aGlzLl9tb3VzZXVwICkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHRoaXMuX21vdXNldXAgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIHRvdWNoZXM7XG5cblx0ICAgIGlmICggc2VsZi5tb3VzZUlEICkge1xuXHRcdHRvdWNoZXMgPSBkb21Nb3VzZVRvT2JqKGUsIHNlbGYubW91c2VJRCk7XG5cdFx0c2VsZi5tYWluSGFuZEVuZCh0b3VjaGVzKTtcblx0XHRzZWxmLm11bHRpSGFuZEVuZCh0b3VjaGVzLCB0b3VjaGVzKTtcblx0XHRzZWxmLm1vdXNlSUQgPSBudWxsO1xuXHQgICAgfVxuXHR9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9tb3VzZXVwO1xufTtcblxuLyogUmV0dXJuIGEgaGFuZGxlciBmb3IgRE9NIG1vdXNlbW92ZSBldmVudCAqL1xuVG91Y2hDb250cm9sbGVyLnByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCAhdGhpcy5fbW91c2Vtb3ZlICkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHRoaXMuX21vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgdG91Y2hlcztcblxuXHQgICAgaWYgKCBzZWxmLm1vdXNlSUQgKSB7XG5cdFx0dG91Y2hlcyA9IGRvbU1vdXNlVG9PYmooZSwgc2VsZi5tb3VzZUlEKTtcblx0XHRzZWxmLm1haW5IYW5kTW92ZSh0b3VjaGVzKTtcblx0XHRzZWxmLm11bHRpSGFuZE1vdmUodG91Y2hlcywgdG91Y2hlcyk7XG5cdCAgICB9XG5cdH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX21vdXNlbW92ZTtcbn07XG5cbi8qIEhhbmRsZSB0aGUgc3RhcnQgb2YgYW4gaW5kaXZpZHVhbCBmaW5nZXIgaW50ZXJhY3Rpb24gKi9cblRvdWNoQ29udHJvbGxlci5wcm90b3R5cGUubWFpbkhhbmRTdGFydCA9IGZ1bmN0aW9uIChjaGFuZ2VkVG91Y2hlcykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICBuZXdGaW5nZXJzID0gW107XG5cbiAgICBmb3JFYWNoKGNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcblx0dmFyIGZpbmdlciA9IG5ldyBGaW5nZXIodG91Y2guaWQsIHRvdWNoLmUpO1xuXHRmaW5nZXIubGFzdFBvaW50ID0gdG91Y2g7XG5cdG5ld0ZpbmdlcnMucHVzaChbIGZpbmdlciwgdG91Y2ggXSk7XG5cdHNlbGYubWFpbkhhbmQuZmluZ2Vycy5wdXNoKGZpbmdlcik7XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKG5ld0ZpbmdlcnMsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdHNlbGYuc2V0dGluZ3MuYW55ICYmIHNlbGYuc2V0dGluZ3MuYW55LmNhbGwoc2VsZiwgc2VsZi5tYWluSGFuZCwgZGF0YVswXSk7XG5cdGRhdGFbMF0udHJpZ2dlcignc3RhcnQnLCBkYXRhWzFdKTtcbiAgICB9KTtcblxuICAgIHNlbGYubWFpbkhhbmQudHJpZ2dlcignc3RhcnQnLCBjaGFuZ2VkVG91Y2hlcyk7XG59O1xuXG4vKiBIYW5kbGUgdGhlIG1vdmVtZW50IG9mIGFuIGluZGl2aWR1YWwgZmluZ2VyIGludGVyYWN0aW9uICovXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLm1haW5IYW5kTW92ZSA9IGZ1bmN0aW9uIChjaGFuZ2VkVG91Y2hlcykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICBtb3ZlZEZpbmdlcnMgPSBbXTtcblxuICAgIGZvckVhY2goY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuXHR2YXIgZmluZ2VyID0gc2VsZi5tYWluSGFuZC5nZXQodG91Y2guaWQpO1xuXG5cdGlmICggIWZpbmdlciApIHtcblx0ICAgIHJldHVybjtcblx0fVxuXG5cdGZpbmdlci5sYXN0UG9pbnQgPSB0b3VjaDtcblx0bW92ZWRGaW5nZXJzLnB1c2goWyBmaW5nZXIsIHRvdWNoIF0pO1xuICAgIH0pO1xuXG4gICAgZm9yRWFjaChtb3ZlZEZpbmdlcnMsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdGRhdGFbMF0udHJpZ2dlcignbW92ZScsIGRhdGFbMV0pO1xuICAgIH0pO1xuXG4gICAgc2VsZi5tYWluSGFuZC50cmlnZ2VyKCdtb3ZlJywgY2hhbmdlZFRvdWNoZXMpO1xufTtcblxuLyogSGFuZGxlIHRoZSBlbmQgb2YgYW4gaW5kaXZpZHVhbCBmaW5nZXIgaW50ZXJhY3Rpb24gKi9cblRvdWNoQ29udHJvbGxlci5wcm90b3R5cGUubWFpbkhhbmRFbmQgPSBmdW5jdGlvbiAoY2hhbmdlZFRvdWNoZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgZW5kRmluZ2VycyA9IFtdO1xuXG4gICAgZm9yRWFjaChjaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG5cdHZhciBmaW5nZXIgPSBzZWxmLm1haW5IYW5kLmdldCh0b3VjaC5pZCksXG5cdGluZGV4O1xuXG5cdGlmICggIWZpbmdlciApIHtcblx0ICAgIHJldHVybjtcblx0fVxuXG5cdGZpbmdlci5sYXN0UG9pbnQgPSB0b3VjaDtcblx0ZW5kRmluZ2Vycy5wdXNoKFsgZmluZ2VyLCB0b3VjaCBdKTtcblxuXHRpbmRleCA9IGluZGV4T2Yoc2VsZi5tYWluSGFuZC5maW5nZXJzLCBmaW5nZXIpO1xuXHRzZWxmLm1haW5IYW5kLmZpbmdlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9KTtcblxuICAgIGZvckVhY2goZW5kRmluZ2VycywgZnVuY3Rpb24gKGRhdGEpIHtcblx0ZGF0YVswXS50cmlnZ2VyKCdlbmQnLCBkYXRhWzFdKTtcbiAgICB9KTtcblxuICAgIHNlbGYubWFpbkhhbmQudHJpZ2dlcignZW5kJywgY2hhbmdlZFRvdWNoZXMpO1xufTtcblxuLyogSGFuZGxlIHRoZSBzdGFydCBvZiBhIG11bHRpLXRvdWNoIGludGVyYWN0aW9uICovXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLm11bHRpSGFuZFN0YXJ0ID0gZnVuY3Rpb24gKGNoYW5nZWRUb3VjaGVzLCB0b3VjaGVzKSB7XG4gICAgdGhpcy5tdWx0aUhhbmREZXN0cm95KCk7XG4gICAgdGhpcy5tdWx0aUhhbmRSZXN0YXJ0KHRvdWNoZXMpO1xufTtcblxuLyogSGFuZGxlIHRoZSBtb3ZlbWVudCBvZiBhIG11bHRpLXRvdWNoIGludGVyYWN0aW9uICovXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLm11bHRpSGFuZE1vdmUgPSBmdW5jdGlvbiAoY2hhbmdlZFRvdWNoZXMsIHRvdWNoZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgbW92ZWRGaW5nZXJzID0gW107XG5cbiAgICBmb3JFYWNoKGNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcblx0dmFyIGZpbmdlciA9IHNlbGYubXVsdGlIYW5kLmdldCh0b3VjaC5pZCk7XG5cblx0aWYoICFmaW5nZXIgKSB7XG5cdCAgICByZXR1cm47XG5cdH1cblxuXHRmaW5nZXIubGFzdFBvaW50ID0gdG91Y2g7XG5cdG1vdmVkRmluZ2Vycy5wdXNoKFsgZmluZ2VyLCB0b3VjaCBdKTtcbiAgICB9KTtcblxuICAgIGZvckVhY2gobW92ZWRGaW5nZXJzLCBmdW5jdGlvbiAoZGF0YSkge1xuXHRkYXRhWzBdLnRyaWdnZXIoJ21vdmUnLCBkYXRhWzFdKTtcbiAgICB9KTtcblxuICAgIHNlbGYubXVsdGlIYW5kLnRyaWdnZXIoJ21vdmUnLCBjaGFuZ2VkVG91Y2hlcyk7XG59O1xuXG4vKiBIYW5kbGUgdGhlIGVuZCBvZiBhIG11bHRpLXRvdWNoIGludGVyYWN0aW9uICovXG5Ub3VjaENvbnRyb2xsZXIucHJvdG90eXBlLm11bHRpSGFuZEVuZCA9IGZ1bmN0aW9uIChjaGFuZ2VkVG91Y2hlcywgdG91Y2hlcykge1xuICAgIHRoaXMubXVsdGlIYW5kRGVzdHJveSgpO1xuXG4gICAgdmFyIHJlbWFpbmluZ1RvdWNoZXMgPSBmaWx0ZXIodG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG5cdHZhciB1bkNoYW5nZWQgPSB0cnVlO1xuXG5cdGZvckVhY2goY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uIChjaGFuZ2VkVG91Y2gpIHtcblx0ICAgIGlmIChjaGFuZ2VkVG91Y2guaWQgPT0gdG91Y2guaWQpIHtcblx0XHR1bkNoYW5nZWQgPSBmYWxzZTtcblx0ICAgIH1cblx0fSk7XG5cblx0cmV0dXJuIHVuQ2hhbmdlZDtcbiAgICB9KTtcblxuICAgIHRoaXMubXVsdGlIYW5kUmVzdGFydChyZW1haW5pbmdUb3VjaGVzKTtcbn07XG5cbi8qIENyZWF0ZSBhIG5ldyBoYW5kIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRvdWNoZXMgb24gdGhlIHNjcmVlbiAqL1xuVG91Y2hDb250cm9sbGVyLnByb3RvdHlwZS5tdWx0aUhhbmRSZXN0YXJ0ID0gZnVuY3Rpb24gKHRvdWNoZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodG91Y2hlcy5sZW5ndGggPT0gMCkge1xuXHRyZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5tdWx0aUhhbmQgPSBuZXcgSGFuZCgpO1xuICAgIHZhciBuZXdGaW5nZXJzID0gW107XG5cbiAgICBmb3JFYWNoKHRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuXHR2YXIgZmluZ2VyID0gbmV3IEZpbmdlcih0b3VjaC5pZCk7XG5cblx0ZmluZ2VyLmxhc3RQb2ludCA9IHRvdWNoO1xuXHRuZXdGaW5nZXJzLnB1c2goWyBmaW5nZXIsIHRvdWNoIF0pO1xuXHRzZWxmLm11bHRpSGFuZC5maW5nZXJzLnB1c2goZmluZ2VyKTtcbiAgICB9KTtcblxuICAgIHZhciBmdW5jID0gc2VsZi5zZXR0aW5nc1sge1xuXHQxOiAnb25lJyxcblx0MjogJ3R3bycsXG5cdDM6ICd0aHJlZScsXG5cdDQ6ICdmb3VyJyxcblx0NTogJ2ZpdmUnXG4gICAgfVsgc2VsZi5tdWx0aUhhbmQuZmluZ2Vycy5sZW5ndGggXSBdO1xuXG4gICAgZnVuYyAmJiBmdW5jLmFwcGx5KHNlbGYsIFsgc2VsZi5tdWx0aUhhbmQgXS5jb25jYXQoIHNlbGYubXVsdGlIYW5kLmZpbmdlcnMgKSk7XG5cbiAgICBmb3JFYWNoKG5ld0ZpbmdlcnMsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdGRhdGFbMF0udHJpZ2dlcignc3RhcnQnLCBkYXRhWzFdKTtcbiAgICB9KTtcblxuICAgIHNlbGYubXVsdGlIYW5kLnRyaWdnZXIoJ3N0YXJ0JywgdG91Y2hlcyk7XG59O1xuXG4vKiBEZXN0cm95IHRoZSBjdXJyZW50IGhhbmQgcmVnYXJkbGVzcyBvZiBmaW5nZXJzIG9uIHRoZSBzY3JlZW4gKi9cblRvdWNoQ29udHJvbGxlci5wcm90b3R5cGUubXVsdGlIYW5kRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoICF0aGlzLm11bHRpSGFuZCApIHtcblx0cmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgIGZvckVhY2godGhpcy5tdWx0aUhhbmQuZmluZ2VycywgZnVuY3Rpb24gKGZpbmdlcikge1xuXHR2YXIgcG9pbnQgPSBmaW5nZXIubGFzdFBvaW50O1xuXHRwb2ludHMucHVzaChwb2ludCk7XG5cdGZpbmdlci50cmlnZ2VyKCdlbmQnLCBwb2ludCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm11bHRpSGFuZC50cmlnZ2VyKCdlbmQnLCBwb2ludHMpO1xuXG4gICAgdGhpcy5tdWx0aUhhbmQgPSBudWxsO1xufTtcblxuLyogU29ja2V0LXN0eWxlIGZpbmdlciBtYW5hZ2VtZW50IGZvciBtdWx0aS10b3VjaCBldmVudHMgKi9cbmZ1bmN0aW9uIFRvdWNoeSAoZWxlbSwgaGFuZGxlTW91c2UsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUb3VjaENvbnRyb2xsZXIoZWxlbSwgaGFuZGxlTW91c2UsIHNldHRpbmdzKTtcbn1cblxuLyogUGx1Z2luIHN1cHBvcnQgZm9yIGN1c3RvbSB0b3VjaCBoYW5kbGluZyAqL1xudmFyIHBsdWdpbnMgPSB7fTtcblRvdWNoeS5wbHVnaW4gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAobmFtZSBpbiBwbHVnaW5zKSB7XG5cdHRocm93ICdUb3VjaHk6ICcgKyBuYW1lICsgJyBwbHVnaW4gYWxyZWFkeSBkZWZpbmVkJztcbiAgICB9XG5cbiAgICBwbHVnaW5zW25hbWVdID0gY2FsbGJhY2s7XG59O1xuXG5cblxuLyogUHJldmVudCB3aW5kb3cgbW92ZW1lbnQgKGlPUyBmaXgpICovXG52YXIgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZSkgeyBlLnByZXZlbnREZWZhdWx0KCkgfTtcblxuVG91Y2h5LnN0b3BXaW5kb3dCb3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCk7XG59O1xuXG5Ub3VjaHkuc3RhcnRXaW5kb3dCb3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHByZXZlbnREZWZhdWx0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG91Y2h5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHIpe1xuXHRcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbc3RyXSwge3R5cGU6IFwidGV4dFxcL2phdmFzY3JpcHRcIn0pO1xuXHRcblx0dmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpXG5cdFxuXHRyZXR1cm4gd29ya2VyO1xuXHRcbn0iLCIoZnVuY3Rpb24oKXsvLyBVVElMSVRZXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG59O1xudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gW3RoaXMubmFtZSArICc6JywgdGhpcy5tZXNzYWdlXS5qb2luKCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMubmFtZSArICc6JyxcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuYWN0dWFsLCByZXBsYWNlciksIDEyOCksXG4gICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkodGhpcy5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvci5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCBndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCEhIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhY3R1YWwpICYmIEJ1ZmZlci5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKCdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKCdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG59KSgpIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe2lmICghcHJvY2Vzcy5FdmVudEVtaXR0ZXIpIHByb2Nlc3MuRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50RW1pdHRlciA9IHByb2Nlc3MuRXZlbnRFbWl0dGVyO1xudmFyIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gQXJyYXkuaXNBcnJheVxuICAgIDogZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgfVxuO1xuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeCA9PT0geHNbaV0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW5cbi8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4vL1xuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gbjtcbn07XG5cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNBcnJheSh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSlcbiAgICB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gZmFsc2U7XG4gIHZhciBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBpZiAoIWhhbmRsZXIpIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBFdmVudEVtaXR0ZXIgaXMgZGVmaW5lZCBpbiBzcmMvbm9kZV9ldmVudHMuY2Ncbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCgpIGlzIGFsc28gZGVmaW5lZCB0aGVyZS5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhZGRMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT0gXCJuZXdMaXN0ZW5lcnNcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgICB2YXIgbTtcbiAgICAgIGlmICh0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbSA9IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYub24odHlwZSwgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzQXJyYXkobGlzdCkpIHtcbiAgICB2YXIgaSA9IGluZGV4T2YobGlzdCwgbGlzdGVuZXIpO1xuICAgIGlmIChpIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDApXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gbGlzdGVuZXIpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAodHlwZSAmJiB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcbiAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdO1xufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsIi8vIG5vdGhpbmcgdG8gc2VlIGhlcmUuLi4gbm8gZmlsZSBtZXRob2RzIGZvciB0aGUgYnJvd3NlclxuIiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbnZhciBodHRwcyA9IG1vZHVsZS5leHBvcnRzO1xuXG5mb3IgKHZhciBrZXkgaW4gaHR0cCkge1xuICAgIGlmIChodHRwLmhhc093blByb3BlcnR5KGtleSkpIGh0dHBzW2tleV0gPSBodHRwW2tleV07XG59O1xuXG5odHRwcy5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgcGFyYW1zLnNjaGVtZSA9ICdodHRwcyc7XG4gICAgcmV0dXJuIGh0dHAucmVxdWVzdC5jYWxsKHRoaXMsIHBhcmFtcywgY2IpO1xufSIsIlxuLyoqXG4gKiBPYmplY3QjdG9TdHJpbmcoKSByZWYgZm9yIHN0cmluZ2lmeSgpLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQXJyYXkjaW5kZXhPZiBzaGltLlxuICovXG5cbnZhciBpbmRleE9mID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBlbCkgeyByZXR1cm4gYXJyLmluZGV4T2YoZWwpOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBlbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gZWwpIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbi8qKlxuICogQXJyYXkuaXNBcnJheSBzaGltLlxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBPYmplY3Qua2V5cyBzaGltLlxuICovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgcmV0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQXJyYXkjZm9yRWFjaCBzaGltLlxuICovXG5cbnZhciBmb3JFYWNoID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBmbikgeyByZXR1cm4gYXJyLmZvckVhY2goZm4pOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBmbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSk7XG4gICAgfTtcblxuLyoqXG4gKiBBcnJheSNyZWR1Y2Ugc2hpbS5cbiAqL1xuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCkge1xuICBpZiAodHlwZW9mIGFyci5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHJldHVybiBhcnIucmVkdWNlKGZuLCBpbml0aWFsKTtcbiAgdmFyIHJlcyA9IGluaXRpYWw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSByZXMgPSBmbihyZXMsIGFycltpXSk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIENhY2hlIG5vbi1pbnRlZ2VyIHRlc3QgcmVnZXhwLlxuICovXG5cbnZhciBpc2ludCA9IC9eWzAtOV0rJC87XG5cbmZ1bmN0aW9uIHByb21vdGUocGFyZW50LCBrZXkpIHtcbiAgaWYgKHBhcmVudFtrZXldLmxlbmd0aCA9PSAwKSByZXR1cm4gcGFyZW50W2tleV0gPSB7fTtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICBwYXJlbnRba2V5XSA9IHQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBwYXJzZShwYXJ0cywgcGFyZW50LCBrZXksIHZhbCkge1xuICB2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gIC8vIGVuZFxuICBpZiAoIXBhcnQpIHtcbiAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgIHBhcmVudFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgIHBhcmVudFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgLy8gYXJyYXlcbiAgfSBlbHNlIHtcbiAgICB2YXIgb2JqID0gcGFyZW50W2tleV0gPSBwYXJlbnRba2V5XSB8fCBbXTtcbiAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKCcnICE9IHZhbCkgb2JqLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICBvYmpbb2JqZWN0S2V5cyhvYmopLmxlbmd0aF0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3BcbiAgICB9IGVsc2UgaWYgKH5pbmRleE9mKHBhcnQsICddJykpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnN1YnN0cigwLCBwYXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKCFpc2ludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0LCB2YWwpO1xuICAgICAgLy8ga2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgcGFyc2UocGFydHMsIG9iaiwgcGFydCwgdmFsKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBwYXJlbnQga2V5L3ZhbCBwYWlyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKHBhcmVudCwga2V5LCB2YWwpe1xuICBpZiAofmluZGV4T2Yoa2V5LCAnXScpKSB7XG4gICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICwgbGVuID0gcGFydHMubGVuZ3RoXG4gICAgICAsIGxhc3QgPSBsZW4gLSAxO1xuICAgIHBhcnNlKHBhcnRzLCBwYXJlbnQsICdiYXNlJywgdmFsKTtcbiAgICAvLyBvcHRpbWl6ZVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICB2YXIgdCA9IHt9O1xuICAgICAgZm9yICh2YXIgayBpbiBwYXJlbnQuYmFzZSkgdFtrXSA9IHBhcmVudC5iYXNlW2tdO1xuICAgICAgcGFyZW50LmJhc2UgPSB0O1xuICAgIH1cbiAgICBzZXQocGFyZW50LmJhc2UsIGtleSwgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIG9iai5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmope1xuICB2YXIgcmV0ID0geyBiYXNlOiB7fSB9O1xuICBmb3JFYWNoKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgbWVyZ2UocmV0LCBuYW1lLCBvYmpbbmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHJldC5iYXNlO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBzdHIuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKXtcbiAgcmV0dXJuIHJlZHVjZShTdHJpbmcoc3RyKS5zcGxpdCgnJicpLCBmdW5jdGlvbihyZXQsIHBhaXIpe1xuICAgIHZhciBlcWwgPSBpbmRleE9mKHBhaXIsICc9JylcbiAgICAgICwgYnJhY2UgPSBsYXN0QnJhY2VJbktleShwYWlyKVxuICAgICAgLCBrZXkgPSBwYWlyLnN1YnN0cigwLCBicmFjZSB8fCBlcWwpXG4gICAgICAsIHZhbCA9IHBhaXIuc3Vic3RyKGJyYWNlIHx8IGVxbCwgcGFpci5sZW5ndGgpXG4gICAgICAsIHZhbCA9IHZhbC5zdWJzdHIoaW5kZXhPZih2YWwsICc9JykgKyAxLCB2YWwubGVuZ3RoKTtcblxuICAgIC8vID9mb29cbiAgICBpZiAoJycgPT0ga2V5KSBrZXkgPSBwYWlyLCB2YWwgPSAnJztcbiAgICBpZiAoJycgPT0ga2V5KSByZXR1cm4gcmV0O1xuXG4gICAgcmV0dXJuIG1lcmdlKHJldCwgZGVjb2RlKGtleSksIGRlY29kZSh2YWwpKTtcbiAgfSwgeyBiYXNlOiB7fSB9KS5iYXNlO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYCBvciBgb2JqYCwgcmV0dXJuaW5nIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHwge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAobnVsbCA9PSBzdHIgfHwgJycgPT0gc3RyKSByZXR1cm4ge307XG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2Ygc3RyXG4gICAgPyBwYXJzZU9iamVjdChzdHIpXG4gICAgOiBwYXJzZVN0cmluZyhzdHIpO1xufTtcblxuLyoqXG4gKiBUdXJuIHRoZSBnaXZlbiBgb2JqYCBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIHByZWZpeCkge1xuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnW29iamVjdCBPYmplY3RdJyA9PSB0b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhvYmosIHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbJyArIGkgKyAnXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKG51bGwgPT0gb2JqW2tleV0pIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXggKyAnWycgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICddJ1xuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyZWFtLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UsIGFuZFxuICAvLyBvbmx5IHdoZW4gYWxsIHNvdXJjZXMgaGF2ZSBlbmRlZC5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgZGVzdC5fcGlwZUNvdW50ID0gZGVzdC5fcGlwZUNvdW50IHx8IDA7XG4gICAgZGVzdC5fcGlwZUNvdW50Kys7XG5cbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5fcGlwZUNvdW50LS07XG5cbiAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyc1xuICAgIGNsZWFudXAoKTtcblxuICAgIGlmIChkZXN0Ll9waXBlQ291bnQgPiAwKSB7XG4gICAgICAvLyB3YWl0aW5nIGZvciBvdGhlciBpbmNvbWluZyBzdHJlYW1zIHRvIGVuZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuX3BpcGVDb3VudC0tO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnNcbiAgICBjbGVhbnVwKCk7XG5cbiAgICBpZiAoZGVzdC5fcGlwZUNvdW50ID4gMCkge1xuICAgICAgLy8gd2FpdGluZyBmb3Igb3RoZXIgaW5jb21pbmcgc3RyZWFtcyB0byBlbmQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsInZhciBwdW55Y29kZSA9IHsgZW5jb2RlIDogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgfSB9O1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyYXksIHN1YmplY3QpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpZihhcnJheVtpXSA9PSBzdWJqZWN0KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCAhPT0gT2JqZWN0KG9iamVjdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb2JqZWN0Jyk7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIGtleXNba2V5cy5sZW5ndGhdID0ga2V5O1xuICAgIHJldHVybiBrZXlzO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKyQvLFxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICd+JywgJ1snLCAnXScsICdgJ10uY29uY2F0KGRlbGltcyksXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXVxuICAgICAgLmNvbmNhdCh1bndpc2UpLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBub25BdXRoQ2hhcnMgPSBbJy8nLCAnQCcsICc/JywgJyMnXS5jb25jYXQoZGVsaW1zKSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16QS1aMC05XVthLXowLTlBLVpfLV17MCw2Mn0kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBoYXZlIGEgcGF0aCBjb21wb25lbnQuXG4gICAgcGF0aGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHR5cGVvZih1cmwpID09PSAnb2JqZWN0JyAmJiB1cmwuaHJlZikgcmV0dXJuIHVybDtcblxuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIG91dCA9IHt9LFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyBjdXQgb2ZmIGFueSBkZWxpbWl0ZXJzLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIjxodHRwOi8vZm9vLmNvbT5cIlxuICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFycmF5SW5kZXhPZihkZWxpbXMsIHJlc3QuY2hhckF0KGkpKSA9PT0gLTEpIGJyZWFrO1xuICB9XG4gIGlmIChpICE9PSAwKSByZXN0ID0gcmVzdC5zdWJzdHIoaSk7XG5cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgb3V0LnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgb3V0LnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy8gZG9uJ3QgZW5mb3JjZSBmdWxsIFJGQyBjb3JyZWN0bmVzcywganVzdCBiZSB1bnN0dXBpZCBhYm91dCBpdC5cblxuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBub24tYXV0aCBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICB2YXIgYXRTaWduID0gYXJyYXlJbmRleE9mKHJlc3QsICdAJyk7XG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIC8vIHRoZXJlICptYXkgYmUqIGFuIGF1dGhcbiAgICAgIHZhciBoYXNBdXRoID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uQXV0aENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSBhcnJheUluZGV4T2YocmVzdCwgbm9uQXV0aENoYXJzW2ldKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCA8IGF0U2lnbikge1xuICAgICAgICAgIC8vIG5vdCBhIHZhbGlkIGF1dGguICBTb21ldGhpbmcgbGlrZSBodHRwOi8vZm9vLmNvbS9iYXJAYmF6L1xuICAgICAgICAgIGhhc0F1dGggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0F1dGgpIHtcbiAgICAgICAgLy8gcGx1Y2sgb2ZmIHRoZSBhdXRoIHBvcnRpb24uXG4gICAgICAgIG91dC5hdXRoID0gcmVzdC5zdWJzdHIoMCwgYXRTaWduKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGF0U2lnbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJzdE5vbkhvc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5SW5kZXhPZihyZXN0LCBub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgIChmaXJzdE5vbkhvc3QgPCAwIHx8IGluZGV4IDwgZmlyc3ROb25Ib3N0KSkgZmlyc3ROb25Ib3N0ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Tm9uSG9zdCAhPT0gLTEpIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdC5zdWJzdHIoMCwgZmlyc3ROb25Ib3N0KTtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihmaXJzdE5vbkhvc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQuaG9zdCA9IHJlc3Q7XG4gICAgICByZXN0ID0gJyc7XG4gICAgfVxuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB2YXIgcCA9IHBhcnNlSG9zdChvdXQuaG9zdCk7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgb3V0W2tleV0gPSBwW2tleV07XG4gICAgfVxuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmIChvdXQuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIG91dC5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gb3V0Lmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICB2YXIgZG9tYWluQXJyYXkgPSBvdXQuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgIH1cbiAgICBvdXQuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuXG4gICAgb3V0Lmhvc3QgPSAob3V0Lmhvc3RuYW1lIHx8ICcnKSArXG4gICAgICAgICgob3V0LnBvcnQpID8gJzonICsgb3V0LnBvcnQgOiAnJyk7XG4gICAgb3V0LmhyZWYgKz0gb3V0Lmhvc3Q7XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgbWFrZSBzdXJlIHRoYXQgZGVsaW1zIG5ldmVyIGFwcGVhciBpbiBhIHVybC5cbiAgICB2YXIgY2hvcCA9IHJlc3QubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGVsaW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGMgPSBhcnJheUluZGV4T2YocmVzdCwgZGVsaW1zW2ldKTtcbiAgICAgIGlmIChjICE9PSAtMSkge1xuICAgICAgICBjaG9wID0gTWF0aC5taW4oYywgY2hvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnN1YnN0cigwLCBjaG9wKTtcbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSBhcnJheUluZGV4T2YocmVzdCwgJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIG91dC5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gYXJyYXlJbmRleE9mKHJlc3QsICc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICBvdXQuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIG91dC5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIG91dC5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKG91dC5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICBvdXQuc2VhcmNoID0gJyc7XG4gICAgb3V0LnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIG91dC5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICBvdXQuaG9zdG5hbWUgJiYgIW91dC5wYXRobmFtZSkge1xuICAgIG91dC5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKG91dC5wYXRobmFtZSB8fCBvdXQuc2VhcmNoKSB7XG4gICAgb3V0LnBhdGggPSAob3V0LnBhdGhuYW1lID8gb3V0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgIChvdXQuc2VhcmNoID8gb3V0LnNlYXJjaCA6ICcnKTtcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICBvdXQuaHJlZiA9IHVybEZvcm1hdChvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHR5cGVvZihvYmopID09PSAnc3RyaW5nJykgb2JqID0gdXJsUGFyc2Uob2JqKTtcblxuICB2YXIgYXV0aCA9IG9iai5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBhdXRoLnNwbGl0KCdAJykuam9pbignJTQwJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub25BdXRoQ2hhcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbkFDID0gbm9uQXV0aENoYXJzW2ldO1xuICAgICAgYXV0aCA9IGF1dGguc3BsaXQobkFDKS5qb2luKGVuY29kZVVSSUNvbXBvbmVudChuQUMpKTtcbiAgICB9XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSBvYmoucHJvdG9jb2wgfHwgJycsXG4gICAgICBob3N0ID0gKG9iai5ob3N0ICE9PSB1bmRlZmluZWQpID8gYXV0aCArIG9iai5ob3N0IDpcbiAgICAgICAgICBvYmouaG9zdG5hbWUgIT09IHVuZGVmaW5lZCA/IChcbiAgICAgICAgICAgICAgYXV0aCArIG9iai5ob3N0bmFtZSArXG4gICAgICAgICAgICAgIChvYmoucG9ydCA/ICc6JyArIG9iai5wb3J0IDogJycpXG4gICAgICAgICAgKSA6XG4gICAgICAgICAgZmFsc2UsXG4gICAgICBwYXRobmFtZSA9IG9iai5wYXRobmFtZSB8fCAnJyxcbiAgICAgIHF1ZXJ5ID0gb2JqLnF1ZXJ5ICYmXG4gICAgICAgICAgICAgICgodHlwZW9mIG9iai5xdWVyeSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBvYmplY3RLZXlzKG9iai5xdWVyeSkubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShvYmoucXVlcnkpIDpcbiAgICAgICAgICAgICAgICAgJycpIHx8ICcnLFxuICAgICAgc2VhcmNoID0gb2JqLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJycsXG4gICAgICBoYXNoID0gb2JqLmhhc2ggfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAob2JqLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybEZvcm1hdCh1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpKTtcbn1cblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG5cbiAgc291cmNlID0gdXJsUGFyc2UodXJsRm9ybWF0KHNvdXJjZSksIGZhbHNlLCB0cnVlKTtcbiAgcmVsYXRpdmUgPSB1cmxQYXJzZSh1cmxGb3JtYXQocmVsYXRpdmUpLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIHNvdXJjZS5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgcmVsYXRpdmUucHJvdG9jb2wgPSBzb3VyY2UucHJvdG9jb2w7XG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSAmJlxuICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSAmJiAhcmVsYXRpdmUucGF0aG5hbWUpIHtcbiAgICAgIHJlbGF0aXZlLnBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gICAgcmVsYXRpdmUuaHJlZiA9IHVybEZvcm1hdChyZWxhdGl2ZSk7XG4gICAgcmV0dXJuIHJlbGF0aXZlO1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSBzb3VyY2UucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICAgIHJldHVybiByZWxhdGl2ZTtcbiAgICB9XG4gICAgc291cmNlLnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVsYXRpdmUucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgc291cmNlLnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzb3VyY2UuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgc291cmNlLmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHNvdXJjZS5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgc291cmNlLnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoc291cmNlLnBhdGhuYW1lICE9PSB1bmRlZmluZWQgfHwgc291cmNlLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAoc291cmNlLnNlYXJjaCA/IHNvdXJjZS5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHNvdXJjZS5zbGFzaGVzID0gc291cmNlLnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAoc291cmNlLnBhdGhuYW1lICYmIHNvdXJjZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSBzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHNvdXJjZS5wcm90b2NvbCAmJlxuICAgICAgICAgICFzbGFzaGVkUHJvdG9jb2xbc291cmNlLnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyBzb3VyY2UucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuXG4gICAgZGVsZXRlIHNvdXJjZS5ob3N0bmFtZTtcbiAgICBkZWxldGUgc291cmNlLnBvcnQ7XG4gICAgaWYgKHNvdXJjZS5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSBzb3VyY2UuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHNvdXJjZS5ob3N0KTtcbiAgICB9XG4gICAgZGVsZXRlIHNvdXJjZS5ob3N0O1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3RuYW1lO1xuICAgICAgZGVsZXRlIHJlbGF0aXZlLnBvcnQ7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSByZWxhdGl2ZS5ob3N0O1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICBzb3VyY2UuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHNvdXJjZS5ob3N0O1xuICAgIHNvdXJjZS5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHNvdXJjZS5ob3N0bmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoJ3NlYXJjaCcgaW4gcmVsYXRpdmUpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBhcnJheUluZGV4T2Yoc291cmNlLmhvc3QsICdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHNvdXJjZS5ob3N0ID0gc291cmNlLmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoc291cmNlLnBhdGhuYW1lICE9PSB1bmRlZmluZWQgfHwgc291cmNlLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAoc291cmNlLnNlYXJjaCA/IHNvdXJjZS5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgZGVsZXRlIHNvdXJjZS5wYXRobmFtZTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFzb3VyY2Uuc2VhcmNoKSB7XG4gICAgICBzb3VyY2UucGF0aCA9ICcvJyArIHNvdXJjZS5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBzb3VyY2UucGF0aDtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAoc291cmNlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgc291cmNlLmhvc3RuYW1lID0gc291cmNlLmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gc291cmNlLmhvc3QgJiYgYXJyYXlJbmRleE9mKHNvdXJjZS5ob3N0LCAnQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHNvdXJjZS5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHNvdXJjZS5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBzb3VyY2UucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoc291cmNlLnBhdGhuYW1lICE9PSB1bmRlZmluZWQgfHwgc291cmNlLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlLnBhdGggPSAoc291cmNlLnBhdGhuYW1lID8gc291cmNlLnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgfVxuICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgc291cmNlLmF1dGg7XG4gIHNvdXJjZS5zbGFzaGVzID0gc291cmNlLnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3N0KGhvc3QpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgb3V0LnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIG91dC5ob3N0bmFtZSA9IGhvc3Q7XG4gIHJldHVybiBvdXQ7XG59XG4iLCJ2YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSd9O1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJ307XG5cblxuZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5wdXRzID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBzZWVuID0gW107XG5cbiAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgIHZhciBzdHlsZXMgPVxuICAgICAgICB7ICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAgICAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAgICAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgICAgICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgICAgICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICAgICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSB9O1xuXG4gICAgdmFyIHN0eWxlID1cbiAgICAgICAgeyAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAgICAgICAnbnVtYmVyJzogJ2JsdWUnLFxuICAgICAgICAgICdib29sZWFuJzogJ3llbGxvdycsXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgICAgICAgICAnbnVsbCc6ICdib2xkJyxcbiAgICAgICAgICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgICAgICAgICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICdyZWdleHAnOiAncmVkJyB9W3N0eWxlVHlwZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG4gIGlmICghIGNvbG9ycykge1xuICAgIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkgeyByZXR1cm4gc3RyOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZSAhPT0gZXhwb3J0cyAmJlxuICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICB9XG5cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIgdmlzaWJsZV9rZXlzID0gT2JqZWN0X2tleXModmFsdWUpO1xuICAgIHZhciBrZXlzID0gc2hvd0hpZGRlbiA/IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSA6IHZpc2libGVfa2V5cztcblxuICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGVzIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWRcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgdHlwZSwgYnJhY2VzO1xuICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnQXJyYXknO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdPYmplY3QnO1xuICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgYmFzZSA9IChpc1JlZ0V4cCh2YWx1ZSkpID8gJyAnICsgdmFsdWUgOiAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJyc7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyB2YWx1ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlX2tleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgIH0pO1xuXG4gICAgc2Vlbi5wb3AoKTtcblxuICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufTtcblxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBhciBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKGFyICYmIGFyICE9PSBPYmplY3QucHJvdG90eXBlICYmIGlzQXJyYXkoYXIuX19wcm90b19fKSk7XG59XG5cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgKHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3BlcnRpZXMgPSBEYXRlLnByb3RvdHlwZSAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRlLnByb3RvdHlwZSk7XG4gIHZhciBwcm90byA9IGQuX19wcm90b19fICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKGQuX19wcm90b19fKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3RvKSA9PT0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG4iLCJleHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiKGZ1bmN0aW9uKCl7dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXI7XG5CdWZmZXIucG9vbFNpemUgPSA4MTkyO1xuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG5mdW5jdGlvbiBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBvZmZzZXQpO1xuICB9XG4gIHRoaXMucGFyZW50ID0gdGhpcztcbiAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gIHZhciB0eXBlO1xuXG4gIC8vIEFyZSB3ZSBzbGljaW5nP1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGNvZXJjZShlbmNvZGluZyk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gICAgc3dpdGNoICh0eXBlID0gdHlwZW9mIHN1YmplY3QpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOiAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5IG9yIHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXNbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzW2ldID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXNbaV07XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChpLCB2KSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpc1tpXSA9IHY7XG59O1xuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5CdWZmZXIucHJvdG90eXBlLmJhc2U2NFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnV0ZjhTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciByZXMgPSBcIlwiO1xuICB2YXIgdG1wID0gXCJcIjtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGlmIChieXRlc1tpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgdG1wID0gXCJcIjtcbiAgICB9IGVsc2VcbiAgICAgIHRtcCArPSBcIiVcIiArIGJ5dGVzW2ldLnRvU3RyaW5nKDE2KTtcblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5U2xpY2UgPSBCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2U7XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPic7XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmhleFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSArb2Zmc2V0IHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gK2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgfVxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IGJ5dGU7XG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcywgZW5kIC0gc3RhcnQsICtzdGFydCk7XG59O1xuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBpc05hTihlbmQpKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c3RhcnQ7IGk8ZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRfc3RhcnQ7IGk8dGFyZ2V0X3N0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0X3N0YXJ0XTtcbiAgfVxufTtcblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIHZhbHVlIHx8ICh2YWx1ZSA9IDApO1xuICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgZW5kIHx8IChlbmQgPSB0aGlzLmxlbmd0aCk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cbiAgaWYgKCEodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBpcyBub3QgYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgPCBzdGFydCcpO1xuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0aGlzLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICB9XG59XG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBoZWxwZXJzXG5cbmZ1bmN0aW9uIGNvZXJjZShsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8XG4gICAgZnVuY3Rpb24oc3ViamVjdCl7XG4gICAgICByZXR1cm4ge30udG9TdHJpbmcuYXBwbHkoc3ViamVjdCkgPT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH0pXG4gICAgKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3MsIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmICgoaStvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVhaztcblxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLy8gcmVhZC93cml0ZSBiaXQtdHdpZGRsaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybjtcblxuICByZXR1cm4gYnVmZmVyW29mZnNldF07XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiAwO1xuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyW29mZnNldCArIDFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHZhbCB8PSBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyW29mZnNldCArIDFdIDw8IDE2O1xuICAgIGlmIChvZmZzZXQgKyAyIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgODtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyW29mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXJbb2Zmc2V0XSA8PCAyNCA+Pj4gMCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyW29mZnNldCArIDJdIDw8IDE2O1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyW29mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZmZlcltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogU2lnbmVkIGludGVnZXIgdHlwZXMsIHlheSB0ZWFtISBBIHJlbWluZGVyIG9uIGhvdyB0d28ncyBjb21wbGVtZW50IGFjdHVhbGx5XG4gKiB3b3Jrcy4gVGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbmVkIGJpdCwgaS5lLiB0ZWxscyB1cyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAqIG51bWJlciBzaG91bGQgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuIElmIHRoZSB0d28ncyBjb21wbGVtZW50IHZhbHVlIGlzXG4gKiBwb3NpdGl2ZSwgdGhlbiB3ZSdyZSBkb25lLCBhcyBpdCdzIGVxdWl2YWxlbnQgdG8gdGhlIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIE5vdyBpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCB5b3UncmUgcHJldHR5IG11Y2ggZG9uZSwgeW91IGNhbiBqdXN0IGxldmVyYWdlXG4gKiB0aGUgdW5zaWduZWQgdHJhbnNsYXRpb25zIGFuZCByZXR1cm4gdGhvc2UuIFVuZm9ydHVuYXRlbHksIG5lZ2F0aXZlIG51bWJlcnNcbiAqIGFyZW4ndCBxdWl0ZSB0aGF0IHN0cmFpZ2h0Zm9yd2FyZC5cbiAqXG4gKiBBdCBmaXJzdCBnbGFuY2UsIG9uZSBtaWdodCBiZSBpbmNsaW5lZCB0byB1c2UgdGhlIHRyYWRpdGlvbmFsIGZvcm11bGEgdG9cbiAqIHRyYW5zbGF0ZSBiaW5hcnkgbnVtYmVycyBiZXR3ZWVuIHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzIGluIHR3bydzXG4gKiBjb21wbGVtZW50LiAoVGhvdWdoIGl0IGRvZXNuJ3QgcXVpdGUgd29yayBmb3IgdGhlIG1vc3QgbmVnYXRpdmUgdmFsdWUpXG4gKiBNYWlubHk6XG4gKiAgLSBpbnZlcnQgYWxsIHRoZSBiaXRzXG4gKiAgLSBhZGQgb25lIHRvIHRoZSByZXN1bHRcbiAqXG4gKiBPZiBjb3Vyc2UsIHRoaXMgZG9lc24ndCBxdWl0ZSB3b3JrIGluIEphdmFzY3JpcHQuIFRha2UgZm9yIGV4YW1wbGUgdGhlIHZhbHVlXG4gKiBvZiAtMTI4LiBUaGlzIGNvdWxkIGJlIHJlcHJlc2VudGVkIGluIDE2IGJpdHMgKGJpZy1lbmRpYW4pIGFzIDB4ZmY4MC4gQnV0IG9mXG4gKiBjb3Vyc2UsIEphdmFzY3JpcHQgd2lsbCBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqID4gfjB4ZmY4MFxuICogLTY1NDA5XG4gKlxuICogV2hvaCB0aGVyZSwgSmF2YXNjcmlwdCwgdGhhdCdzIG5vdCBxdWl0ZSByaWdodC4gQnV0IHdhaXQsIGFjY29yZGluZyB0b1xuICogSmF2YXNjcmlwdCB0aGF0J3MgcGVyZmVjdGx5IGNvcnJlY3QuIFdoZW4gSmF2YXNjcmlwdCBlbmRzIHVwIHNlZWluZyB0aGVcbiAqIGNvbnN0YW50IDB4ZmY4MCwgaXQgaGFzIG5vIG5vdGlvbiB0aGF0IGl0IGlzIGFjdHVhbGx5IGEgc2lnbmVkIG51bWJlci4gSXRcbiAqIGFzc3VtZXMgdGhhdCB3ZSd2ZSBpbnB1dCB0aGUgdW5zaWduZWQgdmFsdWUgMHhmZjgwLiBUaHVzLCB3aGVuIGl0IGRvZXMgdGhlXG4gKiBiaW5hcnkgbmVnYXRpb24sIGl0IGNhc3RzIGl0IGludG8gYSBzaWduZWQgdmFsdWUsIChwb3NpdGl2ZSAweGZmODApLiBUaGVuXG4gKiB3aGVuIHlvdSBwZXJmb3JtIGJpbmFyeSBuZWdhdGlvbiBvbiB0aGF0LCBpdCB0dXJucyBpdCBpbnRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuICpcbiAqIEluc3RlYWQsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gdXNlIHRoZSBmb2xsb3dpbmcgZ2VuZXJhbCBmb3JtdWxhLCB0aGF0IHdvcmtzXG4gKiBpbiBhIHJhdGhlciBKYXZhc2NyaXB0IGZyaWVuZGx5IHdheS4gSSdtIGdsYWQgd2UgZG9uJ3Qgc3VwcG9ydCB0aGlzIGtpbmQgb2ZcbiAqIHdlaXJkIG51bWJlcmluZyBzY2hlbWUgaW4gdGhlIGtlcm5lbC5cbiAqXG4gKiAoQklULU1BWCAtICh1bnNpZ25lZCl2YWwgKyAxKSAqIC0xXG4gKlxuICogVGhlIGFzdHV0ZSBvYnNlcnZlciwgbWF5IHRoaW5rIHRoYXQgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIDgtYml0IG51bWJlcnNcbiAqIChyZWFsbHkgaXQgaXNuJ3QgbmVjZXNzYXJ5IGZvciB0aGVtKS4gSG93ZXZlciwgd2hlbiB5b3UgZ2V0IDE2LWJpdCBudW1iZXJzLFxuICogeW91IGRvLiBMZXQncyBnbyBiYWNrIHRvIG91ciBwcmlvciBleGFtcGxlIGFuZCBzZWUgaG93IHRoaXMgd2lsbCBsb29rOlxuICpcbiAqICgweGZmZmYgLSAweGZmODAgKyAxKSAqIC0xXG4gKiAoMHgwMDdmICsgMSkgKiAtMVxuICogKDB4MDA4MCkgKiAtMVxuICovXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcbiAgdmFyIG5lZztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybjtcblxuICBuZWcgPSBidWZmZXJbb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXJbb2Zmc2V0XSk7XG4gIH1cblxuICByZXR1cm4gKCgweGZmIC0gYnVmZmVyW29mZnNldF0gKyAxKSAqIC0xKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZEludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIG5lZywgdmFsO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhbCA9IHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuICh2YWwpO1xuICB9XG5cbiAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZEZsb2F0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0JykucmVhZElFRUU3NTQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkRG91YmxlKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0JykucmVhZElFRUU3NTQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXQgaXNcbiAqIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90IGV4Y2VlZCB0aGVcbiAqIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqXG4gKiAgICAgIHZhbHVlICAgICAgICAgICBUaGUgbnVtYmVyIHRvIGNoZWNrIGZvciB2YWxpZGl0eVxuICpcbiAqICAgICAgbWF4ICAgICAgICAgICAgIFRoZSBtYXhpbXVtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IDAsXG4gICAgICAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkpKSkgPj4+XG4gICAgICAgICAgICAoaXNCaWdFbmRpYW4gPyAxIC0gaSA6IGkpICogODtcbiAgfVxuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXIubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSsrKSB7XG4gICAgYnVmZmVyW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAoaXNCaWdFbmRpYW4gPyAzIC0gaSA6IGkpICogOCkgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBXZSBub3cgbW92ZSBvbnRvIG91ciBmcmllbmRzIGluIHRoZSBzaWduZWQgbnVtYmVyIGNhdGVnb3J5LiBVbmxpa2UgdW5zaWduZWRcbiAqIG51bWJlcnMsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gd29ycnkgYSBiaXQgbW9yZSBhYm91dCBob3cgd2UgcHV0IHZhbHVlcyBpbnRvXG4gKiBhcnJheXMuIFNpbmNlIHdlIGFyZSBvbmx5IHdvcnJ5aW5nIGFib3V0IHNpZ25lZCAzMi1iaXQgdmFsdWVzLCB3ZSdyZSBpblxuICogc2xpZ2h0bHkgYmV0dGVyIHNoYXBlLiBVbmZvcnR1bmF0ZWx5LCB3ZSByZWFsbHkgY2FuJ3QgZG8gb3VyIGZhdm9yaXRlIGJpbmFyeVxuICogJiBpbiB0aGlzIHN5c3RlbS4gSXQgcmVhbGx5IHNlZW1zIHRvIGRvIHRoZSB3cm9uZyB0aGluZy4gRm9yIGV4YW1wbGU6XG4gKlxuICogPiAtMzIgJiAweGZmXG4gKiAyMjRcbiAqXG4gKiBXaGF0J3MgaGFwcGVuaW5nIGFib3ZlIGlzIHJlYWxseTogMHhlMCAmIDB4ZmYgPSAweGUwLiBIb3dldmVyLCB0aGUgcmVzdWx0cyBvZlxuICogdGhpcyBhcmVuJ3QgdHJlYXRlZCBhcyBhIHNpZ25lZCBudW1iZXIuIFVsdGltYXRlbHkgYSBiYWQgdGhpbmcuXG4gKlxuICogV2hhdCB3ZSdyZSBnb2luZyB0byB3YW50IHRvIGRvIGlzIGJhc2ljYWxseSBjcmVhdGUgdGhlIHVuc2lnbmVkIGVxdWl2YWxlbnQgb2ZcbiAqIG91ciByZXByZXNlbnRhdGlvbiBhbmQgcGFzcyB0aGF0IG9mZiB0byB0aGUgd3VpbnQqIGZ1bmN0aW9ucy4gVG8gZG8gdGhhdFxuICogd2UncmUgZ29pbmcgdG8gZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgcG9zaXRpdmVcbiAqICAgICAgd2UgY2FuIHBhc3MgaXQgZGlyZWN0bHkgb2ZmIHRvIHRoZSBlcXVpdmFsZW50IHd1aW50XG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAqICAgICAgd2UgZG8gdGhlIGZvbGxvd2luZyBjb21wdXRhdGlvbjpcbiAqICAgICAgICAgbWIgKyB2YWwgKyAxLCB3aGVyZVxuICogICAgICAgICBtYiAgIGlzIHRoZSBtYXhpbXVtIHVuc2lnbmVkIHZhbHVlIGluIHRoYXQgYnl0ZSBzaXplXG4gKiAgICAgICAgIHZhbCAgaXMgdGhlIEphdmFzY3JpcHQgbmVnYXRpdmUgaW50ZWdlclxuICpcbiAqXG4gKiBBcyBhIGNvbmNyZXRlIHZhbHVlLCB0YWtlIC0xMjguIEluIHNpZ25lZCAxNiBiaXRzIHRoaXMgd291bGQgYmUgMHhmZjgwLiBJZlxuICogeW91IGRvIG91dCB0aGUgY29tcHV0YXRpb25zOlxuICpcbiAqIDB4ZmZmZiAtIDEyOCArIDFcbiAqIDB4ZmZmZiAtIDEyN1xuICogMHhmZjgwXG4gKlxuICogWW91IGNhbiB0aGVuIGVuY29kZSB0aGlzIHZhbHVlIGFzIHRoZSBzaWduZWQgdmVyc2lvbi4gVGhpcyBpcyByZWFsbHkgcmF0aGVyXG4gKiBoYWNreSwgYnV0IGl0IHNob3VsZCB3b3JrIGFuZCBnZXQgdGhlIGpvYiBkb25lIHdoaWNoIGlzIG91ciBnb2FsIGhlcmUuXG4gKi9cblxuLypcbiAqIEEgc2VyaWVzIG9mIGNoZWNrcyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHNpZ25lZCAzMi1iaXQgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIHZlcmlmc2ludCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGbG9hdChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS53cml0ZUlFRUU3NTQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS53cml0ZUlFRUU3NTQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbn0pKCkiLCIoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG5cdFxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jztcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0cGxhY2VIb2xkZXJzID0gYjY0LmluZGV4T2YoJz0nKTtcblx0XHRwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIHBsYWNlSG9sZGVycyA6IDA7XG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBbXTsvL25ldyBVaW50OEFycmF5KGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAobG9va3VwLmluZGV4T2YoYjY0W2ldKSA8PCAxOCkgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPDwgMTIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pIDw8IDYpIHwgbG9va3VwLmluZGV4T2YoYjY0W2kgKyAzXSk7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KTtcblx0XHRcdGFyci5wdXNoKCh0bXAgJiAweEZGMDApID4+IDgpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMikgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPj4gNCk7XG5cdFx0XHRhcnIucHVzaCh0bXAgJiAweEZGKTtcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTApIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDQpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pID4+IDIpO1xuXHRcdFx0YXJyLnB1c2goKHRtcCA+PiA4KSAmIDB4RkYpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycjtcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aDtcblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl07XG5cdFx0fTtcblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKTtcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFt0ZW1wID4+IDJdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wIDw8IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSAnPT0nO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSk7XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAxMF07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPj4gNCkgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCAyKSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz0nO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheTtcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjQ7XG59KCkpO1xuIiwiKGZ1bmN0aW9uKCl7dmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMToge1xuICAgIGhleDogc2hhLmhleF9zaGExLFxuICAgIGJpbmFyeTogc2hhLmI2NF9zaGExLFxuICAgIGFzY2lpOiBzaGEuc3RyX3NoYTFcbiAgfSxcbiAgbWQ1OiB7XG4gICAgaGV4OiBtZDUuaGV4X21kNSxcbiAgICBiaW5hcnk6IG1kNS5iNjRfbWQ1LFxuICAgIGFzY2lpOiBtZDUuYW55X21kNVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgaWYoIWFsZ29yaXRobXNbYWxnXSlcbiAgICBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgdmFyIHMgPSAnJ1xuICB2YXIgX2FsZyA9IGFsZ29yaXRobXNbYWxnXVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHMgKz0gZGF0YVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgZW5jID0gZW5jIHx8ICdiaW5hcnknXG4gICAgICB2YXIgZm5cbiAgICAgIGlmKCEoZm4gPSBfYWxnW2VuY10pKVxuICAgICAgICBlcnJvcignZW5jb2Rpbmc6JywgZW5jICwgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBhbGdvcml0aG0nLCBhbGcpXG4gICAgICB2YXIgciA9IGZuKHMpXG4gICAgICBzID0gbnVsbCAvL25vdCBtZWFudCB0byB1c2UgdGhlIGhhc2ggYWZ0ZXIgeW91J3ZlIGNhbGxlZCBkaWdlc3QuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIG5ldyBCdWZmZXIocm5nKHNpemUpKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycik7IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVhY2goYSwgZikge1xuICBmb3IodmFyIGkgaW4gYSlcbiAgICBmKGFbaV0sIGkpXG59XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuZWFjaChbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlSG1hYydcbiwgJ2NyZWF0ZUN5cGhlcidcbiwgJ2NyZWF0ZUN5cGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURlZmZpZUhlbGxtYW4nXG4sICdwYmtkZjInXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuXG59KSgpIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG4vKlxuICogQ29uZmlndXJhYmxlIHZhcmlhYmxlcy4gWW91IG1heSBuZWVkIHRvIHR3ZWFrIHRoZXNlIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICogdGhlIHNlcnZlci1zaWRlLCBidXQgdGhlIGRlZmF1bHRzIHdvcmsgaW4gbW9zdCBjYXNlcy5cbiAqL1xudmFyIGhleGNhc2UgPSAwOyAgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqL1xudmFyIGI2NHBhZCAgPSBcIlwiOyAgLyogYmFzZS02NCBwYWQgY2hhcmFjdGVyLiBcIj1cIiBmb3Igc3RyaWN0IFJGQyBjb21wbGlhbmNlICAgKi9cblxuLypcbiAqIFRoZXNlIGFyZSB0aGUgZnVuY3Rpb25zIHlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gY2FsbFxuICogVGhleSB0YWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgaGV4IG9yIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIGhleF9tZDUocykgICAgeyByZXR1cm4gcnN0cjJoZXgocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSkpOyB9XG5mdW5jdGlvbiBiNjRfbWQ1KHMpICAgIHsgcmV0dXJuIHJzdHIyYjY0KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpKTsgfVxuZnVuY3Rpb24gYW55X21kNShzLCBlKSB7IHJldHVybiByc3RyMmFueShyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSwgZSk7IH1cbmZ1bmN0aW9uIGhleF9obWFjX21kNShrLCBkKVxuICB7IHJldHVybiByc3RyMmhleChyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpKTsgfVxuZnVuY3Rpb24gYjY0X2htYWNfbWQ1KGssIGQpXG4gIHsgcmV0dXJuIHJzdHIyYjY0KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSkpOyB9XG5mdW5jdGlvbiBhbnlfaG1hY19tZDUoaywgZCwgZSlcbiAgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSwgZSk7IH1cblxuLypcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2VsZi10ZXN0IHRvIHNlZSBpZiB0aGUgVk0gaXMgd29ya2luZ1xuICovXG5mdW5jdGlvbiBtZDVfdm1fdGVzdCgpXG57XG4gIHJldHVybiBoZXhfbWQ1KFwiYWJjXCIpLnRvTG93ZXJDYXNlKCkgPT0gXCI5MDAxNTA5ODNjZDI0ZmIwZDY5NjNmN2QyOGUxN2Y3MlwiO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYSByYXcgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHJfbWQ1KHMpXG57XG4gIHJldHVybiBiaW5sMnJzdHIoYmlubF9tZDUocnN0cjJiaW5sKHMpLCBzLmxlbmd0aCAqIDgpKTtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuICovXG5mdW5jdGlvbiByc3RyX2htYWNfbWQ1KGtleSwgZGF0YSlcbntcbiAgdmFyIGJrZXkgPSByc3RyMmJpbmwoa2V5KTtcbiAgaWYoYmtleS5sZW5ndGggPiAxNikgYmtleSA9IGJpbmxfbWQ1KGJrZXksIGtleS5sZW5ndGggKiA4KTtcblxuICB2YXIgaXBhZCA9IEFycmF5KDE2KSwgb3BhZCA9IEFycmF5KDE2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gIHtcbiAgICBpcGFkW2ldID0gYmtleVtpXSBeIDB4MzYzNjM2MzY7XG4gICAgb3BhZFtpXSA9IGJrZXlbaV0gXiAweDVDNUM1QzVDO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBiaW5sX21kNShpcGFkLmNvbmNhdChyc3RyMmJpbmwoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIDgpO1xuICByZXR1cm4gYmlubDJyc3RyKGJpbmxfbWQ1KG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxMjgpKTtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyMmhleChpbnB1dClcbntcbiAgdHJ5IHsgaGV4Y2FzZSB9IGNhdGNoKGUpIHsgaGV4Y2FzZT0wOyB9XG4gIHZhciBoZXhfdGFiID0gaGV4Y2FzZSA/IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiIDogXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICB2YXIgeDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxuICB7XG4gICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgb3V0cHV0ICs9IGhleF90YWIuY2hhckF0KCh4ID4+PiA0KSAmIDB4MEYpXG4gICAgICAgICAgICsgIGhleF90YWIuY2hhckF0KCB4ICAgICAgICAmIDB4MEYpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGJhc2UtNjQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYjY0KGlucHV0KVxue1xuICB0cnkgeyBiNjRwYWQgfSBjYXRjaChlKSB7IGI2NHBhZD0nJzsgfVxuICB2YXIgdGFiID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpXG4gIHtcbiAgICB2YXIgdHJpcGxldCA9IChpbnB1dC5jaGFyQ29kZUF0KGkpIDw8IDE2KVxuICAgICAgICAgICAgICAgIHwgKGkgKyAxIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKzEpIDw8IDggOiAwKVxuICAgICAgICAgICAgICAgIHwgKGkgKyAyIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKzIpICAgICAgOiAwKTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGkgKiA4ICsgaiAqIDYgPiBpbnB1dC5sZW5ndGggKiA4KSBvdXRwdXQgKz0gYjY0cGFkO1xuICAgICAgZWxzZSBvdXRwdXQgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+Pj4gNiooMy1qKSkgJiAweDNGKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFyYml0cmFyeSBzdHJpbmcgZW5jb2RpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJhbnkoaW5wdXQsIGVuY29kaW5nKVxue1xuICB2YXIgZGl2aXNvciA9IGVuY29kaW5nLmxlbmd0aDtcbiAgdmFyIGksIGosIHEsIHgsIHF1b3RpZW50O1xuXG4gIC8qIENvbnZlcnQgdG8gYW4gYXJyYXkgb2YgMTYtYml0IGJpZy1lbmRpYW4gdmFsdWVzLCBmb3JtaW5nIHRoZSBkaXZpZGVuZCAqL1xuICB2YXIgZGl2aWRlbmQgPSBBcnJheShNYXRoLmNlaWwoaW5wdXQubGVuZ3RoIC8gMikpO1xuICBmb3IoaSA9IDA7IGkgPCBkaXZpZGVuZC5sZW5ndGg7IGkrKylcbiAge1xuICAgIGRpdmlkZW5kW2ldID0gKGlucHV0LmNoYXJDb2RlQXQoaSAqIDIpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChpICogMiArIDEpO1xuICB9XG5cbiAgLypcbiAgICogUmVwZWF0ZWRseSBwZXJmb3JtIGEgbG9uZyBkaXZpc2lvbi4gVGhlIGJpbmFyeSBhcnJheSBmb3JtcyB0aGUgZGl2aWRlbmQsXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGVuY29kaW5nIGlzIHRoZSBkaXZpc29yLiBPbmNlIGNvbXB1dGVkLCB0aGUgcXVvdGllbnRcbiAgICogZm9ybXMgdGhlIGRpdmlkZW5kIGZvciB0aGUgbmV4dCBzdGVwLiBBbGwgcmVtYWluZGVycyBhcmUgc3RvcmVkIGZvciBsYXRlclxuICAgKiB1c2UuXG4gICAqL1xuICB2YXIgZnVsbF9sZW5ndGggPSBNYXRoLmNlaWwoaW5wdXQubGVuZ3RoICogOCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTWF0aC5sb2coZW5jb2RpbmcubGVuZ3RoKSAvIE1hdGgubG9nKDIpKSk7XG4gIHZhciByZW1haW5kZXJzID0gQXJyYXkoZnVsbF9sZW5ndGgpO1xuICBmb3IoaiA9IDA7IGogPCBmdWxsX2xlbmd0aDsgaisrKVxuICB7XG4gICAgcXVvdGllbnQgPSBBcnJheSgpO1xuICAgIHggPSAwO1xuICAgIGZvcihpID0gMDsgaSA8IGRpdmlkZW5kLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgIHggPSAoeCA8PCAxNikgKyBkaXZpZGVuZFtpXTtcbiAgICAgIHEgPSBNYXRoLmZsb29yKHggLyBkaXZpc29yKTtcbiAgICAgIHggLT0gcSAqIGRpdmlzb3I7XG4gICAgICBpZihxdW90aWVudC5sZW5ndGggPiAwIHx8IHEgPiAwKVxuICAgICAgICBxdW90aWVudFtxdW90aWVudC5sZW5ndGhdID0gcTtcbiAgICB9XG4gICAgcmVtYWluZGVyc1tqXSA9IHg7XG4gICAgZGl2aWRlbmQgPSBxdW90aWVudDtcbiAgfVxuXG4gIC8qIENvbnZlcnQgdGhlIHJlbWFpbmRlcnMgdG8gdGhlIG91dHB1dCBzdHJpbmcgKi9cbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcihpID0gcmVtYWluZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBvdXRwdXQgKz0gZW5jb2RpbmcuY2hhckF0KHJlbWFpbmRlcnNbaV0pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTguXG4gKiBGb3IgZWZmaWNpZW5jeSwgdGhpcyBhc3N1bWVzIHRoZSBpbnB1dCBpcyB2YWxpZCB1dGYtMTYuXG4gKi9cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjgoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgeCwgeTtcblxuICB3aGlsZSgrK2kgPCBpbnB1dC5sZW5ndGgpXG4gIHtcbiAgICAvKiBEZWNvZGUgdXRmLTE2IHN1cnJvZ2F0ZSBwYWlycyAqL1xuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgIHkgPSBpICsgMSA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJDb2RlQXQoaSArIDEpIDogMDtcbiAgICBpZigweEQ4MDAgPD0geCAmJiB4IDw9IDB4REJGRiAmJiAweERDMDAgPD0geSAmJiB5IDw9IDB4REZGRilcbiAgICB7XG4gICAgICB4ID0gMHgxMDAwMCArICgoeCAmIDB4MDNGRikgPDwgMTApICsgKHkgJiAweDAzRkYpO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIC8qIEVuY29kZSBvdXRwdXQgYXMgdXRmLTggKi9cbiAgICBpZih4IDw9IDB4N0YpXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgICBlbHNlIGlmKHggPD0gMHg3RkYpXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEMwIHwgKCh4ID4+PiA2ICkgJiAweDFGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoIHggICAgICAgICAmIDB4M0YpKTtcbiAgICBlbHNlIGlmKHggPD0gMHhGRkZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhFMCB8ICgoeCA+Pj4gMTIpICYgMHgwRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiA2ICkgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoIHggICAgICAgICAmIDB4M0YpKTtcbiAgICBlbHNlIGlmKHggPD0gMHgxRkZGRkYpXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEYwIHwgKCh4ID4+PiAxOCkgJiAweDA3KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDEyKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIEVuY29kZSBhIHN0cmluZyBhcyB1dGYtMTZcbiAqL1xuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZsZShpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggaW5wdXQuY2hhckNvZGVBdChpKSAgICAgICAgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dC5jaGFyQ29kZUF0KGkpID4+PiA4KSAmIDB4RkYpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBzdHIycnN0cl91dGYxNmJlKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dC5jaGFyQ29kZUF0KGkpID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmNoYXJDb2RlQXQoaSkgICAgICAgICYgMHhGRik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gcnN0cjJiaW5sKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gQXJyYXkoaW5wdXQubGVuZ3RoID4+IDIpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKVxuICAgIG91dHB1dFtpXSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiA4OyBpICs9IDgpXG4gICAgb3V0cHV0W2k+PjVdIHw9IChpbnB1dC5jaGFyQ29kZUF0KGkgLyA4KSAmIDB4RkYpIDw8IChpJTMyKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5sMnJzdHIoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogMzI7IGkgKz0gOClcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaW5wdXRbaT4+NV0gPj4+IChpICUgMzIpKSAmIDB4RkYpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gYmlubF9tZDUoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcblxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcbn1cblxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cbmZ1bmN0aW9uIG1kNV9jbW4ocSwgYSwgYiwgeCwgcywgdClcbntcbiAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksYik7XG59XG5mdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9oaChhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuXG5leHBvcnRzLmhleF9tZDUgPSBoZXhfbWQ1O1xuZXhwb3J0cy5iNjRfbWQ1ID0gYjY0X21kNTtcbmV4cG9ydHMuYW55X21kNSA9IGFueV9tZDU7XG4iLCIvLyBPcmlnaW5hbCBjb2RlIGFkYXB0ZWQgZnJvbSBSb2JlcnQgS2llZmZlci5cbi8vIGRldGFpbHMgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWRcbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIHZhciBtYXRoUk5HLCB3aGF0d2dSTkc7XG5cbiAgLy8gTk9URTogTWF0aC5yYW5kb20oKSBkb2VzIG5vdCBndWFyYW50ZWUgXCJjcnlwdG9ncmFwaGljIHF1YWxpdHlcIlxuICBtYXRoUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgcjtcblxuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgYnl0ZXNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgLy8gY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGluIHdlYmtpdC1iYXNlZCBicm93c2Vycy5cbiAgaWYgKF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB2YXIgX3JuZHMgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgd2hhdHdnUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kcyk7XG5cbiAgICAgIGZvciAodmFyIGMgPSAwIDsgYyA8IHNpemU7IGMrKykge1xuICAgICAgICBieXRlc1tjXSA9IF9ybmRzW2MgPj4gMl0gPj4+ICgoYyAmIDB4MDMpICogOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gd2hhdHdnUk5HIHx8IG1hdGhSTkc7XG5cbn0oKSkiLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG5leHBvcnRzLmhleF9zaGExID0gaGV4X3NoYTE7XG5leHBvcnRzLmI2NF9zaGExID0gYjY0X3NoYTE7XG5leHBvcnRzLnN0cl9zaGExID0gc3RyX3NoYTE7XG5leHBvcnRzLmhleF9obWFjX3NoYTEgPSBoZXhfaG1hY19zaGExO1xuZXhwb3J0cy5iNjRfaG1hY19zaGExID0gYjY0X2htYWNfc2hhMTtcbmV4cG9ydHMuc3RyX2htYWNfc2hhMSA9IHN0cl9obWFjX3NoYTE7XG5cbi8qXG4gKiBDb25maWd1cmFibGUgdmFyaWFibGVzLiBZb3UgbWF5IG5lZWQgdG8gdHdlYWsgdGhlc2UgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gKiB0aGUgc2VydmVyLXNpZGUsIGJ1dCB0aGUgZGVmYXVsdHMgd29yayBpbiBtb3N0IGNhc2VzLlxuICovXG52YXIgaGV4Y2FzZSA9IDA7ICAvKiBoZXggb3V0cHV0IGZvcm1hdC4gMCAtIGxvd2VyY2FzZTsgMSAtIHVwcGVyY2FzZSAgICAgICAgKi9cbnZhciBiNjRwYWQgID0gXCJcIjsgLyogYmFzZS02NCBwYWQgY2hhcmFjdGVyLiBcIj1cIiBmb3Igc3RyaWN0IFJGQyBjb21wbGlhbmNlICAgKi9cbnZhciBjaHJzeiAgID0gODsgIC8qIGJpdHMgcGVyIGlucHV0IGNoYXJhY3Rlci4gOCAtIEFTQ0lJOyAxNiAtIFVuaWNvZGUgICAgICAqL1xuXG4vKlxuICogVGhlc2UgYXJlIHRoZSBmdW5jdGlvbnMgeW91J2xsIHVzdWFsbHkgd2FudCB0byBjYWxsXG4gKiBUaGV5IHRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciBoZXggb3IgYmFzZS02NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gaGV4X3NoYTEocyl7cmV0dXJuIGJpbmIyaGV4KGNvcmVfc2hhMShzdHIyYmluYihzKSxzLmxlbmd0aCAqIGNocnN6KSk7fVxuZnVuY3Rpb24gYjY0X3NoYTEocyl7cmV0dXJuIGJpbmIyYjY0KGNvcmVfc2hhMShzdHIyYmluYihzKSxzLmxlbmd0aCAqIGNocnN6KSk7fVxuZnVuY3Rpb24gc3RyX3NoYTEocyl7cmV0dXJuIGJpbmIyc3RyKGNvcmVfc2hhMShzdHIyYmluYihzKSxzLmxlbmd0aCAqIGNocnN6KSk7fVxuZnVuY3Rpb24gaGV4X2htYWNfc2hhMShrZXksIGRhdGEpeyByZXR1cm4gYmluYjJoZXgoY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKSk7fVxuZnVuY3Rpb24gYjY0X2htYWNfc2hhMShrZXksIGRhdGEpeyByZXR1cm4gYmluYjJiNjQoY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKSk7fVxuZnVuY3Rpb24gc3RyX2htYWNfc2hhMShrZXksIGRhdGEpeyByZXR1cm4gYmluYjJzdHIoY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKSk7fVxuXG4vKlxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXG4gKi9cbmZ1bmN0aW9uIHNoYTFfdm1fdGVzdCgpXG57XG4gIHJldHVybiBoZXhfc2hhMShcImFiY1wiKSA9PSBcImE5OTkzZTM2NDcwNjgxNmFiYTNlMjU3MTc4NTBjMjZjOWNkMGQ4OWRcIjtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX3NoYTEoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuXG4gIHZhciB3ID0gQXJyYXkoODApO1xuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcbiAgdmFyIGUgPSAtMTAwOTU4OTc3NjtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgdmFyIG9sZGUgPSBlO1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDgwOyBqKyspXG4gICAge1xuICAgICAgaWYoaiA8IDE2KSB3W2pdID0geFtpICsgal07XG4gICAgICBlbHNlIHdbal0gPSByb2wod1tqLTNdIF4gd1tqLThdIF4gd1tqLTE0XSBeIHdbai0xNl0sIDEpO1xuICAgICAgdmFyIHQgPSBzYWZlX2FkZChzYWZlX2FkZChyb2woYSwgNSksIHNoYTFfZnQoaiwgYiwgYywgZCkpLFxuICAgICAgICAgICAgICAgICAgICAgICBzYWZlX2FkZChzYWZlX2FkZChlLCB3W2pdKSwgc2hhMV9rdChqKSkpO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSByb2woYiwgMzApO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gICAgZSA9IHNhZmVfYWRkKGUsIG9sZGUpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkLCBlKTtcblxufVxuXG4vKlxuICogUGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgdHJpcGxldCBjb21iaW5hdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAqIGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2Z0KHQsIGIsIGMsIGQpXG57XG4gIGlmKHQgPCAyMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpO1xuICBpZih0IDwgNDApIHJldHVybiBiIF4gYyBeIGQ7XG4gIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgcmV0dXJuIGIgXiBjIF4gZDtcbn1cblxuLypcbiAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgYWRkaXRpdmUgY29uc3RhbnQgZm9yIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2t0KHQpXG57XG4gIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XG4gICAgICAgICAodCA8IDYwKSA/IC0xODk0MDA3NTg4IDogLTg5OTQ5NzUxNDtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgSE1BQy1TSEExIG9mIGEga2V5IGFuZCBzb21lIGRhdGFcbiAqL1xuZnVuY3Rpb24gY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKVxue1xuICB2YXIgYmtleSA9IHN0cjJiaW5iKGtleSk7XG4gIGlmKGJrZXkubGVuZ3RoID4gMTYpIGJrZXkgPSBjb3JlX3NoYTEoYmtleSwga2V5Lmxlbmd0aCAqIGNocnN6KTtcblxuICB2YXIgaXBhZCA9IEFycmF5KDE2KSwgb3BhZCA9IEFycmF5KDE2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gIHtcbiAgICBpcGFkW2ldID0gYmtleVtpXSBeIDB4MzYzNjM2MzY7XG4gICAgb3BhZFtpXSA9IGJrZXlbaV0gXiAweDVDNUM1QzVDO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBjb3JlX3NoYTEoaXBhZC5jb25jYXQoc3RyMmJpbmIoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIGNvcmVfc2hhMShvcGFkLmNvbmNhdChoYXNoKSwgNTEyICsgMTYwKTtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG4vKlxuICogQ29udmVydCBhbiA4LWJpdCBvciAxNi1iaXQgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHNcbiAqIEluIDgtYml0IGZ1bmN0aW9uLCBjaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaS1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIHN0cjJiaW5iKHN0cilcbntcbiAgdmFyIGJpbiA9IEFycmF5KCk7XG4gIHZhciBtYXNrID0gKDEgPDwgY2hyc3opIC0gMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGggKiBjaHJzejsgaSArPSBjaHJzeilcbiAgICBiaW5baT4+NV0gfD0gKHN0ci5jaGFyQ29kZUF0KGkgLyBjaHJzeikgJiBtYXNrKSA8PCAoMzIgLSBjaHJzeiAtIGklMzIpO1xuICByZXR1cm4gYmluO1xufVxuXG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmIyc3RyKGJpbilcbntcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHZhciBtYXNrID0gKDEgPDwgY2hyc3opIC0gMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbi5sZW5ndGggKiAzMjsgaSArPSBjaHJzeilcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYmluW2k+PjVdID4+PiAoMzIgLSBjaHJzeiAtIGklMzIpKSAmIG1hc2spO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzIHRvIGEgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmluYjJoZXgoYmluYXJyYXkpXG57XG4gIHZhciBoZXhfdGFiID0gaGV4Y2FzZSA/IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiIDogXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIHZhciBzdHIgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoICogNDsgaSsrKVxuICB7XG4gICAgc3RyICs9IGhleF90YWIuY2hhckF0KChiaW5hcnJheVtpPj4yXSA+PiAoKDMgLSBpJTQpKjgrNCkpICYgMHhGKSArXG4gICAgICAgICAgIGhleF90YWIuY2hhckF0KChiaW5hcnJheVtpPj4yXSA+PiAoKDMgLSBpJTQpKjggICkpICYgMHhGKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzIHRvIGEgYmFzZS02NCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmluYjJiNjQoYmluYXJyYXkpXG57XG4gIHZhciB0YWIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGggKiA0OyBpICs9IDMpXG4gIHtcbiAgICB2YXIgdHJpcGxldCA9ICgoKGJpbmFycmF5W2kgICA+PiAyXSA+PiA4ICogKDMgLSAgaSAgICU0KSkgJiAweEZGKSA8PCAxNilcbiAgICAgICAgICAgICAgICB8ICgoKGJpbmFycmF5W2krMSA+PiAyXSA+PiA4ICogKDMgLSAoaSsxKSU0KSkgJiAweEZGKSA8PCA4IClcbiAgICAgICAgICAgICAgICB8ICAoKGJpbmFycmF5W2krMiA+PiAyXSA+PiA4ICogKDMgLSAoaSsyKSU0KSkgJiAweEZGKTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGkgKiA4ICsgaiAqIDYgPiBiaW5hcnJheS5sZW5ndGggKiAzMikgc3RyICs9IGI2NHBhZDtcbiAgICAgIGVsc2Ugc3RyICs9IHRhYi5jaGFyQXQoKHRyaXBsZXQgPj4gNiooMy1qKSkgJiAweDNGKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuIiwidmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKTtcblxuaHR0cC5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCkgcGFyYW1zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgIGlmICghcGFyYW1zLnBvcnQpIHBhcmFtcy5wb3J0ID0gd2luZG93LmxvY2F0aW9uLnBvcnQ7XG4gICAgaWYgKCFwYXJhbXMuc2NoZW1lKSBwYXJhbXMuc2NoZW1lID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gICAgXG4gICAgdmFyIHJlcSA9IG5ldyBSZXF1ZXN0KG5ldyB4aHJIdHRwLCBwYXJhbXMpO1xuICAgIGlmIChjYikgcmVxLm9uKCdyZXNwb25zZScsIGNiKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuaHR0cC5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIHBhcmFtcy5tZXRob2QgPSAnR0VUJztcbiAgICB2YXIgcmVxID0gaHR0cC5yZXF1ZXN0KHBhcmFtcywgY2IpO1xuICAgIHJlcS5lbmQoKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuaHR0cC5BZ2VudCA9IGZ1bmN0aW9uICgpIHt9O1xuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDQ7XG5cbnZhciB4aHJIdHRwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB3aW5kb3cgb2JqZWN0IHByZXNlbnQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIHZhciBheHMgPSBbXG4gICAgICAgICAgICAnTXN4bWwyLlhNTEhUVFAuNi4wJyxcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC4zLjAnLFxuICAgICAgICAgICAgJ01pY3Jvc29mdC5YTUxIVFRQJ1xuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYXggPSBuZXcod2luZG93LkFjdGl2ZVhPYmplY3QpKGF4c1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhfID0gYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBheCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhfO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhamF4IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgfVxufSkoKTtcbiIsIihmdW5jdGlvbigpe3ZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBSZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcbnZhciBjb25jYXRTdHJlYW0gPSByZXF1aXJlKCdjb25jYXQtc3RyZWFtJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IGNvbmNhdFN0cmVhbSgpXG4gICAgXG4gICAgdmFyIHVyaSA9IHBhcmFtcy5ob3N0XG4gICAgICAgICsgKHBhcmFtcy5wb3J0ID8gJzonICsgcGFyYW1zLnBvcnQgOiAnJylcbiAgICAgICAgKyAocGFyYW1zLnBhdGggfHwgJy8nKVxuICAgIDtcbiAgICBcbiAgICB4aHIub3BlbihcbiAgICAgICAgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgKHBhcmFtcy5zY2hlbWUgfHwgJ2h0dHAnKSArICc6Ly8nICsgdXJpLFxuICAgICAgICB0cnVlXG4gICAgKTtcbiAgICBcbiAgICBpZiAocGFyYW1zLmhlYWRlcnMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHBhcmFtcy5oZWFkZXJzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc1NhZmVSZXF1ZXN0SGVhZGVyKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zLmhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChwYXJhbXMuYXV0aCkge1xuICAgICAgICAvL2Jhc2ljIGF1dGhcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIG5ldyBCdWZmZXIocGFyYW1zLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IG5ldyBSZXNwb25zZTtcbiAgICByZXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfSk7XG4gICAgXG4gICAgcmVzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG4gICAgfSk7XG4gICAgXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzLmhhbmRsZSh4aHIpO1xuICAgIH07XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZSA9IG5ldyBTdHJlYW07XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS53cml0ZShzKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB0aGlzLmJvZHkud3JpdGUocyk7XG4gICAgdGhpcy5ib2R5LmVuZCgpXG4gICAgdGhpcy54aHIuc2VuZCh0aGlzLmJvZHkuZ2V0Qm9keSgpKTtcbn07XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhL21vemlsbGEtY2VudHJhbC9jb250ZW50L2Jhc2Uvc3JjL25zWE1MSHR0cFJlcXVlc3QuY3BwLmh0bWxcblJlcXVlc3QudW5zYWZlSGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVzZXItYWdlbnRcIixcbiAgICBcInZpYVwiXG5dO1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pc1NhZmVSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcbiAgICBpZiAoIWhlYWRlck5hbWUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaW5kZXhPZihSZXF1ZXN0LnVuc2FmZUhlYWRlcnMsIGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxufSkoKSIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudmFyIFJlc3BvbnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlID0gbmV3IFN0cmVhbTtcblxudmFyIGNhcGFibGUgPSB7XG4gICAgc3RyZWFtaW5nIDogdHJ1ZSxcbiAgICBzdGF0dXMyIDogdHJ1ZVxufTtcblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzIChyZXMpIHtcbiAgICB2YXIgbGluZXMgPSByZXMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoL1xccj9cXG4vKTtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGxpbmUgPT09ICcnKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXihbXjpdKyk6XFxzKiguKikvKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBtWzFdLnRvTG93ZXJDYXNlKCksIHZhbHVlID0gbVsyXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShoZWFkZXJzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFsgaGVhZGVyc1trZXldLCB2YWx1ZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyc1tsaW5lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXRSZXNwb25zZSA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgICB2YXIgcmVzcFR5cGUgPSBTdHJpbmcoeGhyLnJlc3BvbnNlVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocmVzcFR5cGUgPT09ICdibG9iJykgcmV0dXJuIHhoci5yZXNwb25zZUJsb2IgfHwgeGhyLnJlc3BvbnNlO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykgcmV0dXJuIHhoci5yZXNwb25zZTtcbiAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKHJlcy5yZWFkeVN0YXRlID09PSAyICYmIGNhcGFibGUuc3RhdHVzMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RhdHVzMiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwYWJsZS5zdHJlYW1pbmcgJiYgcmVzLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge31cbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RyZWFtaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdERhdGEocmVzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzLmdldFJlc3BvbnNlKHJlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB9XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX2VtaXREYXRhID0gZnVuY3Rpb24gKHJlcykge1xuICAgIHZhciByZXNwQm9keSA9IHRoaXMuZ2V0UmVzcG9uc2UocmVzKTtcbiAgICBpZiAocmVzcEJvZHkudG9TdHJpbmcoKS5tYXRjaCgvQXJyYXlCdWZmZXIvKSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBuZXcgVWludDhBcnJheShyZXNwQm9keSwgdGhpcy5vZmZzZXQpKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSByZXNwQm9keS5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwQm9keS5sZW5ndGggPiB0aGlzLm9mZnNldCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXNwQm9keS5zbGljZSh0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5Lmxlbmd0aDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBDb25jYXRTdHJlYW0oY2IpIHtcbiAgc3RyZWFtLlN0cmVhbS5jYWxsKHRoaXMpXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gIGlmIChjYikgdGhpcy5jYiA9IGNiXG4gIHRoaXMuYm9keSA9IFtdXG4gIGlmICh0aGlzLmNiKSB0aGlzLm9uKCdlcnJvcicsIGNiKVxufVxuXG51dGlsLmluaGVyaXRzKENvbmNhdFN0cmVhbSwgc3RyZWFtLlN0cmVhbSlcblxuQ29uY2F0U3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHRoaXMuYm9keS5wdXNoKGNodW5rKVxufVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLmFycmF5Q29uY2F0ID0gZnVuY3Rpb24oYXJycykge1xuICBpZiAoYXJycy5sZW5ndGggPT09IDApIHJldHVybiBbXVxuICBpZiAoYXJycy5sZW5ndGggPT09IDEpIHJldHVybiBhcnJzWzBdXG4gIHJldHVybiBhcnJzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYikgfSlcbn1cblxuQ29uY2F0U3RyZWFtLnByb3RvdHlwZS5pc0FycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShhcnIpXG4gIHZhciBpc1R5cGVkQXJyYXkgPSBhcnIudG9TdHJpbmcoKS5tYXRjaCgvQXJyYXkvKVxuICByZXR1cm4gaXNBcnJheSB8fCBpc1R5cGVkQXJyYXlcbn1cblxuQ29uY2F0U3RyZWFtLnByb3RvdHlwZS5nZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5ib2R5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIGlmICh0eXBlb2YodGhpcy5ib2R5WzBdKSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRoaXMuYm9keS5qb2luKCcnKVxuICBpZiAodGhpcy5pc0FycmF5KHRoaXMuYm9keVswXSkpIHJldHVybiB0aGlzLmFycmF5Q29uY2F0KHRoaXMuYm9keSlcbiAgaWYgKHR5cGVvZihCdWZmZXIpICE9PSBcInVuZGVmaW5lZFwiICYmIEJ1ZmZlci5pc0J1ZmZlcih0aGlzLmJvZHlbMF0pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQodGhpcy5ib2R5KVxuICB9XG4gIHJldHVybiB0aGlzLmJvZHlcbn1cblxuQ29uY2F0U3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoZmFsc2UsIHRoaXMuZ2V0Qm9keSgpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG4gIHJldHVybiBuZXcgQ29uY2F0U3RyZWFtKGNiKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Db25jYXRTdHJlYW0gPSBDb25jYXRTdHJlYW1cblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9CdWZmZXJcIikuQnVmZmVyKSIsInJlcXVpcmU9KGZ1bmN0aW9uKGUsdCxuLHIpe2Z1bmN0aW9uIGkocil7aWYoIW5bcl0pe2lmKCF0W3JdKXtpZihlKXJldHVybiBlKHIpO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrcitcIidcIil9dmFyIHM9bltyXT17ZXhwb3J0czp7fX07dFtyXVswXShmdW5jdGlvbihlKXt2YXIgbj10W3JdWzFdW2VdO3JldHVybiBpKG4/bjplKX0scyxzLmV4cG9ydHMpfXJldHVybiBuW3JdLmV4cG9ydHN9Zm9yKHZhciBzPTA7czxyLmxlbmd0aDtzKyspaShyW3NdKTtyZXR1cm4gaX0pKHR5cGVvZiByZXF1aXJlIT09XCJ1bmRlZmluZWRcIiYmcmVxdWlyZSx7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBVVElMSVRZXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG59O1xudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gW3RoaXMubmFtZSArICc6JywgdGhpcy5tZXNzYWdlXS5qb2luKCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMubmFtZSArICc6JyxcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuYWN0dWFsLCByZXBsYWNlciksIDEyOCksXG4gICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkodGhpcy5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvci5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCBndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCEhIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhY3R1YWwpICYmIEJ1ZmZlci5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKCdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKCdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG59LHtcInV0aWxcIjoyLFwiYnVmZmVyXCI6M31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0RhdGUgPSBmdW5jdGlvbihvYmope3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nfTtcbmV4cG9ydHMuaXNSZWdFeHAgPSBmdW5jdGlvbihvYmope3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSd9O1xuXG5cbmV4cG9ydHMucHJpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMucHV0cyA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5kZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5cbmV4cG9ydHMuaW5zcGVjdCA9IGZ1bmN0aW9uKG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycykge1xuICB2YXIgc2VlbiA9IFtdO1xuXG4gIHZhciBzdHlsaXplID0gZnVuY3Rpb24oc3RyLCBzdHlsZVR5cGUpIHtcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcbiAgICB2YXIgc3R5bGVzID1cbiAgICAgICAgeyAnYm9sZCcgOiBbMSwgMjJdLFxuICAgICAgICAgICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgICAgICAgICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICAgICAgICAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgICAgICAgICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICAgICAgICAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICAgICAgICAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAgICAgICAgICdibHVlJyA6IFszNCwgMzldLFxuICAgICAgICAgICdjeWFuJyA6IFszNiwgMzldLFxuICAgICAgICAgICdncmVlbicgOiBbMzIsIDM5XSxcbiAgICAgICAgICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgICAgICAgICAncmVkJyA6IFszMSwgMzldLFxuICAgICAgICAgICd5ZWxsb3cnIDogWzMzLCAzOV0gfTtcblxuICAgIHZhciBzdHlsZSA9XG4gICAgICAgIHsgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICAgICAgICAgJ251bWJlcic6ICdibHVlJyxcbiAgICAgICAgICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAgICAgICAgICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICAgICAgICAgJ251bGwnOiAnYm9sZCcsXG4gICAgICAgICAgJ3N0cmluZyc6ICdncmVlbicsXG4gICAgICAgICAgJ2RhdGUnOiAnbWFnZW50YScsXG4gICAgICAgICAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgICAgICAgICAncmVnZXhwJzogJ3JlZCcgfVtzdHlsZVR5cGVdO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICByZXR1cm4gJ1xcMDMzWycgKyBzdHlsZXNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgICAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMV0gKyAnbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xuICBpZiAoISBjb2xvcnMpIHtcbiAgICBzdHlsaXplID0gZnVuY3Rpb24oc3RyLCBzdHlsZVR5cGUpIHsgcmV0dXJuIHN0cjsgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gICAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAgIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgICAgdmFsdWUgIT09IGV4cG9ydHMgJiZcbiAgICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuXG4gICAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBzdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiBzdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gICAgfVxuICAgIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gICAgdmFyIHZpc2libGVfa2V5cyA9IE9iamVjdF9rZXlzKHZhbHVlKTtcbiAgICB2YXIga2V5cyA9IHNob3dIaWRkZW4gPyBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkgOiB2aXNpYmxlX2tleXM7XG5cbiAgICAvLyBGdW5jdGlvbnMgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzdHlsaXplKCcnICsgdmFsdWUsICdyZWdleHAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICAgIHJldHVybiBzdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEYXRlcyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzdHlsaXplKHZhbHVlLnRvVVRDU3RyaW5nKCksICdkYXRlJyk7XG4gICAgfVxuXG4gICAgdmFyIGJhc2UsIHR5cGUsIGJyYWNlcztcbiAgICAvLyBEZXRlcm1pbmUgdGhlIG9iamVjdCB0eXBlXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0eXBlID0gJ0FycmF5JztcbiAgICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSAnT2JqZWN0JztcbiAgICAgIGJyYWNlcyA9IFsneycsICd9J107XG4gICAgfVxuXG4gICAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIGJhc2UgPSAoaXNSZWdFeHAodmFsdWUpKSA/ICcgJyArIHZhbHVlIDogJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9ICcnO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICBiYXNlID0gJyAnICsgdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzdHlsaXplKCcnICsgdmFsdWUsICdyZWdleHAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2Vlbi5wdXNoKHZhbHVlKTtcblxuICAgIHZhciBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBuYW1lLCBzdHI7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXykge1xuICAgICAgICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmlzaWJsZV9rZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgICAgIH1cbiAgICAgIGlmICghc3RyKSB7XG4gICAgICAgIGlmIChzZWVuLmluZGV4T2YodmFsdWVba2V5XSkgPCAwKSB7XG4gICAgICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0KHZhbHVlW2tleV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ0FycmF5JyAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgICAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICAgICAgbmFtZSA9IHN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbiAgICB9KTtcblxuICAgIHNlZW4ucG9wKCk7XG5cbiAgICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICAgIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgbnVtTGluZXNFc3QrKztcbiAgICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICAgIHJldHVybiBwcmV2ICsgY3VyLmxlbmd0aCArIDE7XG4gICAgfSwgMCk7XG5cbiAgICBpZiAobGVuZ3RoID4gNTApIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArXG4gICAgICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIGJyYWNlc1sxXTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICByZXR1cm4gZm9ybWF0KG9iaiwgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyAyIDogZGVwdGgpKTtcbn07XG5cblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gYXIgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgQXJyYXkuaXNBcnJheShhcikgfHxcbiAgICAgICAgIChhciAmJiBhciAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBpc0FycmF5KGFyLl9fcHJvdG9fXykpO1xufVxuXG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiByZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgICh0eXBlb2YgcmUgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKTtcbn1cblxuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICBpZiAoZCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIGQgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm9wZXJ0aWVzID0gRGF0ZS5wcm90b3R5cGUgJiYgT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXMoRGF0ZS5wcm90b3R5cGUpO1xuICB2YXIgcHJvdG8gPSBkLl9fcHJvdG9fXyAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhkLl9fcHJvdG9fXyk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwcm90bykgPT09IEpTT04uc3RyaW5naWZ5KHByb3BlcnRpZXMpO1xufVxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbiAobXNnKSB7fTtcblxuZXhwb3J0cy5wdW1wID0gbnVsbDtcblxudmFyIE9iamVjdF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgLy8gZnJvbSBlczUtc2hpbVxuICAgIHZhciBvYmplY3Q7XG4gICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICBvYmplY3QgPSB7ICdfX3Byb3RvX18nIDogbnVsbCB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICd0eXBlb2YgcHJvdG90eXBlWycgKyAodHlwZW9mIHByb3RvdHlwZSkgKyAnXSAhPSBcXCdvYmplY3RcXCcnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBUeXBlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICBvYmplY3QgPSBuZXcgVHlwZSgpO1xuICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdF9jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogY3RvcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKHR5cGVvZiBmICE9PSAnc3RyaW5nJykge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChleHBvcnRzLmluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOiByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvcih2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pe1xuICAgIGlmICh4ID09PSBudWxsIHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBleHBvcnRzLmluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG59LHtcImV2ZW50c1wiOjR9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5zb3VyY2UgPT09IHdpbmRvdyAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKHByb2Nlc3Mpe2lmICghcHJvY2Vzcy5FdmVudEVtaXR0ZXIpIHByb2Nlc3MuRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50RW1pdHRlciA9IHByb2Nlc3MuRXZlbnRFbWl0dGVyO1xudmFyIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gQXJyYXkuaXNBcnJheVxuICAgIDogZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgfVxuO1xuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeCA9PT0geHNbaV0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW5cbi8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4vL1xuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gbjtcbn07XG5cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNBcnJheSh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSlcbiAgICB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gZmFsc2U7XG4gIHZhciBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBpZiAoIWhhbmRsZXIpIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBFdmVudEVtaXR0ZXIgaXMgZGVmaW5lZCBpbiBzcmMvbm9kZV9ldmVudHMuY2Ncbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCgpIGlzIGFsc28gZGVmaW5lZCB0aGVyZS5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhZGRMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT0gXCJuZXdMaXN0ZW5lcnNcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgICB2YXIgbTtcbiAgICAgIGlmICh0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbSA9IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYub24odHlwZSwgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzQXJyYXkobGlzdCkpIHtcbiAgICB2YXIgaSA9IGluZGV4T2YobGlzdCwgbGlzdGVuZXIpO1xuICAgIGlmIChpIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDApXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gbGlzdGVuZXIpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAodHlwZSAmJiB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcbiAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdO1xufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKVxufSx7XCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiOjZ9XSxcImJ1ZmZlci1icm93c2VyaWZ5XCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgncTlUeENDJyk7XG59LHt9XSxcInE5VHhDQ1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkgKiA4O1xuICB9XG5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDQpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSx7XCJhc3NlcnRcIjoxLFwiLi9idWZmZXJfaWVlZTc1NFwiOjUsXCJiYXNlNjQtanNcIjo3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG5cdFxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jztcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0cGxhY2VIb2xkZXJzID0gYjY0LmluZGV4T2YoJz0nKTtcblx0XHRwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIHBsYWNlSG9sZGVycyA6IDA7XG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBbXTsvL25ldyBVaW50OEFycmF5KGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAobG9va3VwLmluZGV4T2YoYjY0W2ldKSA8PCAxOCkgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPDwgMTIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pIDw8IDYpIHwgbG9va3VwLmluZGV4T2YoYjY0W2kgKyAzXSk7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KTtcblx0XHRcdGFyci5wdXNoKCh0bXAgJiAweEZGMDApID4+IDgpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMikgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPj4gNCk7XG5cdFx0XHRhcnIucHVzaCh0bXAgJiAweEZGKTtcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTApIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDQpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pID4+IDIpO1xuXHRcdFx0YXJyLnB1c2goKHRtcCA+PiA4KSAmIDB4RkYpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycjtcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aDtcblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl07XG5cdFx0fTtcblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKTtcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFt0ZW1wID4+IDJdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wIDw8IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSAnPT0nO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSk7XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAxMF07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPj4gNCkgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCAyKSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz0nO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheTtcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjQ7XG59KCkpO1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc2l6ZSkge1xuICAgIHRoaXMubGVuZ3RoID0gc2l6ZTtcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG5cbmZ1bmN0aW9uIHRvSGV4KG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpO1xuICByZXR1cm4gbi50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgIGlmIChzdHIuY2hhckNvZGVBdChpKSA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLmNoYXJBdChpKSkuc3Vic3RyKDEpLnNwbGl0KCclJyk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSk7XG4gICAgfVxuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrIClcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaCggc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGICk7XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpIHtcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikudG9CeXRlQXJyYXkoc3RyKTtcbn1cblxuU2xvd0J1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChlbmNvZGluZyB8fCBcInV0ZjhcIikge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aCAvIDI7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGg7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmFzZTY0V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLmZyb21CeXRlQXJyYXkoYnl0ZXMpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhcihzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCk7IC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnV0ZjhTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciByZXMgPSBcIlwiO1xuICB2YXIgdG1wID0gXCJcIjtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGlmIChieXRlc1tpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgdG1wID0gXCJcIjtcbiAgICB9IGVsc2VcbiAgICAgIHRtcCArPSBcIiVcIiArIGJ5dGVzW2ldLnRvU3RyaW5nKDE2KTtcblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJldCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvdXQgPSBbXSxcbiAgICAgIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiAnPFNsb3dCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPic7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmhleFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICB2YXIgb3V0ID0gJyc7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KHRoaXNbaV0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5sZW5ndGg7XG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoK2VuZCA9PSBzdGFydCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmhleFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSArb2Zmc2V0IHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gK2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgfVxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IGJ5dGU7XG4gIH1cbiAgU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDI7XG4gIHJldHVybiBpO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgIGxlbmd0aCA9IHN3YXA7XG4gIH1cblxuICBvZmZzZXQgPSArb2Zmc2V0IHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gK2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuU2xvd0J1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcywgZW5kIC0gc3RhcnQsICtzdGFydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRzdGFydCwgc291cmNlc3RhcnQsIHNvdXJjZWVuZCkge1xuICB2YXIgdGVtcCA9IFtdO1xuICBmb3IgKHZhciBpPXNvdXJjZXN0YXJ0OyBpPHNvdXJjZWVuZDsgaSsrKSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiB0aGlzW2ldICE9PSAndW5kZWZpbmVkJywgXCJjb3B5aW5nIHVuZGVmaW5lZCBidWZmZXIgYnl0ZXMhXCIpO1xuICAgIHRlbXAucHVzaCh0aGlzW2ldKTtcbiAgfVxuXG4gIGZvciAodmFyIGk9dGFyZ2V0c3RhcnQ7IGk8dGFyZ2V0c3RhcnQrdGVtcC5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldFtpXSA9IHRlbXBbaS10YXJnZXRzdGFydF07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNvZXJjZShsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoO1xufVxuXG5cbi8vIEJ1ZmZlclxuXG5mdW5jdGlvbiBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBvZmZzZXQpO1xuICB9XG5cbiAgdmFyIHR5cGU7XG5cbiAgLy8gQXJlIHdlIHNsaWNpbmc/XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKGVuY29kaW5nKTtcbiAgICB0aGlzLnBhcmVudCA9IHN1YmplY3Q7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gICAgc3dpdGNoICh0eXBlID0gdHlwZW9mIHN1YmplY3QpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOiAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5IG9yIHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBCdWZmZXIucG9vbFNpemUpIHtcbiAgICAgIC8vIEJpZyBidWZmZXIsIGp1c3QgYWxsb2Mgb25lLlxuICAgICAgdGhpcy5wYXJlbnQgPSBuZXcgU2xvd0J1ZmZlcih0aGlzLmxlbmd0aCk7XG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU21hbGwgYnVmZmVyLlxuICAgICAgaWYgKCFwb29sIHx8IHBvb2wubGVuZ3RoIC0gcG9vbC51c2VkIDwgdGhpcy5sZW5ndGgpIGFsbG9jUG9vbCgpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwb29sO1xuICAgICAgdGhpcy5vZmZzZXQgPSBwb29sLnVzZWQ7XG4gICAgICBwb29sLnVzZWQgKz0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5LlxuICAgIGlmIChpc0FycmF5SXNoKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSA9IHN1YmplY3RbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXZSBhcmUgYSBzdHJpbmdcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZyk7XG4gICAgfVxuICB9XG5cbn1cblxuZnVuY3Rpb24gaXNBcnJheUlzaChzdWJqZWN0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXI7XG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcblxuQnVmZmVyLnBvb2xTaXplID0gOCAqIDEwMjQ7XG52YXIgcG9vbDtcblxuZnVuY3Rpb24gYWxsb2NQb29sKCkge1xuICBwb29sID0gbmV3IFNsb3dCdWZmZXIoQnVmZmVyLnBvb2xTaXplKTtcbiAgcG9vbC51c2VkID0gMDtcbn1cblxuXG4vLyBTdGF0aWMgbWV0aG9kc1xuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICByZXR1cm4gYiBpbnN0YW5jZW9mIEJ1ZmZlciB8fCBiIGluc3RhbmNlb2YgU2xvd0J1ZmZlcjtcbn07XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4gXFxcbiAgICAgIGxpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LlwiKTtcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF07XG4gIH1cblxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgICAgdG90YWxMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8vIEluc3BlY3RcbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHZhciBvdXQgPSBbXSxcbiAgICAgIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPic7XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChpLCB2KSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXSA9IHY7XG59O1xuXG5cbi8vIHdyaXRlKHN0cmluZywgb2Zmc2V0ID0gMCwgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aC1vZmZzZXQsIGVuY29kaW5nID0gJ3V0ZjgnKVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgIGxlbmd0aCA9IHN3YXA7XG4gIH1cblxuICBvZmZzZXQgPSArb2Zmc2V0IHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gK2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICB2YXIgcmV0O1xuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmhleFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LnV0ZjhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5hc2NpaVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iaW5hcnlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJhc2U2NFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LnVjczJXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cblxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbjtcblxuICByZXR1cm4gcmV0O1xufTtcblxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICh0eXBlb2Ygc3RhcnQgPT0gJ3VuZGVmaW5lZCcgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kID0gMDtcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgKyB0aGlzLm9mZnNldDtcbiAgZW5kID0gZW5kICsgdGhpcy5vZmZzZXQ7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuaGV4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJpbmFyeVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gYnl0ZUxlbmd0aFxuQnVmZmVyLmJ5dGVMZW5ndGggPSBTbG93QnVmZmVyLmJ5dGVMZW5ndGg7XG5cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIHZhbHVlIHx8ICh2YWx1ZSA9IDApO1xuICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgZW5kIHx8IChlbmQgPSB0aGlzLmxlbmd0aCk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cbiAgaWYgKCEodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBpcyBub3QgYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgPCBzdGFydCcpO1xuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0aGlzLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5maWxsKHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCArIHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgZW5kIHx8IChlbmQgPSB0aGlzLmxlbmd0aCk7XG4gIHRhcmdldF9zdGFydCB8fCAodGFyZ2V0X3N0YXJ0ID0gMCk7XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0Jyk7XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRhcmdldC5sZW5ndGggPT0gMCB8fCBzb3VyY2UubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuY29weSh0YXJnZXQucGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfc3RhcnQgKyB0YXJnZXQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCArIHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIGlmIChzdGFydCA+IGVuZCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLnBhcmVudCwgZW5kIC0gc3RhcnQsICtzdGFydCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gTGVnYWN5IG1ldGhvZHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5CdWZmZXIucHJvdG90eXBlLnV0ZjhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdiaW5hcnknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2FzY2lpJywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAndXRmOCcpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYmluYXJ5Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpV3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2FzY2lpJyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDg7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDE2O1xuICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCA4O1xuICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA8PCAyNCA+Pj4gMCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPDwgMTY7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgdmFsID0gdmFsICsgKGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdIDw8IDI0ID4+PiAwKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBTaWduZWQgaW50ZWdlciB0eXBlcywgeWF5IHRlYW0hIEEgcmVtaW5kZXIgb24gaG93IHR3bydzIGNvbXBsZW1lbnQgYWN0dWFsbHlcbiAqIHdvcmtzLiBUaGUgZmlyc3QgYml0IGlzIHRoZSBzaWduZWQgYml0LCBpLmUuIHRlbGxzIHVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICogbnVtYmVyIHNob3VsZCBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS4gSWYgdGhlIHR3bydzIGNvbXBsZW1lbnQgdmFsdWUgaXNcbiAqIHBvc2l0aXZlLCB0aGVuIHdlJ3JlIGRvbmUsIGFzIGl0J3MgZXF1aXZhbGVudCB0byB0aGUgdW5zaWduZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogTm93IGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHlvdSdyZSBwcmV0dHkgbXVjaCBkb25lLCB5b3UgY2FuIGp1c3QgbGV2ZXJhZ2VcbiAqIHRoZSB1bnNpZ25lZCB0cmFuc2xhdGlvbnMgYW5kIHJldHVybiB0aG9zZS4gVW5mb3J0dW5hdGVseSwgbmVnYXRpdmUgbnVtYmVyc1xuICogYXJlbid0IHF1aXRlIHRoYXQgc3RyYWlnaHRmb3J3YXJkLlxuICpcbiAqIEF0IGZpcnN0IGdsYW5jZSwgb25lIG1pZ2h0IGJlIGluY2xpbmVkIHRvIHVzZSB0aGUgdHJhZGl0aW9uYWwgZm9ybXVsYSB0b1xuICogdHJhbnNsYXRlIGJpbmFyeSBudW1iZXJzIGJldHdlZW4gdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgaW4gdHdvJ3NcbiAqIGNvbXBsZW1lbnQuIChUaG91Z2ggaXQgZG9lc24ndCBxdWl0ZSB3b3JrIGZvciB0aGUgbW9zdCBuZWdhdGl2ZSB2YWx1ZSlcbiAqIE1haW5seTpcbiAqICAtIGludmVydCBhbGwgdGhlIGJpdHNcbiAqICAtIGFkZCBvbmUgdG8gdGhlIHJlc3VsdFxuICpcbiAqIE9mIGNvdXJzZSwgdGhpcyBkb2Vzbid0IHF1aXRlIHdvcmsgaW4gSmF2YXNjcmlwdC4gVGFrZSBmb3IgZXhhbXBsZSB0aGUgdmFsdWVcbiAqIG9mIC0xMjguIFRoaXMgY291bGQgYmUgcmVwcmVzZW50ZWQgaW4gMTYgYml0cyAoYmlnLWVuZGlhbikgYXMgMHhmZjgwLiBCdXQgb2ZcbiAqIGNvdXJzZSwgSmF2YXNjcmlwdCB3aWxsIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogPiB+MHhmZjgwXG4gKiAtNjU0MDlcbiAqXG4gKiBXaG9oIHRoZXJlLCBKYXZhc2NyaXB0LCB0aGF0J3Mgbm90IHF1aXRlIHJpZ2h0LiBCdXQgd2FpdCwgYWNjb3JkaW5nIHRvXG4gKiBKYXZhc2NyaXB0IHRoYXQncyBwZXJmZWN0bHkgY29ycmVjdC4gV2hlbiBKYXZhc2NyaXB0IGVuZHMgdXAgc2VlaW5nIHRoZVxuICogY29uc3RhbnQgMHhmZjgwLCBpdCBoYXMgbm8gbm90aW9uIHRoYXQgaXQgaXMgYWN0dWFsbHkgYSBzaWduZWQgbnVtYmVyLiBJdFxuICogYXNzdW1lcyB0aGF0IHdlJ3ZlIGlucHV0IHRoZSB1bnNpZ25lZCB2YWx1ZSAweGZmODAuIFRodXMsIHdoZW4gaXQgZG9lcyB0aGVcbiAqIGJpbmFyeSBuZWdhdGlvbiwgaXQgY2FzdHMgaXQgaW50byBhIHNpZ25lZCB2YWx1ZSwgKHBvc2l0aXZlIDB4ZmY4MCkuIFRoZW5cbiAqIHdoZW4geW91IHBlcmZvcm0gYmluYXJ5IG5lZ2F0aW9uIG9uIHRoYXQsIGl0IHR1cm5zIGl0IGludG8gYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogSW5zdGVhZCwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB1c2UgdGhlIGZvbGxvd2luZyBnZW5lcmFsIGZvcm11bGEsIHRoYXQgd29ya3NcbiAqIGluIGEgcmF0aGVyIEphdmFzY3JpcHQgZnJpZW5kbHkgd2F5LiBJJ20gZ2xhZCB3ZSBkb24ndCBzdXBwb3J0IHRoaXMga2luZCBvZlxuICogd2VpcmQgbnVtYmVyaW5nIHNjaGVtZSBpbiB0aGUga2VybmVsLlxuICpcbiAqIChCSVQtTUFYIC0gKHVuc2lnbmVkKXZhbCArIDEpICogLTFcbiAqXG4gKiBUaGUgYXN0dXRlIG9ic2VydmVyLCBtYXkgdGhpbmsgdGhhdCB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgOC1iaXQgbnVtYmVyc1xuICogKHJlYWxseSBpdCBpc24ndCBuZWNlc3NhcnkgZm9yIHRoZW0pLiBIb3dldmVyLCB3aGVuIHlvdSBnZXQgMTYtYml0IG51bWJlcnMsXG4gKiB5b3UgZG8uIExldCdzIGdvIGJhY2sgdG8gb3VyIHByaW9yIGV4YW1wbGUgYW5kIHNlZSBob3cgdGhpcyB3aWxsIGxvb2s6XG4gKlxuICogKDB4ZmZmZiAtIDB4ZmY4MCArIDEpICogLTFcbiAqICgweDAwN2YgKyAxKSAqIC0xXG4gKiAoMHgwMDgwKSAqIC0xXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuICB2YXIgbmVnO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIG5lZyA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gJiAweDgwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSk7XG4gIH1cblxuICByZXR1cm4gKCgweGZmIC0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSArIDEpICogLTEpO1xufTtcblxuZnVuY3Rpb24gcmVhZEludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIG5lZywgdmFsO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhbCA9IHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIG5lZyA9IHZhbCAmIDB4ODAwMDtcbiAgaWYgKCFuZWcpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwMDAwMDtcbiAgaWYgKCFuZWcpIHtcbiAgICByZXR1cm4gKHZhbCk7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkRmxvYXQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS5yZWFkSUVFRTc1NChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWREb3VibGUoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS5yZWFkSUVFRTc1NChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdCBpc1xuICogbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3QgZXhjZWVkIHRoZVxuICogbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICpcbiAqICAgICAgdmFsdWUgICAgICAgICAgIFRoZSBudW1iZXIgdG8gY2hlY2sgZm9yIHZhbGlkaXR5XG4gKlxuICogICAgICBtYXggICAgICAgICAgICAgVGhlIG1heGltdW0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50KHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gMCxcbiAgICAgICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZik7XG4gIH1cblxuICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdID0gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdID0gKHZhbHVlICYgMHhmZjAwKSA+Pj4gODtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9IHZhbHVlICYgMHgwMGZmO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZjAwKSA+Pj4gODtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdID0gdmFsdWUgJiAweDAwZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdID0gKHZhbHVlID4+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBXZSBub3cgbW92ZSBvbnRvIG91ciBmcmllbmRzIGluIHRoZSBzaWduZWQgbnVtYmVyIGNhdGVnb3J5LiBVbmxpa2UgdW5zaWduZWRcbiAqIG51bWJlcnMsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gd29ycnkgYSBiaXQgbW9yZSBhYm91dCBob3cgd2UgcHV0IHZhbHVlcyBpbnRvXG4gKiBhcnJheXMuIFNpbmNlIHdlIGFyZSBvbmx5IHdvcnJ5aW5nIGFib3V0IHNpZ25lZCAzMi1iaXQgdmFsdWVzLCB3ZSdyZSBpblxuICogc2xpZ2h0bHkgYmV0dGVyIHNoYXBlLiBVbmZvcnR1bmF0ZWx5LCB3ZSByZWFsbHkgY2FuJ3QgZG8gb3VyIGZhdm9yaXRlIGJpbmFyeVxuICogJiBpbiB0aGlzIHN5c3RlbS4gSXQgcmVhbGx5IHNlZW1zIHRvIGRvIHRoZSB3cm9uZyB0aGluZy4gRm9yIGV4YW1wbGU6XG4gKlxuICogPiAtMzIgJiAweGZmXG4gKiAyMjRcbiAqXG4gKiBXaGF0J3MgaGFwcGVuaW5nIGFib3ZlIGlzIHJlYWxseTogMHhlMCAmIDB4ZmYgPSAweGUwLiBIb3dldmVyLCB0aGUgcmVzdWx0cyBvZlxuICogdGhpcyBhcmVuJ3QgdHJlYXRlZCBhcyBhIHNpZ25lZCBudW1iZXIuIFVsdGltYXRlbHkgYSBiYWQgdGhpbmcuXG4gKlxuICogV2hhdCB3ZSdyZSBnb2luZyB0byB3YW50IHRvIGRvIGlzIGJhc2ljYWxseSBjcmVhdGUgdGhlIHVuc2lnbmVkIGVxdWl2YWxlbnQgb2ZcbiAqIG91ciByZXByZXNlbnRhdGlvbiBhbmQgcGFzcyB0aGF0IG9mZiB0byB0aGUgd3VpbnQqIGZ1bmN0aW9ucy4gVG8gZG8gdGhhdFxuICogd2UncmUgZ29pbmcgdG8gZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgcG9zaXRpdmVcbiAqICAgICAgd2UgY2FuIHBhc3MgaXQgZGlyZWN0bHkgb2ZmIHRvIHRoZSBlcXVpdmFsZW50IHd1aW50XG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAqICAgICAgd2UgZG8gdGhlIGZvbGxvd2luZyBjb21wdXRhdGlvbjpcbiAqICAgICAgICAgbWIgKyB2YWwgKyAxLCB3aGVyZVxuICogICAgICAgICBtYiAgIGlzIHRoZSBtYXhpbXVtIHVuc2lnbmVkIHZhbHVlIGluIHRoYXQgYnl0ZSBzaXplXG4gKiAgICAgICAgIHZhbCAgaXMgdGhlIEphdmFzY3JpcHQgbmVnYXRpdmUgaW50ZWdlclxuICpcbiAqXG4gKiBBcyBhIGNvbmNyZXRlIHZhbHVlLCB0YWtlIC0xMjguIEluIHNpZ25lZCAxNiBiaXRzIHRoaXMgd291bGQgYmUgMHhmZjgwLiBJZlxuICogeW91IGRvIG91dCB0aGUgY29tcHV0YXRpb25zOlxuICpcbiAqIDB4ZmZmZiAtIDEyOCArIDFcbiAqIDB4ZmZmZiAtIDEyN1xuICogMHhmZjgwXG4gKlxuICogWW91IGNhbiB0aGVuIGVuY29kZSB0aGlzIHZhbHVlIGFzIHRoZSBzaWduZWQgdmVyc2lvbi4gVGhpcyBpcyByZWFsbHkgcmF0aGVyXG4gKiBoYWNreSwgYnV0IGl0IHNob3VsZCB3b3JrIGFuZCBnZXQgdGhlIGpvYiBkb25lIHdoaWNoIGlzIG91ciBnb2FsIGhlcmUuXG4gKi9cblxuLypcbiAqIEEgc2VyaWVzIG9mIGNoZWNrcyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHNpZ25lZCAzMi1iaXQgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIHZlcmlmc2ludCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGbG9hdChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS53cml0ZUlFRUU3NTQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS53cml0ZUlFRUU3NTQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFO1xuXG59LHtcImFzc2VydFwiOjEsXCIuL2J1ZmZlcl9pZWVlNzU0XCI6OCxcImJhc2U2NC1qc1wiOjl9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheShiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcblx0XG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnO1xuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHRwbGFjZUhvbGRlcnMgPSBiNjQuaW5kZXhPZignPScpO1xuXHRcdHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gcGxhY2VIb2xkZXJzIDogMDtcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IFtdOy8vbmV3IFVpbnQ4QXJyYXkoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTtcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDE4KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCAxMikgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAyXSkgPDwgNikgfCBsb29rdXAuaW5kZXhPZihiNjRbaSArIDNdKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOCk7XG5cdFx0XHRhcnIucHVzaCh0bXAgJiAweEZGKTtcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAobG9va3VwLmluZGV4T2YoYjY0W2ldKSA8PCAyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA+PiA0KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAobG9va3VwLmluZGV4T2YoYjY0W2ldKSA8PCAxMCkgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPDwgNCkgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAyXSkgPj4gMik7XG5cdFx0XHRhcnIucHVzaCgodG1wID4+IDgpICYgMHhGRik7XG5cdFx0XHRhcnIucHVzaCh0bXAgJiAweEZGKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoO1xuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXTtcblx0XHR9O1xuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApO1xuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgNCkgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFt0ZW1wID4+IDEwXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA+PiA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wIDw8IDIpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSAnPSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5O1xuXHRtb2R1bGUuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NDtcbn0oKSk7XG5cbn0se31dfSx7fSxbXSlcbjs7bW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcImJ1ZmZlci1icm93c2VyaWZ5XCIpXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiJdfQ==
;